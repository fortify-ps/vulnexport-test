{
  "$schema" : "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
  "version" : "2.1.0",
  "runs" : [ {
    "tool" : {
      "driver" : {
        "name" : "Fortify SCA",
        "version" : "5.7.0.0025",
        "rules" : [ {
          "id" : "635",
          "shortDescription" : {
            "text" : "Race Condition: Singleton Member Field"
          },
          "fullDescription" : {
            "text" : "The class HammerHead is a singleton, so the member field mySession is shared between users.  The result is that one user could see another user's data.\n\n\n"
          },
          "help" : {
            "text" : "Many Servlet developers do not understand that, unless a Servlet implements the SingleThreadModel interface, the Servlet is a singleton; there is only one instance of the Servlet, and that single instance is used and re-used to handle multiple requests that are processed simultaneously by different threads. \n\nA common result of this misunderstanding is that developers use Servlet member fields in such a way that one user may inadvertently see another user's data. In other words, storing user data in Servlet member fields introduces a data access race condition.\n\nExample 1: The following Servlet stores the value of a request parameter in a member field and then later echoes the parameter value to the response output stream.\n\n\npublic class GuestBook extends HttpServlet {\n\n   String name;\n\n   protected void doPost (HttpServletRequest req,\n                       HttpServletResponse res) {\n     name = req.getParameter(\"name\");\n     ...\n     out.println(name + \", thanks for visiting!\");\n   }\n}\n\n\nWhile this code will work perfectly in a single-user environment, if two users access the Servlet at approximately the same time, it is possible for the two request handler threads to interleave in the following way:\n\n\tThread 1:\tassign \"Dick\" to name\n\tThread 2:\tassign \"Jane\" to name\n\tThread 1:\tprint \"Jane, thanks for visiting!\"\n\tThread 2:\tprint \"Jane, thanks for visiting!\"\n\n Thereby showing the first user the second user's name.\n\nDo not use Servlet member fields for anything but constants. (i.e. make all member fields static final).\n\nDevelopers are often tempted to use Servlet member fields for user data when they need to transport data from one region of code to another. If this is your aim, consider declaring a separate class and using the Servlet only to \"wrap\" this new class. \n\nExample 2: The bug in the example above can be corrected in the following way:\n\n\npublic class GuestBook extends HttpServlet {\n\n   protected void doPost (HttpServletRequest req,\n                       HttpServletResponse res) {\n\tGBRequestHandler handler = new GBRequestHandler();\n\thandler.handle(req, res);\n   }\n}\n\npublic class GBRequestHandler {\n\n   String name;\n\n   public void handle(HttpServletRequest req,\n                       HttpServletResponse res) {\n     name = req.getParameter(\"name\");\n     ...\n     out.println(name + \", thanks for visiting!\");\n   }\n\n}\n\n\nAlternatively, a Servlet can implement the SingleThreadModel interface, in which case the Servlet container will maintain a pool of Servlet objects and dispatch a different object to process each request. Depending on the container implementation and the needs of the application, using the SingleThreadModel interface may cause significant performance problems.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/635/?engineType=SCA&issue=E2D4A2D542D71542FC025DF66EF28C26"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "542",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function doPost() in HammerHead.java might reveal system data or debugging information by calling printStackTrace() on line 192.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/542/?engineType=SCA&issue=B98B6B12E7E2107A2C5FB412E8074669"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "537",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function doPost() in HammerHead.java might reveal system data or debugging information by calling log() on line 193.  The information revealed by log() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/537/?engineType=SCA&issue=B7C1C1CB2A70786BA5A237EC0231FBC0"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "604",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function doPost() in HammerHead.java might reveal system data or debugging information by calling printStackTrace() on line 204.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/604/?engineType=SCA&issue=D7EA539980EA0892CA2126A54762616A"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "605",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function doPost() in HammerHead.java might reveal system data or debugging information by calling printStackTrace() on line 204.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/605/?engineType=SCA&issue=D7EA539980EA0892CA2126A54762616B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "606",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function doPost() in HammerHead.java might reveal system data or debugging information by calling printStackTrace() on line 204.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/606/?engineType=SCA&issue=D7EA539980EA0892CA2126A54762616C"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "377",
          "shortDescription" : {
            "text" : "Log Forging"
          },
          "fullDescription" : {
            "text" : "The method doPost() in HammerHead.java writes unvalidated user input to the log on line 205.  An attacker could take advantage of this behavior to forge log entries or inject malicious content into the log.\n\n\n"
          },
          "help" : {
            "text" : "Log forging vulnerabilities occur when:\n\n1. Data enters an application from an untrusted source. \n\nIn this case the data enters at getHeader() in HammerHead.java at line 177. \n\n2. The data is written to an application or system log file. \n\nIn this case the data is logged by log() in HammerHead.java at line 205.\n\nApplications typically use log files to store a history of events or transactions for later review, statistics gathering, or debugging. Depending on the nature of the application, the task of reviewing log files may be performed manually on an as-needed basis or automated with a tool that automatically culls logs for important events or trending information.\n\nInterpretation of the log files may be hindered or misdirected if an attacker can supply data to the application that is subsequently logged verbatim. In the most benign case, an attacker may be able to insert false entries into the log file by providing the application with input that includes appropriate characters. If the log file is processed automatically, the attacker can render the file unusable by corrupting the format of the file or injecting unexpected characters. A more subtle attack might involve skewing the log file statistics. Forged or otherwise, corrupted log files can be used to cover an attacker's tracks or even to implicate another party in the commission of a malicious act [1]. In the worst case, an attacker may inject code or other commands into the log file and take advantage of a vulnerability in the log processing utility [2].\n\nExample: The following web application code attempts to read an integer value from a request object. If the value fails to parse as an integer, then the input is logged with an error message indicating what happened. \n\n\nString val = request.getParameter(\"val\");\ntry {\n  int value = Integer.parseInt(val);\n}\ncatch (NumberFormatException) {\n  log.info(\"Failed to parse val = \" + val);\n}\n\n\nIf a user submits the string \"twenty-one\" for val, the following entry is logged:\n\n\nINFO: Failed to parse val=twenty-one\n\n\nHowever, if an attacker submits the string \"twenty-one%0a%0aINFO:+User+logged+out%3dbadguy\", the following entry is logged:\n\n\nINFO: Failed to parse val=twenty-one\n\nINFO: User logged out=badguy\n\n\nClearly, attackers can use this same mechanism to insert arbitrary log entries.\n\nPrevent log forging attacks with indirection: create a set of legitimate log entries that correspond to different events that must be logged and only log entries from this set. To capture dynamic content, such as users logging out of the system, always use server-controlled values rather than user-supplied data. This ensures that the input provided by the user is never used directly in a log entry. \n\nIn some situations this approach is impractical because the set of legitimate log entries is too large or complicated. In these situations, developers often fall back on blacklisting. Blacklisting selectively rejects or escapes potentially dangerous characters before using the input. However, a list of unsafe characters can quickly become incomplete or outdated. A better approach is to create a white list of characters that are allowed to appear in log entries and accept input composed exclusively of characters in the approved set. The most critical character in most log forging attacks is the '\n' (newline) character, which should never appear on a log entry white list.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/377/?engineType=SCA&issue=81E68A780910D710E6290EA2FEFC6A98"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "582",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/582/?engineType=SCA&issue=CBC1A299785CBB6162BAC7CE6631AC42"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "583",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/583/?engineType=SCA&issue=CBC1A299785CBB6162BAC7CE6631AC43"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "176",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function log() in HammerHead.java might reveal system data or debugging information by calling log() on line 306.  The information revealed by log() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/176/?engineType=SCA&issue=395FF4482C440E0DFFFDBE3D38ACE125"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "476",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function log() in HammerHead.java might reveal system data or debugging information by calling log() on line 306.  The information revealed by log() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/476/?engineType=SCA&issue=A442B6350AC6E369A724F565263FE717"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1606",
          "shortDescription" : {
            "text" : "Log Forging"
          },
          "fullDescription" : {
            "text" : "The method log() in HammerHead.java writes unvalidated user input to the log on line 306.  An attacker could take advantage of this behavior to forge log entries or inject malicious content into the log.\n\n\n"
          },
          "help" : {
            "text" : "Log forging vulnerabilities occur when:\n\n1. Data enters an application from an untrusted source. \n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 593. \n\n2. The data is written to an application or system log file. \n\nIn this case the data is logged by log() in HammerHead.java at line 306.\n\nApplications typically use log files to store a history of events or transactions for later review, statistics gathering, or debugging. Depending on the nature of the application, the task of reviewing log files may be performed manually on an as-needed basis or automated with a tool that automatically culls logs for important events or trending information.\n\nInterpretation of the log files may be hindered or misdirected if an attacker can supply data to the application that is subsequently logged verbatim. In the most benign case, an attacker may be able to insert false entries into the log file by providing the application with input that includes appropriate characters. If the log file is processed automatically, the attacker can render the file unusable by corrupting the format of the file or injecting unexpected characters. A more subtle attack might involve skewing the log file statistics. Forged or otherwise, corrupted log files can be used to cover an attacker's tracks or even to implicate another party in the commission of a malicious act [1]. In the worst case, an attacker may inject code or other commands into the log file and take advantage of a vulnerability in the log processing utility [2].\n\nExample: The following web application code attempts to read an integer value from a request object. If the value fails to parse as an integer, then the input is logged with an error message indicating what happened. \n\n\nString val = request.getParameter(\"val\");\ntry {\n  int value = Integer.parseInt(val);\n}\ncatch (NumberFormatException) {\n  log.info(\"Failed to parse val = \" + val);\n}\n\n\nIf a user submits the string \"twenty-one\" for val, the following entry is logged:\n\n\nINFO: Failed to parse val=twenty-one\n\n\nHowever, if an attacker submits the string \"twenty-one%0a%0aINFO:+User+logged+out%3dbadguy\", the following entry is logged:\n\n\nINFO: Failed to parse val=twenty-one\n\nINFO: User logged out=badguy\n\n\nClearly, attackers can use this same mechanism to insert arbitrary log entries.\n\nPrevent log forging attacks with indirection: create a set of legitimate log entries that correspond to different events that must be logged and only log entries from this set. To capture dynamic content, such as users logging out of the system, always use server-controlled values rather than user-supplied data. This ensures that the input provided by the user is never used directly in a log entry. \n\nIn some situations this approach is impractical because the set of legitimate log entries is too large or complicated. In these situations, developers often fall back on blacklisting. Blacklisting selectively rejects or escapes potentially dangerous characters before using the input. However, a list of unsafe characters can quickly become incomplete or outdated. A better approach is to create a white list of characters that are allowed to appear in log entries and accept input composed exclusively of characters in the approved set. The most critical character in most log forging attacks is the '\n' (newline) character, which should never appear on a log entry white list.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1606/?engineType=SCA&issue=3E3C937B3D0198B6F1DE184BAF51F1E6"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1608",
          "shortDescription" : {
            "text" : "Log Forging"
          },
          "fullDescription" : {
            "text" : "The method log() in HammerHead.java writes unvalidated user input to the log on line 306.  An attacker could take advantage of this behavior to forge log entries or inject malicious content into the log.\n\n\n"
          },
          "help" : {
            "text" : "Log forging vulnerabilities occur when:\n\n1. Data enters an application from an untrusted source. \n\nIn this case the data enters at getParameterNames() in ParameterParser.java at line 576. \n\n2. The data is written to an application or system log file. \n\nIn this case the data is logged by log() in HammerHead.java at line 306.\n\nApplications typically use log files to store a history of events or transactions for later review, statistics gathering, or debugging. Depending on the nature of the application, the task of reviewing log files may be performed manually on an as-needed basis or automated with a tool that automatically culls logs for important events or trending information.\n\nInterpretation of the log files may be hindered or misdirected if an attacker can supply data to the application that is subsequently logged verbatim. In the most benign case, an attacker may be able to insert false entries into the log file by providing the application with input that includes appropriate characters. If the log file is processed automatically, the attacker can render the file unusable by corrupting the format of the file or injecting unexpected characters. A more subtle attack might involve skewing the log file statistics. Forged or otherwise, corrupted log files can be used to cover an attacker's tracks or even to implicate another party in the commission of a malicious act [1]. In the worst case, an attacker may inject code or other commands into the log file and take advantage of a vulnerability in the log processing utility [2].\n\nExample: The following web application code attempts to read an integer value from a request object. If the value fails to parse as an integer, then the input is logged with an error message indicating what happened. \n\n\nString val = request.getParameter(\"val\");\ntry {\n  int value = Integer.parseInt(val);\n}\ncatch (NumberFormatException) {\n  log.info(\"Failed to parse val = \" + val);\n}\n\n\nIf a user submits the string \"twenty-one\" for val, the following entry is logged:\n\n\nINFO: Failed to parse val=twenty-one\n\n\nHowever, if an attacker submits the string \"twenty-one%0a%0aINFO:+User+logged+out%3dbadguy\", the following entry is logged:\n\n\nINFO: Failed to parse val=twenty-one\n\nINFO: User logged out=badguy\n\n\nClearly, attackers can use this same mechanism to insert arbitrary log entries.\n\nPrevent log forging attacks with indirection: create a set of legitimate log entries that correspond to different events that must be logged and only log entries from this set. To capture dynamic content, such as users logging out of the system, always use server-controlled values rather than user-supplied data. This ensures that the input provided by the user is never used directly in a log entry. \n\nIn some situations this approach is impractical because the set of legitimate log entries is too large or complicated. In these situations, developers often fall back on blacklisting. Blacklisting selectively rejects or escapes potentially dangerous characters before using the input. However, a list of unsafe characters can quickly become incomplete or outdated. A better approach is to create a white list of characters that are allowed to appear in log entries and accept input composed exclusively of characters in the approved set. The most critical character in most log forging attacks is the '\n' (newline) character, which should never appear on a log entry white list.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1608/?engineType=SCA&issue=4179E644761CD4A3FAF2F275662F135A"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "116",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/116/?engineType=SCA&issue=2770E49728E1EE378BC0BD7B34A122C9"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "444",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function log() in HammerHead.java might reveal system data or debugging information by calling println() on line 307.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/444/?engineType=SCA&issue=99230E892495D721C9D0F9664711B616"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "496",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function log() in HammerHead.java might reveal system data or debugging information by calling println() on line 307.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/496/?engineType=SCA&issue=AB4E42C5163F2C47C0CE0592AD5E896C"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "329",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function doPost() in LessonSource.java might reveal system data or debugging information by calling printStackTrace() on line 93.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/329/?engineType=SCA&issue=71BF097995A06C0A5E79ED93F9DFA30B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1025",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function doPost() in LessonSource.java might reveal system data or debugging information by calling log() on line 94.  The information revealed by log() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1025/?engineType=SCA&issue=01C7651E942A3833D17DC17AB436A13F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "108",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function doPost() in LessonSource.java might reveal system data or debugging information by calling printStackTrace() on line 104.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/108/?engineType=SCA&issue=2509DC39A77F6D65BBCF8ACCFF657FFE"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "646",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at AbstractLesson.java line 420 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/646/?engineType=SCA&issue=E80E51AB9225B4EA3FA4674302DC130A"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "553",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getFileMethod() in AbstractLesson.java might reveal system data or debugging information by calling println() on line 422.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/553/?engineType=SCA&issue=BC4C3AFB66A9949C193A3809DDA9E40C"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "629",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/629/?engineType=SCA&issue=DEF38D529FC2FAD74E4EB1C518722812"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "667",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getFileMethod() in AbstractLesson.java might reveal system data or debugging information by calling printStackTrace() on line 423.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/667/?engineType=SCA&issue=F0AF230D6D4B8FD61D448F00098EF862"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "707",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at AbstractLesson.java line 476 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/707/?engineType=SCA&issue=F93C83B4FFD27A376FB49DE36A9D44D2"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "93",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getFileText() in AbstractLesson.java might reveal system data or debugging information by calling println() on line 478.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/93/?engineType=SCA&issue=1E98A6F7A122158FAD7179B0502E34B1"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "117",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/117/?engineType=SCA&issue=27BC666113F2CFC868E3CA65D2C89F34"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "601",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getFileText() in AbstractLesson.java might reveal system data or debugging information by calling printStackTrace() on line 479.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/601/?engineType=SCA&issue=D76FD51A11E5483E308232F0748769C5"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1204",
          "shortDescription" : {
            "text" : "Unreleased Resource: Streams"
          },
          "fullDescription" : {
            "text" : "The function getLessonPlan() in AbstractLesson.java sometimes fails to release a system resource allocated by FileReader() on line 567.\n\n\n"
          },
          "help" : {
            "text" : "The program can potentially fail to release a system resource.\n\n    In this case, there are program paths on which the resource allocated in AbstractLesson.java at line 567 is not released.\n\n\nResource leaks have at least two common causes:\n\n- Error conditions and other exceptional circumstances.\n\n- Confusion over which part of the program is responsible for releasing the resource.\n\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.\n\nExample 1: The following method never closes the file handle it opens. The finalize() method for FileInputStream eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n\n\nprivate void processFile(String fName) throws FileNotFoundException, IOException\n{\n  FileInputStream fis = new FileInputStream(fName);\n  int sz;\n  byte[] byteArray = new byte[BLOCK_SIZE];\n  while ((sz = fis.read(byteArray)) != -1) {\n    processBytes(byteArray, sz);\n  }\n}\n\n\nExample 2: Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.\n\n\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(CXN_SQL);\n  harvestResults(rs);\n  stmt.close();\n\n\n\n1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to \"bursty\" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.\n\nFinally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang. \n\n2. Release resources in a finally block. The code for Example 2 should be rewritten as follows:\n\n\n  public void execCxnSql(Connection conn) {\n    Statement stmt;\n    try {\n      stmt = conn.createStatement();\n      ResultSet rs = stmt.executeQuery(CXN_SQL);\n      ...\n    }\n    finally {\n      if (stmt != null) {\n        safeClose(stmt);\n      }\n    }\n}\n\npublic static void safeClose(Statement stmt) {\n  if (stmt != null) {\n    try {\n      stmt.close();\n    } catch (SQLException e) {\n      log(e);\n    }\n  }\n}\n\n\nThis solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. \n\nAlso, the execCxnSql method does not initialize the stmt object to null. Instead, it checks to ensure that stmt is not null before calling safeClose(). Without the null check, the Java compiler reports that stmt might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  stmt is initialized to null in a more complex method, cases in which stmt is used without being initialized will not be detected by the compiler. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1204/?engineType=SCA&issue=8D2F9470457AA1DBB019D65452C98DCC"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1067",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at AbstractLesson.java line 571 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1067/?engineType=SCA&issue=20BA5BBCC9DDDA06B46463E3D6B3E983"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1162",
          "shortDescription" : {
            "text" : "Unreleased Resource: Streams"
          },
          "fullDescription" : {
            "text" : "The function getSource() in AbstractLesson.java sometimes fails to release a system resource allocated by FileReader() on line 670.\n\n\n"
          },
          "help" : {
            "text" : "The program can potentially fail to release a system resource.\n\n    In this case, there are program paths on which the resource allocated in AbstractLesson.java at line 670 is not released.\n\n\nResource leaks have at least two common causes:\n\n- Error conditions and other exceptional circumstances.\n\n- Confusion over which part of the program is responsible for releasing the resource.\n\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.\n\nExample 1: The following method never closes the file handle it opens. The finalize() method for FileInputStream eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n\n\nprivate void processFile(String fName) throws FileNotFoundException, IOException\n{\n  FileInputStream fis = new FileInputStream(fName);\n  int sz;\n  byte[] byteArray = new byte[BLOCK_SIZE];\n  while ((sz = fis.read(byteArray)) != -1) {\n    processBytes(byteArray, sz);\n  }\n}\n\n\nExample 2: Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.\n\n\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(CXN_SQL);\n  harvestResults(rs);\n  stmt.close();\n\n\n\n1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to \"bursty\" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.\n\nFinally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang. \n\n2. Release resources in a finally block. The code for Example 2 should be rewritten as follows:\n\n\n  public void execCxnSql(Connection conn) {\n    Statement stmt;\n    try {\n      stmt = conn.createStatement();\n      ResultSet rs = stmt.executeQuery(CXN_SQL);\n      ...\n    }\n    finally {\n      if (stmt != null) {\n        safeClose(stmt);\n      }\n    }\n}\n\npublic static void safeClose(Statement stmt) {\n  if (stmt != null) {\n    try {\n      stmt.close();\n    } catch (SQLException e) {\n      log(e);\n    }\n  }\n}\n\n\nThis solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. \n\nAlso, the execCxnSql method does not initialize the stmt object to null. Instead, it checks to ensure that stmt is not null before calling safeClose(). Without the null check, the Java compiler reports that stmt might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  stmt is initialized to null in a more complex method, cases in which stmt is used without being initialized will not be detected by the compiler. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1162/?engineType=SCA&issue=6A452E3BFF473737F95196432C59610A"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "228",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 801 of AbstractLesson.java, the method isAuthorized() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\nIn this case Fortify could not determine that the source of the data is trusted.\n\n2. The data is used to dynamically construct a SQL query. \n\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.  \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one used in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can: \n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but when user-supplied data needs to be included, they create bind parameters, which are placeholders for data that is subsequently inserted. Bind parameters allow the program to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for the value of each of the bind parameters, without the risk of the data being interpreted as commands. \n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n        \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the command structure of the SQL statement, such as the addition of dynamic constraints in the WHERE clause. Do not use this requirement to justify concatenating user input into query strings. Prevent SQL injection attacks where user input must affect statement command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/228/?engineType=SCA&issue=4B43C1C4D3D99D2A7DFE1A2192D7A6AB"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "600",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function isAuthorized() in AbstractLesson.java might reveal system data or debugging information by calling printStackTrace() on line 807.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/600/?engineType=SCA&issue=D613F7CF5C9DCE819D72E14B4C1612FB"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1086",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at AbstractLesson.java line 810 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1086/?engineType=SCA&issue=30F39BBC28D0369D663791E91DDFBFA6"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "245",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function isAuthorized() in AbstractLesson.java might reveal system data or debugging information by calling printStackTrace() on line 813.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/245/?engineType=SCA&issue=52AB825BF8B0D376878A2332E3C287FB"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1801",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method makeParamDump_DELETEME() in AbstractLesson.java sends unvalidated data to a web browser on line 872, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterNames() in ParameterParser.java at line 576. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at LI() in AbstractLesson.java at line 872.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1801/?engineType=SCA&issue=E37E79651849FC3D1A90C1ABAD6E637D"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1819",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method makeParamDump_DELETEME() in AbstractLesson.java sends unvalidated data to a web browser on line 872, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 593. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at LI() in AbstractLesson.java at line 872.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1819/?engineType=SCA&issue=EEC853E23854174F9A6951A9CC55840E"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1219",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at AbstractLesson.java line 903 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1219/?engineType=SCA&issue=9BCF360F710A55757FC8BD2BCC652BF0"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1139",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method makeRequestDump_DELETEME() in AbstractLesson.java sends unvalidated data to a web browser on line 920, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getReader() in AbstractLesson.java at line 900. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at addElement() in AbstractLesson.java at line 920.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1139/?engineType=SCA&issue=56F91135D0561F50D05F151536F819F8"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1298",
          "shortDescription" : {
            "text" : "Unreleased Resource: Streams"
          },
          "fullDescription" : {
            "text" : "The function makeSourceDump_DELETEME() in AbstractLesson.java sometimes fails to release a system resource allocated by FileReader() on line 955.\n\n\n"
          },
          "help" : {
            "text" : "The program can potentially fail to release a system resource.\n\n    In this case, there are program paths on which the resource allocated in AbstractLesson.java at line 955 is not released.\n\n\nResource leaks have at least two common causes:\n\n- Error conditions and other exceptional circumstances.\n\n- Confusion over which part of the program is responsible for releasing the resource.\n\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.\n\nExample 1: The following method never closes the file handle it opens. The finalize() method for FileInputStream eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n\n\nprivate void processFile(String fName) throws FileNotFoundException, IOException\n{\n  FileInputStream fis = new FileInputStream(fName);\n  int sz;\n  byte[] byteArray = new byte[BLOCK_SIZE];\n  while ((sz = fis.read(byteArray)) != -1) {\n    processBytes(byteArray, sz);\n  }\n}\n\n\nExample 2: Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.\n\n\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(CXN_SQL);\n  harvestResults(rs);\n  stmt.close();\n\n\n\n1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to \"bursty\" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.\n\nFinally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang. \n\n2. Release resources in a finally block. The code for Example 2 should be rewritten as follows:\n\n\n  public void execCxnSql(Connection conn) {\n    Statement stmt;\n    try {\n      stmt = conn.createStatement();\n      ResultSet rs = stmt.executeQuery(CXN_SQL);\n      ...\n    }\n    finally {\n      if (stmt != null) {\n        safeClose(stmt);\n      }\n    }\n}\n\npublic static void safeClose(Statement stmt) {\n  if (stmt != null) {\n    try {\n      stmt.close();\n    } catch (SQLException e) {\n      log(e);\n    }\n  }\n}\n\n\nThis solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. \n\nAlso, the execCxnSql method does not initialize the stmt object to null. Instead, it checks to ensure that stmt is not null before calling safeClose(). Without the null check, the Java compiler reports that stmt might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  stmt is initialized to null in a more complex method, cases in which stmt is used without being initialized will not be detected by the compiler. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1298/?engineType=SCA&issue=D56D1FEF7BB4EBA49C9A395DF0D88AC4"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1093",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1093/?engineType=SCA&issue=37635EECC3C6B321C571737A2EDF72D7"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1330",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function makeSourceDump_DELETEME() in AbstractLesson.java might reveal system data or debugging information by calling println() on line 960.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1330/?engineType=SCA&issue=F0879411EBC690469AFC6E5E7FF4EDC1"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "65",
          "shortDescription" : {
            "text" : "Unreleased Resource: Streams"
          },
          "fullDescription" : {
            "text" : "The function readFromURL() in AbstractLesson.java sometimes fails to release a system resource allocated by getInputStream() on line 1032.\n\n\n"
          },
          "help" : {
            "text" : "The program can potentially fail to release a system resource.\n\n    In this case, there are program paths on which the resource allocated in AbstractLesson.java at line 1032 is not released.\n\n\nResource leaks have at least two common causes:\n\n- Error conditions and other exceptional circumstances.\n\n- Confusion over which part of the program is responsible for releasing the resource.\n\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.\n\nExample 1: The following method never closes the file handle it opens. The finalize() method for FileInputStream eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n\n\nprivate void processFile(String fName) throws FileNotFoundException, IOException\n{\n  FileInputStream fis = new FileInputStream(fName);\n  int sz;\n  byte[] byteArray = new byte[BLOCK_SIZE];\n  while ((sz = fis.read(byteArray)) != -1) {\n    processBytes(byteArray, sz);\n  }\n}\n\n\nExample 2: Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.\n\n\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(CXN_SQL);\n  harvestResults(rs);\n  stmt.close();\n\n\n\n1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to \"bursty\" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.\n\nFinally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang. \n\n2. Release resources in a finally block. The code for Example 2 should be rewritten as follows:\n\n\n  public void execCxnSql(Connection conn) {\n    Statement stmt;\n    try {\n      stmt = conn.createStatement();\n      ResultSet rs = stmt.executeQuery(CXN_SQL);\n      ...\n    }\n    finally {\n      if (stmt != null) {\n        safeClose(stmt);\n      }\n    }\n}\n\npublic static void safeClose(Statement stmt) {\n  if (stmt != null) {\n    try {\n      stmt.close();\n    } catch (SQLException e) {\n      log(e);\n    }\n  }\n}\n\n\nThis solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. \n\nAlso, the execCxnSql method does not initialize the stmt object to null. Instead, it checks to ensure that stmt is not null before calling safeClose(). Without the null check, the Java compiler reports that stmt might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  stmt is initialized to null in a more complex method, cases in which stmt is used without being initialized will not be detected by the compiler. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/65/?engineType=SCA&issue=15C50D550084CFABCE3D6DBB896ACCE3"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "345",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at AbstractLesson.java line 1042 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/345/?engineType=SCA&issue=788548B8FF65CC4AF3A944A36AD831BA"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "237",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/237/?engineType=SCA&issue=4DB0C4C7484B1BC7DED7FD5D654E0315"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "300",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function readFromURL() in AbstractLesson.java might reveal system data or debugging information by calling println() on line 1044.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/300/?engineType=SCA&issue=63B451D8A2A6D70B0E55D1795D455FAF"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "346",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function readFromURL() in AbstractLesson.java might reveal system data or debugging information by calling printStackTrace() on line 1045.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/346/?engineType=SCA&issue=791A891A76696CCE5590E44AE11A9C91"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1307",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at AccessControlMatrix.java line 111 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1307/?engineType=SCA&issue=D85F7F08CD96663CB4852A0166EBAC84"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "244",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in AccessControlMatrix.java might reveal system data or debugging information by calling printStackTrace() on line 114.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/244/?engineType=SCA&issue=51D7D308BD3345DCA7B15A0BEB7EBE70"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1026",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Throws"
          },
          "fullDescription" : {
            "text" : "The method concept1() in BackDoors.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
          },
          "help" : {
            "text" : "Declaring a method to throw Exception or Throwable makes it difficult for callers to do good error handling and error recovery. Java's exception mechanism is set up to make it easy for callers to anticipate what can go wrong and write code to handle each specific exceptional circumstance. Declaring that a method throws a generic form of exception defeats this system.\n\nExample: The following method throws three types of exceptions.\n\n\npublic void doExchange()\n  throws IOException, InvocationTargetException,\n         SQLException {\n  ...\n}\n\n\n\nWhile it might seem tidier to write \n\n\npublic void doExchange()\n  throws Exception {\n  ...\n}\n\n\ndoing so hampers the caller's ability to understand and handle the exceptions that occur. Further, if a later revision of doExchange() introduces a new type of exception that should be treated differently than previous exceptions, there is no easy way to enforce this requirement.\n\nDo not declare methods to throw Exception or Throwable. If the exceptions thrown by a method are not recoverable or should not generally be caught by the caller, consider throwing unchecked exceptions rather than checked exceptions. This can be accomplished by implementing exception classes that extend RuntimeException or Error instead of Exception, or add a try/catch wrapper in your method to convert checked exceptions to unchecked exceptions.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1026/?engineType=SCA&issue=022767F21A8D334E484C3E7CEC2C6749"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1677",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 106 of BackDoors.java, the method concept1() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeUpdate() in BackDoors.java at line 106.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1677/?engineType=SCA&issue=7DE5CB2BC4041A1E67F217526A3B5F3A"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1637",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 113 of BackDoors.java, the method concept1() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeQuery() in BackDoors.java at line 113.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1637/?engineType=SCA&issue=675BD3A413F61AD447FA0DCCD6661859"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "452",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Persistent"
          },
          "fullDescription" : {
            "text" : "The method concept1() in BackDoors.java sends unvalidated data to a web browser on line 125, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Persistent (also known as Stored) XSS, the untrusted source is typically a database or other back-end datastore, while in the case of Reflected XSS it is typically a web request.\n\n\nIn this case the data enters at executeQuery() in BackDoors.java at line 113. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at TD() in BackDoors.java at line 125.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nThis code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. This code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nExample 2: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nAs in Example 1, this code operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- As in Example 2, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/452/?engineType=SCA&issue=9BF8789DF9C0CCB6DBF071D592563C54"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "213",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Persistent"
          },
          "fullDescription" : {
            "text" : "The method concept1() in BackDoors.java sends unvalidated data to a web browser on line 126, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Persistent (also known as Stored) XSS, the untrusted source is typically a database or other back-end datastore, while in the case of Reflected XSS it is typically a web request.\n\n\nIn this case the data enters at executeQuery() in BackDoors.java at line 113. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at TD() in BackDoors.java at line 126.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nThis code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. This code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nExample 2: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nAs in Example 1, this code operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- As in Example 2, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/213/?engineType=SCA&issue=45708E1EF2D60DAC753B122522A7537E"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "426",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Persistent"
          },
          "fullDescription" : {
            "text" : "The method concept1() in BackDoors.java sends unvalidated data to a web browser on line 127, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Persistent (also known as Stored) XSS, the untrusted source is typically a database or other back-end datastore, while in the case of Reflected XSS it is typically a web request.\n\n\nIn this case the data enters at executeQuery() in BackDoors.java at line 113. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at TD() in BackDoors.java at line 127.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nThis code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. This code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nExample 2: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nAs in Example 1, this code operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- As in Example 2, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/426/?engineType=SCA&issue=961B750FFA42A8955E468768E4F13CCF"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "193",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Persistent"
          },
          "fullDescription" : {
            "text" : "The method concept1() in BackDoors.java sends unvalidated data to a web browser on line 128, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Persistent (also known as Stored) XSS, the untrusted source is typically a database or other back-end datastore, while in the case of Reflected XSS it is typically a web request.\n\n\nIn this case the data enters at executeQuery() in BackDoors.java at line 113. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at TD() in BackDoors.java at line 128.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nThis code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. This code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nExample 2: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nAs in Example 1, this code operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- As in Example 2, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/193/?engineType=SCA&issue=3BC31286F68156D8BF9A7F34BA37635B"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1346",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at BackDoors.java line 134 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1346/?engineType=SCA&issue=FB25471481DE82711751425170451DD3"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1101",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Throws"
          },
          "fullDescription" : {
            "text" : "The method concept2() in BackDoors.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
          },
          "help" : {
            "text" : "Declaring a method to throw Exception or Throwable makes it difficult for callers to do good error handling and error recovery. Java's exception mechanism is set up to make it easy for callers to anticipate what can go wrong and write code to handle each specific exceptional circumstance. Declaring that a method throws a generic form of exception defeats this system.\n\nExample: The following method throws three types of exceptions.\n\n\npublic void doExchange()\n  throws IOException, InvocationTargetException,\n         SQLException {\n  ...\n}\n\n\n\nWhile it might seem tidier to write \n\n\npublic void doExchange()\n  throws Exception {\n  ...\n}\n\n\ndoing so hampers the caller's ability to understand and handle the exceptions that occur. Further, if a later revision of doExchange() introduces a new type of exception that should be treated differently than previous exceptions, there is no easy way to enforce this requirement.\n\nDo not declare methods to throw Exception or Throwable. If the exceptions thrown by a method are not recoverable or should not generally be caught by the caller, consider throwing unchecked exceptions rather than checked exceptions. This can be accomplished by implementing exception classes that extend RuntimeException or Error instead of Exception, or add a try/catch wrapper in your method to convert checked exceptions to unchecked exceptions.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1101/?engineType=SCA&issue=3CEFB658C858D961F2C1942155C3C953"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1643",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method makeUsername() in BackDoors.java sends unvalidated data to a web browser on line 235, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at Div() in BackDoors.java at line 235.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1643/?engineType=SCA&issue=6999DE3FC99AF2500FE3F95C518BC7D3"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1784",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method doStage1() in BasicAuthentication.java sends unvalidated data to a web browser on line 143, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 690. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at Input() in BasicAuthentication.java at line 143.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1784/?engineType=SCA&issue=D5C3ED4CE0DAF762A1F6D507F0B2914F"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1800",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method doStage1() in BasicAuthentication.java sends unvalidated data to a web browser on line 145, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 690. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at Input() in BasicAuthentication.java at line 145.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1800/?engineType=SCA&issue=E350095CB012D2ECF7AC8B80E4032750"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1087",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at BasicAuthentication.java line 157 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1087/?engineType=SCA&issue=319D6AB060984AB435CFC2164A196538"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "495",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function doStage1() in BasicAuthentication.java might reveal system data or debugging information by calling printStackTrace() on line 160.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/495/?engineType=SCA&issue=AB0F9C0F0179DC45DB936C0CAB702657"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1240",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at BasicAuthentication.java line 248 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1240/?engineType=SCA&issue=AD2FEB0CD76C9ED8B99A2A5F61415514"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "32",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function doStage2() in BasicAuthentication.java might reveal system data or debugging information by calling printStackTrace() on line 251.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/32/?engineType=SCA&issue=10D4432215FC1D906CED38AA5E8FCC55"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1617",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 122 of BlindSqlInjection.java, the method createContent() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeQuery() in BlindSqlInjection.java at line 122.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1617/?engineType=SCA&issue=4C2F0A022D42BDB810AB61020436E6EE"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1228",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at BlindSqlInjection.java line 142 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1228/?engineType=SCA&issue=A638BBFC9558DCBD6543396FED7E085F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "457",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in BlindSqlInjection.java might reveal system data or debugging information by calling printStackTrace() on line 145.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/457/?engineType=SCA&issue=9DE7F1DA6C0A12A6FD5E01E6393AB3DA"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1227",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at BlindSqlInjection.java line 341 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1227/?engineType=SCA&issue=A5C4F2CFD0C6A55CD11A173A3EC43334"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1208",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1208/?engineType=SCA&issue=9240DA4A67F3261C56DD14951F08BFAC"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1321",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in BlindSqlInjection.java might reveal system data or debugging information by calling println() on line 343.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1321/?engineType=SCA&issue=E8944AADCF578C5024D1735F7C279E48"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "39",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in BlindSqlInjection.java might reveal system data or debugging information by calling printStackTrace() on line 344.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/39/?engineType=SCA&issue=125F01FC217C384431D1097619DF9AD9"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1338",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at CSRF.java line 100 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1338/?engineType=SCA&issue=F718D43EBA284DCE994D82A30120BE9B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1207",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 181 of CSRF.java, the method makeList() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\nIn this case Fortify could not determine that the source of the data is trusted.\n\n2. The data is used to dynamically construct a SQL query. \n\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.  \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one used in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can: \n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but when user-supplied data needs to be included, they create bind parameters, which are placeholders for data that is subsequently inserted. Bind parameters allow the program to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for the value of each of the bind parameters, without the risk of the data being interpreted as commands. \n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n        \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the command structure of the SQL statement, such as the addition of dynamic constraints in the WHERE clause. Do not use this requirement to justify concatenating user input into query strings. Prevent SQL injection attacks where user input must affect statement command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1207/?engineType=SCA&issue=91BE8A9509668E194A8C877526E7160F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1186",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Persistent"
          },
          "fullDescription" : {
            "text" : "The method makeList() in CSRF.java sends unvalidated data to a web browser on line 193, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Persistent (also known as Stored) XSS, the untrusted source is typically a database or other back-end datastore, while in the case of Reflected XSS it is typically a web request.\n\n\nIn this case the data enters at executeQuery() in CSRF.java at line 181. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at addElement() in CSRF.java at line 193.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nThis code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. This code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nExample 2: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nAs in Example 1, this code operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- As in Example 2, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1186/?engineType=SCA&issue=7F5910D8AF054AAE63BCB1A22ECFA207"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1089",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at CSRF.java line 199 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1089/?engineType=SCA&issue=34584650395D5F2534406558498B5C27"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "562",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Persistent"
          },
          "fullDescription" : {
            "text" : "The method makeCurrent() in CSRF.java sends unvalidated data to a web browser on line 245, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Persistent (also known as Stored) XSS, the untrusted source is typically a database or other back-end datastore, while in the case of Reflected XSS it is typically a web request.\n\n\nIn this case the data enters at executeQuery() in CSRF.java at line 241. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at H1() in CSRF.java at line 245.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nThis code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. This code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nExample 2: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nAs in Example 1, this code operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- As in Example 2, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/562/?engineType=SCA&issue=BFC40FBA3F9B73C3A8654B3F76C62244"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "492",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Persistent"
          },
          "fullDescription" : {
            "text" : "The method makeCurrent() in CSRF.java sends unvalidated data to a web browser on line 248, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Persistent (also known as Stored) XSS, the untrusted source is typically a database or other back-end datastore, while in the case of Reflected XSS it is typically a web request.\n\n\nIn this case the data enters at executeQuery() in CSRF.java at line 241. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at TD() in CSRF.java at line 248.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nThis code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. This code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nExample 2: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nAs in Example 1, this code operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- As in Example 2, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/492/?engineType=SCA&issue=AAFC1F7059CAAA46A9CD6BDBA80E9307"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "493",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Persistent"
          },
          "fullDescription" : {
            "text" : "The method makeCurrent() in CSRF.java sends unvalidated data to a web browser on line 253, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Persistent (also known as Stored) XSS, the untrusted source is typically a database or other back-end datastore, while in the case of Reflected XSS it is typically a web request.\n\n\nIn this case the data enters at executeQuery() in CSRF.java at line 241. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at TD() in CSRF.java at line 253.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nThis code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. This code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nExample 2: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nAs in Example 1, this code operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- As in Example 2, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/493/?engineType=SCA&issue=AAFC1F7059CAAA46A9CD6BDBA80E9308"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "494",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Persistent"
          },
          "fullDescription" : {
            "text" : "The method makeCurrent() in CSRF.java sends unvalidated data to a web browser on line 257, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Persistent (also known as Stored) XSS, the untrusted source is typically a database or other back-end datastore, while in the case of Reflected XSS it is typically a web request.\n\n\nIn this case the data enters at executeQuery() in CSRF.java at line 241. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at TD() in CSRF.java at line 257.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nThis code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. This code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nExample 2: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nAs in Example 1, this code operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- As in Example 2, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/494/?engineType=SCA&issue=AAFC1F7059CAAA46A9CD6BDBA80E9309"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1187",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at CSRF.java line 272 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1187/?engineType=SCA&issue=7FCE6A612F85C47C347711EDAAA88EFA"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "647",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function makeCurrent() in CSRF.java might reveal system data or debugging information by calling printStackTrace() on line 275.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/647/?engineType=SCA&issue=E8DC3D6ED853BCA5483F2920F6C6F78F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1167",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 220 of Challenge2Screen.java, the method doStage2() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getCookies() in Challenge2Screen.java at line 801. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeQuery() in Challenge2Screen.java at line 220.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1167/?engineType=SCA&issue=722C045E93DFA161A8B0B9F3C11E00B5"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1123",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at Challenge2Screen.java line 265 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1123/?engineType=SCA&issue=4919F2422E04E3C4D0B440616F633827"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1259",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at Challenge2Screen.java line 346 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1259/?engineType=SCA&issue=B78E4DB4CCF0A63E485127E81BAEB186"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1043",
          "shortDescription" : {
            "text" : "Unreleased Resource: Streams"
          },
          "fullDescription" : {
            "text" : "The function isDefaced() in Challenge2Screen.java sometimes fails to release a system resource allocated by FileReader() on line 381.\n\n\n"
          },
          "help" : {
            "text" : "The program can potentially fail to release a system resource.\n\n    In this case, there are program paths on which the resource allocated in Challenge2Screen.java at line 381 is not released.\n\n\nResource leaks have at least two common causes:\n\n- Error conditions and other exceptional circumstances.\n\n- Confusion over which part of the program is responsible for releasing the resource.\n\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.\n\nExample 1: The following method never closes the file handle it opens. The finalize() method for FileInputStream eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n\n\nprivate void processFile(String fName) throws FileNotFoundException, IOException\n{\n  FileInputStream fis = new FileInputStream(fName);\n  int sz;\n  byte[] byteArray = new byte[BLOCK_SIZE];\n  while ((sz = fis.read(byteArray)) != -1) {\n    processBytes(byteArray, sz);\n  }\n}\n\n\nExample 2: Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.\n\n\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(CXN_SQL);\n  harvestResults(rs);\n  stmt.close();\n\n\n\n1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to \"bursty\" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.\n\nFinally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang. \n\n2. Release resources in a finally block. The code for Example 2 should be rewritten as follows:\n\n\n  public void execCxnSql(Connection conn) {\n    Statement stmt;\n    try {\n      stmt = conn.createStatement();\n      ResultSet rs = stmt.executeQuery(CXN_SQL);\n      ...\n    }\n    finally {\n      if (stmt != null) {\n        safeClose(stmt);\n      }\n    }\n}\n\npublic static void safeClose(Statement stmt) {\n  if (stmt != null) {\n    try {\n      stmt.close();\n    } catch (SQLException e) {\n      log(e);\n    }\n  }\n}\n\n\nThis solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. \n\nAlso, the execCxnSql method does not initialize the stmt object to null. Instead, it checks to ensure that stmt is not null before calling safeClose(). Without the null check, the Java compiler reports that stmt might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  stmt is initialized to null in a more complex method, cases in which stmt is used without being initialized will not be detected by the compiler. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1043/?engineType=SCA&issue=13D5F7ED75A3AB864A34A5714569EF65"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1044",
          "shortDescription" : {
            "text" : "Unreleased Resource: Streams"
          },
          "fullDescription" : {
            "text" : "The function isDefaced() in Challenge2Screen.java sometimes fails to release a system resource allocated by FileReader() on line 383.\n\n\n"
          },
          "help" : {
            "text" : "The program can potentially fail to release a system resource.\n\n    In this case, there are program paths on which the resource allocated in Challenge2Screen.java at line 383 is not released.\n\n\nResource leaks have at least two common causes:\n\n- Error conditions and other exceptional circumstances.\n\n- Confusion over which part of the program is responsible for releasing the resource.\n\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.\n\nExample 1: The following method never closes the file handle it opens. The finalize() method for FileInputStream eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n\n\nprivate void processFile(String fName) throws FileNotFoundException, IOException\n{\n  FileInputStream fis = new FileInputStream(fName);\n  int sz;\n  byte[] byteArray = new byte[BLOCK_SIZE];\n  while ((sz = fis.read(byteArray)) != -1) {\n    processBytes(byteArray, sz);\n  }\n}\n\n\nExample 2: Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.\n\n\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(CXN_SQL);\n  harvestResults(rs);\n  stmt.close();\n\n\n\n1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to \"bursty\" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.\n\nFinally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang. \n\n2. Release resources in a finally block. The code for Example 2 should be rewritten as follows:\n\n\n  public void execCxnSql(Connection conn) {\n    Statement stmt;\n    try {\n      stmt = conn.createStatement();\n      ResultSet rs = stmt.executeQuery(CXN_SQL);\n      ...\n    }\n    finally {\n      if (stmt != null) {\n        safeClose(stmt);\n      }\n    }\n}\n\npublic static void safeClose(Statement stmt) {\n  if (stmt != null) {\n    try {\n      stmt.close();\n    } catch (SQLException e) {\n      log(e);\n    }\n  }\n}\n\n\nThis solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. \n\nAlso, the execCxnSql method does not initialize the stmt object to null. Instead, it checks to ensure that stmt is not null before calling safeClose(). Without the null check, the Java compiler reports that stmt might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  stmt is initialized to null in a more complex method, cases in which stmt is used without being initialized will not be detected by the compiler. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1044/?engineType=SCA&issue=13D5F7ED75A3AB864A34A5714569EF66"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1133",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at Challenge2Screen.java line 388 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1133/?engineType=SCA&issue=51B54953C34AEE1514439CF36E4EF00F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "609",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function isDefaced() in Challenge2Screen.java might reveal system data or debugging information by calling printStackTrace() on line 390.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/609/?engineType=SCA&issue=D91B3091E8E264DF8C6FF60BC35600BA"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1309",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Throws"
          },
          "fullDescription" : {
            "text" : "The method showDefaceAttempt() in Challenge2Screen.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
          },
          "help" : {
            "text" : "Declaring a method to throw Exception or Throwable makes it difficult for callers to do good error handling and error recovery. Java's exception mechanism is set up to make it easy for callers to anticipate what can go wrong and write code to handle each specific exceptional circumstance. Declaring that a method throws a generic form of exception defeats this system.\n\nExample: The following method throws three types of exceptions.\n\n\npublic void doExchange()\n  throws IOException, InvocationTargetException,\n         SQLException {\n  ...\n}\n\n\n\nWhile it might seem tidier to write \n\n\npublic void doExchange()\n  throws Exception {\n  ...\n}\n\n\ndoing so hampers the caller's ability to understand and handle the exceptions that occur. Further, if a later revision of doExchange() introduces a new type of exception that should be treated differently than previous exceptions, there is no easy way to enforce this requirement.\n\nDo not declare methods to throw Exception or Throwable. If the exceptions thrown by a method are not recoverable or should not generally be caught by the caller, consider throwing unchecked exceptions rather than checked exceptions. This can be accomplished by implementing exception classes that extend RuntimeException or Error instead of Exception, or add a try/catch wrapper in your method to convert checked exceptions to unchecked exceptions.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1309/?engineType=SCA&issue=D9C7CC39D5B7A558E88FA78611553BF4"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1121",
          "shortDescription" : {
            "text" : "Unreleased Resource: Streams"
          },
          "fullDescription" : {
            "text" : "The function showDefaceAttempt() in Challenge2Screen.java sometimes fails to release a system resource allocated by FileReader() on line 405.\n\n\n"
          },
          "help" : {
            "text" : "The program can potentially fail to release a system resource.\n\n    In this case, there are program paths on which the resource allocated in Challenge2Screen.java at line 405 is not released.\n\n\nResource leaks have at least two common causes:\n\n- Error conditions and other exceptional circumstances.\n\n- Confusion over which part of the program is responsible for releasing the resource.\n\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.\n\nExample 1: The following method never closes the file handle it opens. The finalize() method for FileInputStream eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n\n\nprivate void processFile(String fName) throws FileNotFoundException, IOException\n{\n  FileInputStream fis = new FileInputStream(fName);\n  int sz;\n  byte[] byteArray = new byte[BLOCK_SIZE];\n  while ((sz = fis.read(byteArray)) != -1) {\n    processBytes(byteArray, sz);\n  }\n}\n\n\nExample 2: Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.\n\n\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(CXN_SQL);\n  harvestResults(rs);\n  stmt.close();\n\n\n\n1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to \"bursty\" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.\n\nFinally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang. \n\n2. Release resources in a finally block. The code for Example 2 should be rewritten as follows:\n\n\n  public void execCxnSql(Connection conn) {\n    Statement stmt;\n    try {\n      stmt = conn.createStatement();\n      ResultSet rs = stmt.executeQuery(CXN_SQL);\n      ...\n    }\n    finally {\n      if (stmt != null) {\n        safeClose(stmt);\n      }\n    }\n}\n\npublic static void safeClose(Statement stmt) {\n  if (stmt != null) {\n    try {\n      stmt.close();\n    } catch (SQLException e) {\n      log(e);\n    }\n  }\n}\n\n\nThis solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. \n\nAlso, the execCxnSql method does not initialize the stmt object to null. Instead, it checks to ensure that stmt is not null before calling safeClose(). Without the null check, the Java compiler reports that stmt might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  stmt is initialized to null in a more complex method, cases in which stmt is used without being initialized will not be detected by the compiler. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1121/?engineType=SCA&issue=48CFC4960DE0E45B88DAE1B75077B408"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1122",
          "shortDescription" : {
            "text" : "Unreleased Resource: Streams"
          },
          "fullDescription" : {
            "text" : "The function showDefaceAttempt() in Challenge2Screen.java sometimes fails to release a system resource allocated by FileReader() on line 406.\n\n\n"
          },
          "help" : {
            "text" : "The program can potentially fail to release a system resource.\n\n    In this case, there are program paths on which the resource allocated in Challenge2Screen.java at line 406 is not released.\n\n\nResource leaks have at least two common causes:\n\n- Error conditions and other exceptional circumstances.\n\n- Confusion over which part of the program is responsible for releasing the resource.\n\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.\n\nExample 1: The following method never closes the file handle it opens. The finalize() method for FileInputStream eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n\n\nprivate void processFile(String fName) throws FileNotFoundException, IOException\n{\n  FileInputStream fis = new FileInputStream(fName);\n  int sz;\n  byte[] byteArray = new byte[BLOCK_SIZE];\n  while ((sz = fis.read(byteArray)) != -1) {\n    processBytes(byteArray, sz);\n  }\n}\n\n\nExample 2: Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.\n\n\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(CXN_SQL);\n  harvestResults(rs);\n  stmt.close();\n\n\n\n1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to \"bursty\" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.\n\nFinally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang. \n\n2. Release resources in a finally block. The code for Example 2 should be rewritten as follows:\n\n\n  public void execCxnSql(Connection conn) {\n    Statement stmt;\n    try {\n      stmt = conn.createStatement();\n      ResultSet rs = stmt.executeQuery(CXN_SQL);\n      ...\n    }\n    finally {\n      if (stmt != null) {\n        safeClose(stmt);\n      }\n    }\n}\n\npublic static void safeClose(Statement stmt) {\n  if (stmt != null) {\n    try {\n      stmt.close();\n    } catch (SQLException e) {\n      log(e);\n    }\n  }\n}\n\n\nThis solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. \n\nAlso, the execCxnSql method does not initialize the stmt object to null. Instead, it checks to ensure that stmt is not null before calling safeClose(). Without the null check, the Java compiler reports that stmt might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  stmt is initialized to null in a more complex method, cases in which stmt is used without being initialized will not be detected by the compiler. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1122/?engineType=SCA&issue=48CFC4960DE0E45B88DAE1B75077B409"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1125",
          "shortDescription" : {
            "text" : "Unreleased Resource: Streams"
          },
          "fullDescription" : {
            "text" : "The function resetWebPage() in Challenge2Screen.java sometimes fails to release a system resource allocated by FileWriter() on line 433.\n\n\n"
          },
          "help" : {
            "text" : "The program can potentially fail to release a system resource.\n\n    In this case, there are program paths on which the resource allocated in Challenge2Screen.java at line 433 is not released.\n\n\nResource leaks have at least two common causes:\n\n- Error conditions and other exceptional circumstances.\n\n- Confusion over which part of the program is responsible for releasing the resource.\n\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.\n\nExample 1: The following method never closes the file handle it opens. The finalize() method for FileInputStream eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n\n\nprivate void processFile(String fName) throws FileNotFoundException, IOException\n{\n  FileInputStream fis = new FileInputStream(fName);\n  int sz;\n  byte[] byteArray = new byte[BLOCK_SIZE];\n  while ((sz = fis.read(byteArray)) != -1) {\n    processBytes(byteArray, sz);\n  }\n}\n\n\nExample 2: Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.\n\n\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(CXN_SQL);\n  harvestResults(rs);\n  stmt.close();\n\n\n\n1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to \"bursty\" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.\n\nFinally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang. \n\n2. Release resources in a finally block. The code for Example 2 should be rewritten as follows:\n\n\n  public void execCxnSql(Connection conn) {\n    Statement stmt;\n    try {\n      stmt = conn.createStatement();\n      ResultSet rs = stmt.executeQuery(CXN_SQL);\n      ...\n    }\n    finally {\n      if (stmt != null) {\n        safeClose(stmt);\n      }\n    }\n}\n\npublic static void safeClose(Statement stmt) {\n  if (stmt != null) {\n    try {\n      stmt.close();\n    } catch (SQLException e) {\n      log(e);\n    }\n  }\n}\n\n\nThis solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. \n\nAlso, the execCxnSql method does not initialize the stmt object to null. Instead, it checks to ensure that stmt is not null before calling safeClose(). Without the null check, the Java compiler reports that stmt might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  stmt is initialized to null in a more complex method, cases in which stmt is used without being initialized will not be detected by the compiler. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1125/?engineType=SCA&issue=49AC82522DFE5219AF616B4DD208B330"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1059",
          "shortDescription" : {
            "text" : "Unreleased Resource: Streams"
          },
          "fullDescription" : {
            "text" : "The function resetWebPage() in Challenge2Screen.java sometimes fails to release a system resource allocated by FileReader() on line 434.\n\n\n"
          },
          "help" : {
            "text" : "The program can potentially fail to release a system resource.\n\n    In this case, there are program paths on which the resource allocated in Challenge2Screen.java at line 434 is not released.\n\n\nResource leaks have at least two common causes:\n\n- Error conditions and other exceptional circumstances.\n\n- Confusion over which part of the program is responsible for releasing the resource.\n\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.\n\nExample 1: The following method never closes the file handle it opens. The finalize() method for FileInputStream eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n\n\nprivate void processFile(String fName) throws FileNotFoundException, IOException\n{\n  FileInputStream fis = new FileInputStream(fName);\n  int sz;\n  byte[] byteArray = new byte[BLOCK_SIZE];\n  while ((sz = fis.read(byteArray)) != -1) {\n    processBytes(byteArray, sz);\n  }\n}\n\n\nExample 2: Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.\n\n\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(CXN_SQL);\n  harvestResults(rs);\n  stmt.close();\n\n\n\n1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to \"bursty\" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.\n\nFinally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang. \n\n2. Release resources in a finally block. The code for Example 2 should be rewritten as follows:\n\n\n  public void execCxnSql(Connection conn) {\n    Statement stmt;\n    try {\n      stmt = conn.createStatement();\n      ResultSet rs = stmt.executeQuery(CXN_SQL);\n      ...\n    }\n    finally {\n      if (stmt != null) {\n        safeClose(stmt);\n      }\n    }\n}\n\npublic static void safeClose(Statement stmt) {\n  if (stmt != null) {\n    try {\n      stmt.close();\n    } catch (SQLException e) {\n      log(e);\n    }\n  }\n}\n\n\nThis solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. \n\nAlso, the execCxnSql method does not initialize the stmt object to null. Instead, it checks to ensure that stmt is not null before calling safeClose(). Without the null check, the Java compiler reports that stmt might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  stmt is initialized to null in a more complex method, cases in which stmt is used without being initialized will not be detected by the compiler. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1059/?engineType=SCA&issue=1C63C03CDAD3AAC473C04FED33047A6E"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1329",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at Challenge2Screen.java line 439 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1329/?engineType=SCA&issue=F07967E12A769BEE46B8C32F248610D0"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "654",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function resetWebPage() in Challenge2Screen.java might reveal system data or debugging information by calling printStackTrace() on line 441.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/654/?engineType=SCA&issue=EC550B01611ECF96AB4E36233F98E1DA"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "587",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at Challenge2Screen.java line 726 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/587/?engineType=SCA&issue=CF1625E05308FFEA3F1E0E6E3565D80D"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "96",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/96/?engineType=SCA&issue=208CC9439D8BBD0EF6A7FA217C42BAF8"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "208",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function sendMessage() in Challenge2Screen.java might reveal system data or debugging information by calling printStackTrace() on line 729.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/208/?engineType=SCA&issue=434C02AFB8035E739BE7929C0035BE55"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1256",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1256/?engineType=SCA&issue=B5CEF3088653D1EB0FC57A1296AD4BAF"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1185",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at CommandInjection.java line 208 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1185/?engineType=SCA&issue=7EF40D82A5F7C67496FCA5ABE720E01E"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "66",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in CommandInjection.java might reveal system data or debugging information by calling printStackTrace() on line 211.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/66/?engineType=SCA&issue=160F81FA3700C4ACF05278016D591DEE"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "154",
          "shortDescription" : {
            "text" : "Unchecked Return Value"
          },
          "fullDescription" : {
            "text" : "The method parseResults() in CommandInjection.java ignores the value returned by replaceAll() on line 220, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "It is not uncommon for Java programmers to misunderstand read() and related methods that are part of many java.io classes. Most errors and unusual events in Java result in an exception being thrown. (This is one of the advantages that Java has over languages like C: Exceptions make it easier for programmers to think about what can go wrong.) But the stream and reader classes do not consider it unusual or exceptional if only a small amount of data becomes available. These classes simply add the small amount of data to the return buffer, and set the return value to the number of bytes or characters read. There is no guarantee that the amount of data returned is equal to the amount of data requested.\n\nThis behavior makes it important for programmers to examine the return value from read() and other IO methods to ensure that they receive the amount of data they expect.\n\n\n\nExample: The following code loops through a set of users, reading a private data file for each user. The programmer assumes that the files are always exactly 1 kilobyte in size and therefore ignores the return value from read(). If an attacker can create a smaller file, the program will recycle the remainder of the data from the previous user and handle it as though it belongs to the attacker.\n\n\nFileInputStream fis;\nbyte[] byteArray = new byte[1024];\nfor (Iterator i=users.iterator(); i.hasNext();) {\n    String userName = (String) i.next();\n    String pFileName = PFILE_ROOT + \"/\" + userName;\n    FileInputStream fis = new FileInputStream(pFileName);   \n    fis.read(byteArray); // the file is always 1k bytes\n    fis.close();\n    processPFile(userName, byteArray);\n}\n\n\n\n\n  FileInputStream fis;\n  byte[] byteArray = new byte[1024];\n  for (Iterator i=users.iterator(); i.hasNext();) {\n    String userName = (String) i.next();\n    String pFileName = PFILE_ROOT + \"/\" + userName;\n    fis = new FileInputStream(pFileName);\n    int bRead = 0;\n    while (bRead &lt; 1024) {\n        int rd = fis.read(byteArray, bRead, 1024 - bRead); \n        if (rd == -1) {\n          throw new IOException(\"file is unusually small\");\n        }\n        bRead += rd;\n    }\n    // could add check to see if file is too large here\n    fis.close();\n    processPFile(userName, byteArray);\n  }\n\n\nNote: Because the fix for this problem is relatively complicated, you might be tempted to use a simpler approach, such as checking the size of the file before you begin reading. Such an approach would render the application vulnerable to a file system race condition, whereby an attacker could replace a well-formed file with a malicious file between the file size check and the call to read data from the file. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/154/?engineType=SCA&issue=30AE8696BEA3CD405C5B06406DC2D875"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1229",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1229/?engineType=SCA&issue=A762ABB9403892D49EFC78C3720C32AB"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1114",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1114/?engineType=SCA&issue=45061B1E02B98799473F8A6E78BC4A66"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1041",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1041/?engineType=SCA&issue=115DE7E55178D4232C6ABF96346DEC56"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1332",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1332/?engineType=SCA&issue=F3622B291F5D16CC3A727AF90D75988B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1697",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in CrossSiteScripting.java might reveal system data or debugging information by calling printStackTrace() on line 360.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1697/?engineType=SCA&issue=94BC2CB125163422C63F4E162F0FF0CB"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1333",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1333/?engineType=SCA&issue=F3622B291F5D16CC3A727AF90D75988C"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1050",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in CrossSiteScripting.java might reveal system data or debugging information by calling printStackTrace() on line 366.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1050/?engineType=SCA&issue=163B719F69C0908312A41CC536248C81"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1334",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1334/?engineType=SCA&issue=F3622B291F5D16CC3A727AF90D75988D"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1539",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in CrossSiteScripting.java might reveal system data or debugging information by calling printStackTrace() on line 373.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1539/?engineType=SCA&issue=031C838BEA3E68948136390E110422AA"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1335",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1335/?engineType=SCA&issue=F3622B291F5D16CC3A727AF90D75988E"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1535",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in CrossSiteScripting.java might reveal system data or debugging information by calling printStackTrace() on line 379.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1535/?engineType=SCA&issue=0010C1C949B6B1146790E9BA51866F0D"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1328",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at CrossSiteScripting.java line 381 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1328/?engineType=SCA&issue=EFBAC65F8FEB6F6E14FACDBB742BCC7E"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1336",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1336/?engineType=SCA&issue=F3622B291F5D16CC3A727AF90D75988F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "312",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in CrossSiteScripting.java might reveal system data or debugging information by calling printStackTrace() on line 385.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/312/?engineType=SCA&issue=6848A018EE47A64FCA5A0F716FFE688A"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "558",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getEmployeeProfile() in EditProfile.java might reveal system data or debugging information by calling printStackTrace() on line 125.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/558/?engineType=SCA&issue=BD4FADFC5F19C155B261ECC46F46E82D"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1840",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at EditProfile.java line 128 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1840/?engineType=SCA&issue=F895A6CAB37A1636D3B9FBBEA23C9674"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "469",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getEmployeeProfile() in EditProfile.java might reveal system data or debugging information by calling printStackTrace() on line 131.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/469/?engineType=SCA&issue=A1F3CAB3AF6B424ADC408CBF64AACBA5"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "471",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getEmployeeProfile_BACKUP() in EditProfile.java might reveal system data or debugging information by calling printStackTrace() on line 183.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/471/?engineType=SCA&issue=A35E8449693CFFD71A5DF12FFDCBA587"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1821",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at EditProfile.java line 186 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1821/?engineType=SCA&issue=F225C68286E6C19D93D2C1E94F95F7D3"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "67",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getEmployeeProfile_BACKUP() in EditProfile.java might reveal system data or debugging information by calling printStackTrace() on line 189.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/67/?engineType=SCA&issue=1628D80D60254DD5FE7AF2F02C279A5B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1119",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1119/?engineType=SCA&issue=481CC74E021AC4A5CE81F944517BE70B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1788",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in FindProfile.java might reveal system data or debugging information by calling printStackTrace() on line 121.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1788/?engineType=SCA&issue=D872647971F4264544026202303B0C13"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1120",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1120/?engineType=SCA&issue=481CC74E021AC4A5CE81F944517BE70C"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1836",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in FindProfile.java might reveal system data or debugging information by calling printStackTrace() on line 126.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1836/?engineType=SCA&issue=F7FD358E0D1F0374731F1FA9D063D96F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "353",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function findEmployeeProfile() in FindProfile.java might reveal system data or debugging information by calling printStackTrace() on line 213.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/353/?engineType=SCA&issue=7BA6A8A7BD79BE08A61BCA60190284D4"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1592",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at FindProfile.java line 216 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1592/?engineType=SCA&issue=349863551B1440EF6513F300D1F84040"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "166",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function findEmployeeProfile() in FindProfile.java might reveal system data or debugging information by calling printStackTrace() on line 219.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/166/?engineType=SCA&issue=35E084BA77E09CEA853C2E8B67EC5A90"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1331",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method foundEmployee() in FindProfile.java ignores an exception on line 235, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1331/?engineType=SCA&issue=F23C1087E34409F5607C5C5C9FF79069"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1127",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1127/?engineType=SCA&issue=4CFCAFDD85B95ADCE288F8E77CEAB6F2"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1684",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 110.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1684/?engineType=SCA&issue=820D9127C18956E39B7BFD623247D3DA"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1128",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1128/?engineType=SCA&issue=4CFCAFDD85B95ADCE288F8E77CEAB6F3"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1594",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 115.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1594/?engineType=SCA&issue=34F7DA75494088350E0041164CF31E69"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1550",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 248 of UpdateProfile.java, the method changeEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameter() in UpdateProfile.java at line 140. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeUpdate() in UpdateProfile.java at line 248.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1550/?engineType=SCA&issue=102133874B3B236067674F95CDA65378"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1562",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 248 of UpdateProfile.java, the method changeEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameter() in UpdateProfile.java at line 151. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeUpdate() in UpdateProfile.java at line 248.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1562/?engineType=SCA&issue=1BA016A253E02A521F93B3FE8326D3B6"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1616",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 248 of UpdateProfile.java, the method changeEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameter() in UpdateProfile.java at line 143. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeUpdate() in UpdateProfile.java at line 248.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1616/?engineType=SCA&issue=4C1FCFCA2C8B123EF5A2352B71C40263"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1621",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 248 of UpdateProfile.java, the method changeEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameter() in UpdateProfile.java at line 133. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeUpdate() in UpdateProfile.java at line 248.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1621/?engineType=SCA&issue=4EEAB05EB064C3B925D99AAE170F718D"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1653",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 248 of UpdateProfile.java, the method changeEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameter() in UpdateProfile.java at line 134. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeUpdate() in UpdateProfile.java at line 248.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1653/?engineType=SCA&issue=6EB2F2FA65B0712F919DA4A441EA91C4"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1712",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 248 of UpdateProfile.java, the method changeEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameter() in UpdateProfile.java at line 135. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeUpdate() in UpdateProfile.java at line 248.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1712/?engineType=SCA&issue=A17C4D04E1782E491588042AC8FE1D41"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1741",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 248 of UpdateProfile.java, the method changeEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameter() in UpdateProfile.java at line 131. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeUpdate() in UpdateProfile.java at line 248.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1741/?engineType=SCA&issue=BCA3D333363FC5AC917286E91F517058"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1762",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 248 of UpdateProfile.java, the method changeEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameter() in UpdateProfile.java at line 137. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeUpdate() in UpdateProfile.java at line 248.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1762/?engineType=SCA&issue=C7251E9EB27461586D6CA0B5DD1FED0C"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1786",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 248 of UpdateProfile.java, the method changeEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameter() in UpdateProfile.java at line 132. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeUpdate() in UpdateProfile.java at line 248.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1786/?engineType=SCA&issue=D6285BDE3B6367571257E12E7237E331"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1795",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 248 of UpdateProfile.java, the method changeEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameter() in UpdateProfile.java at line 136. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeUpdate() in UpdateProfile.java at line 248.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1795/?engineType=SCA&issue=DECADC8CF18805DE8D393C1FF350A884"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "70",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function changeEmployeeProfile() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 253.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/70/?engineType=SCA&issue=181A204DA906FACB0A0455C47657CF13"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1587",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at UpdateProfile.java line 257 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1587/?engineType=SCA&issue=2EF06EFC80CA9FC3BE40DB3F601F8239"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "607",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function changeEmployeeProfile() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 260.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/607/?engineType=SCA&issue=D8119249773A39CD022B883126F43C24"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "592",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 297 of UpdateProfile.java, the method doChangeEmployeeProfile_BACKUP() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\nIn this case Fortify could not determine that the source of the data is trusted.\n\n2. The data is used to dynamically construct a SQL query. \n\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.  \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one used in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can: \n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but when user-supplied data needs to be included, they create bind parameters, which are placeholders for data that is subsequently inserted. Bind parameters allow the program to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for the value of each of the bind parameters, without the risk of the data being interpreted as commands. \n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n        \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the command structure of the SQL statement, such as the addition of dynamic constraints in the WHERE clause. Do not use this requirement to justify concatenating user input into query strings. Prevent SQL injection attacks where user input must affect statement command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/592/?engineType=SCA&issue=D22EAF3DF450EDEF696802635C6007D6"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "405",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function doChangeEmployeeProfile_BACKUP() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 302.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/405/?engineType=SCA&issue=8E8BA4B0E6CF6803058E507305B358C3"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1726",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at UpdateProfile.java line 306 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1726/?engineType=SCA&issue=B2272914D82DDB38D16D455828C529E1"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "608",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function doChangeEmployeeProfile_BACKUP() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 309.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/608/?engineType=SCA&issue=D9077301391A2AB9CFF320A0941B7299"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1543",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 340 of UpdateProfile.java, the method createEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameter() in UpdateProfile.java at line 134. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeUpdate() in UpdateProfile.java at line 340.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1543/?engineType=SCA&issue=0AE1973FD4FF73765D0BEC7F8886DBFB"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1572",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 340 of UpdateProfile.java, the method createEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameter() in UpdateProfile.java at line 135. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeUpdate() in UpdateProfile.java at line 340.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1572/?engineType=SCA&issue=23738AA4672374B793E3F0B3EF6F77C2"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1607",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 340 of UpdateProfile.java, the method createEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameter() in UpdateProfile.java at line 143. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeUpdate() in UpdateProfile.java at line 340.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1607/?engineType=SCA&issue=40F182886B5388EEFE531DC0B78022F2"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1651",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 340 of UpdateProfile.java, the method createEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameter() in UpdateProfile.java at line 137. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeUpdate() in UpdateProfile.java at line 340.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1651/?engineType=SCA&issue=6D8E8E746A0B2870F8099EC8D0CBF6A0"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1662",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 340 of UpdateProfile.java, the method createEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameter() in UpdateProfile.java at line 149. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeUpdate() in UpdateProfile.java at line 340.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1662/?engineType=SCA&issue=72F28D8F000869CC39934273918DB898"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1705",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 340 of UpdateProfile.java, the method createEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameter() in UpdateProfile.java at line 136. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeUpdate() in UpdateProfile.java at line 340.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1705/?engineType=SCA&issue=9D3EBB494D095ACB73F8E6265896C275"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1734",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 340 of UpdateProfile.java, the method createEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameter() in UpdateProfile.java at line 131. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeUpdate() in UpdateProfile.java at line 340.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1734/?engineType=SCA&issue=B8EC49F42C1791942978ED0508097358"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1772",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 340 of UpdateProfile.java, the method createEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameter() in UpdateProfile.java at line 140. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeUpdate() in UpdateProfile.java at line 340.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1772/?engineType=SCA&issue=CD2D57A971D7F45E4E5903C44BB03E13"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1773",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 340 of UpdateProfile.java, the method createEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameter() in UpdateProfile.java at line 133. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeUpdate() in UpdateProfile.java at line 340.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1773/?engineType=SCA&issue=CDB62E3970E486E23A3869664BE02CE7"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1783",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 340 of UpdateProfile.java, the method createEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameter() in UpdateProfile.java at line 132. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeUpdate() in UpdateProfile.java at line 340.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1783/?engineType=SCA&issue=D32951D526755AC8D8AE2790B9BC4289"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1822",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 340 of UpdateProfile.java, the method createEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameter() in UpdateProfile.java at line 151. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeUpdate() in UpdateProfile.java at line 340.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1822/?engineType=SCA&issue=F241067F505B2D49558AEB12BAEB3A86"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1844",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 340 of UpdateProfile.java, the method createEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameter() in UpdateProfile.java at line 147. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeUpdate() in UpdateProfile.java at line 340.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1844/?engineType=SCA&issue=FBEE1D44AE79C9DBD77CF348837EC499"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "164",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createEmployeeProfile() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 345.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/164/?engineType=SCA&issue=348D9FB5ADC466B0BF5C0E5163F660CB"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1820",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at UpdateProfile.java line 348 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1820/?engineType=SCA&issue=F15DA3960EE5AC46A5FFA169F84C1F62"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "201",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createEmployeeProfile() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 351.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/201/?engineType=SCA&issue=3DDF4C741AC3A01CBE48D925C7B3268F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "508",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 382 of UpdateProfile.java, the method createEmployeeProfile_BACKUP() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\nIn this case Fortify could not determine that the source of the data is trusted.\n\n2. The data is used to dynamically construct a SQL query. \n\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.  \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one used in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can: \n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but when user-supplied data needs to be included, they create bind parameters, which are placeholders for data that is subsequently inserted. Bind parameters allow the program to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for the value of each of the bind parameters, without the risk of the data being interpreted as commands. \n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n        \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the command structure of the SQL statement, such as the addition of dynamic constraints in the WHERE clause. Do not use this requirement to justify concatenating user input into query strings. Prevent SQL injection attacks where user input must affect statement command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/508/?engineType=SCA&issue=ADB2838EEF4321355CBA5524A2E21C12"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "599",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createEmployeeProfile_BACKUP() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 387.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/599/?engineType=SCA&issue=D60D775DBDAE54DDEBF316C5113E73DC"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1799",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at UpdateProfile.java line 390 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1799/?engineType=SCA&issue=E1B463F82834469B4244B82822DE919E"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "612",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createEmployeeProfile_BACKUP() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 393.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/612/?engineType=SCA&issue=D9A6AE2AC85C0E39449C242C052F302B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "239",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getEmployeeProfile() in ViewProfile.java might reveal system data or debugging information by calling printStackTrace() on line 140.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/239/?engineType=SCA&issue=4FDA9B15885A673A877D3550A8CABB1E"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1758",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ViewProfile.java line 143 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1758/?engineType=SCA&issue=C4D54C64E816134C129CC4FB04CE5624"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "348",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getEmployeeProfile() in ViewProfile.java might reveal system data or debugging information by calling printStackTrace() on line 146.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/348/?engineType=SCA&issue=7A4AD89F74574F83E5609198EF01BDC2"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "38",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 172 of ViewProfile.java, the method getEmployeeProfile_BACKUP() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\nIn this case Fortify could not determine that the source of the data is trusted.\n\n2. The data is used to dynamically construct a SQL query. \n\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.  \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one used in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can: \n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but when user-supplied data needs to be included, they create bind parameters, which are placeholders for data that is subsequently inserted. Bind parameters allow the program to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for the value of each of the bind parameters, without the risk of the data being interpreted as commands. \n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n        \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the command structure of the SQL statement, such as the addition of dynamic constraints in the WHERE clause. Do not use this requirement to justify concatenating user input into query strings. Prevent SQL injection attacks where user input must affect statement command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/38/?engineType=SCA&issue=125AFBB5C27425AA50E71B144AE97786"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "210",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getEmployeeProfile_BACKUP() in ViewProfile.java might reveal system data or debugging information by calling printStackTrace() on line 200.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/210/?engineType=SCA&issue=435FCB107394C1B62FA1D1B941C914E7"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1696",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ViewProfile.java line 203 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1696/?engineType=SCA&issue=93CE2393E73626FF83259F7BF183836D"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "195",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getEmployeeProfile_BACKUP() in ViewProfile.java might reveal system data or debugging information by calling printStackTrace() on line 206.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/195/?engineType=SCA&issue=3C5D38A41A6EB2D7820B964AB70ED332"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1316",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at DOMInjection.java line 89 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1316/?engineType=SCA&issue=E094301BE5A2AD6CE88C5C1EA1DF7303"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "458",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in DOMInjection.java might reveal system data or debugging information by calling printStackTrace() on line 92.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/458/?engineType=SCA&issue=9EA2F7ECE0EB7F2DFEA0C97602F3136D"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "413",
          "shortDescription" : {
            "text" : "Password Management: Hardcoded Password"
          },
          "fullDescription" : {
            "text" : "Hardcoded passwords can compromise system security in a way that cannot be easily remedied.\n\n\n"
          },
          "help" : {
            "text" : "It is never a good idea to hardcode a password. Not only does hardcoding a password allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. Once the code is in production, the password cannot be changed without patching the software. If the account protected by the password is compromised, the owners of the system will be forced to choose between security and availability.\n\n\nExample: The following code uses a hardcoded password to connect to a database:\n\n\n...\nDriverManager.getConnection(url, \"scott\", \"tiger\");\n...\n\n\nThis code will run successfully, but anyone who has access to it will have access to the password. Once the program has shipped, there is no going back from the database user \"scott\" with a password of \"tiger\" unless the program is patched. A devious employee with access to this information can use it to break into the system. Even worse, if attackers have access to the bytecode for application, they can use the javap -c command to access the disassembled code, which will contain the values of the passwords used. The result of this operation might look something like the following for the example above:\n\n\njavap -c ConnMngr.class\n\n22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql\n24: ldc   #38; //String scott\n26: ldc   #17; //String tiger\n\n\n\nPasswords should never be hardcoded and should generally be obfuscated and managed in an external source. Storing passwords in plaintext anywhere on the system allows anyone with sufficient permissions to read and potentially misuse the password.\n\nSome third party products claim the ability to manage passwords in a more secure way. For example, WebSphere Application Server 4.x uses a simple XOR encryption algorithm for obfuscating values, but be skeptical about such facilities. WebSphere and other application servers offer outdated and relatively weak encryption mechanisms that are insufficient for security-sensitive environments. For a secure solution, the only viable option available today appears to be a proprietary one that you create.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/413/?engineType=SCA&issue=92F0529952890D159704864A64A192D1"
          },
          "properties" : {
            "tags" : [ "Medium" ],
            "precision" : "high"
          }
        }, {
          "id" : "1273",
          "shortDescription" : {
            "text" : "Password Management: Empty Password"
          },
          "fullDescription" : {
            "text" : "Empty passwords can compromise system security in a way that cannot be easily remedied.\n\n\n"
          },
          "help" : {
            "text" : "It is never a good idea to assign an empty string to a password variable. When it is never assigned to a real password, it might compromise security.\n\n\nExample: The following code has an empty password that has a path where it will not be changed before the check:\n\n\n    ...\n    String stored_password=\"\";\n    ...\n    {\n        stored_password=database.getPassword(user_name);\n        ...\n    }\n    ...\n    if(stored_password.equals(user_password){\n        // Not all paths go through the lookup, so an empty password is acceptable\n        ...\n        }\n    ...\n\n\n\n\nPasswords should never be assigned to a value that can misleading. The password is set to a value and at the point of comparing the password, it will not always be taken in to consideration that the password variable was initialized instead of set to a real value.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1273/?engineType=SCA&issue=C59C95ED474FD05F7CB5280ED6D5E9E6"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1743",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 114 of DOS_Login.java, the method createContent() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeQuery() in DOS_Login.java at line 114.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1743/?engineType=SCA&issue=BDB979C5A4BED6AFC08178F9E4372662"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1634",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 134 of DOS_Login.java, the method createContent() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeUpdate() in DOS_Login.java at line 134.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1634/?engineType=SCA&issue=609AB6BC75F18101BAF34F183F5F90BB"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "169",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 139 of DOS_Login.java, the method createContent() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\nIn this case Fortify could not determine that the source of the data is trusted.\n\n2. The data is used to dynamically construct a SQL query. \n\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.  \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one used in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can: \n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but when user-supplied data needs to be included, they create bind parameters, which are placeholders for data that is subsequently inserted. Bind parameters allow the program to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for the value of each of the bind parameters, without the risk of the data being interpreted as commands. \n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n        \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the command structure of the SQL statement, such as the addition of dynamic constraints in the WHERE clause. Do not use this requirement to justify concatenating user input into query strings. Prevent SQL injection attacks where user input must affect statement command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/169/?engineType=SCA&issue=360E3CE77448ED1F01C49BC9140332C0"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "473",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 147 of DOS_Login.java, the method createContent() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\nIn this case Fortify could not determine that the source of the data is trusted.\n\n2. The data is used to dynamically construct a SQL query. \n\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.  \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one used in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can: \n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but when user-supplied data needs to be included, they create bind parameters, which are placeholders for data that is subsequently inserted. Bind parameters allow the program to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for the value of each of the bind parameters, without the risk of the data being interpreted as commands. \n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n        \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the command structure of the SQL statement, such as the addition of dynamic constraints in the WHERE clause. Do not use this requirement to justify concatenating user input into query strings. Prevent SQL injection attacks where user input must affect statement command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/473/?engineType=SCA&issue=A3CC95BCD894EAD3D13DABC323E3D63B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "168",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 162 of DOS_Login.java, the method createContent() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\nIn this case Fortify could not determine that the source of the data is trusted.\n\n2. The data is used to dynamically construct a SQL query. \n\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.  \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one used in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can: \n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but when user-supplied data needs to be included, they create bind parameters, which are placeholders for data that is subsequently inserted. Bind parameters allow the program to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for the value of each of the bind parameters, without the risk of the data being interpreted as commands. \n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n        \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the command structure of the SQL statement, such as the addition of dynamic constraints in the WHERE clause. Do not use this requirement to justify concatenating user input into query strings. Prevent SQL injection attacks where user input must affect statement command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/168/?engineType=SCA&issue=360E3CE77448ED1F01C49BC9140332BF"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "505",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in DOS_Login.java might reveal system data or debugging information by calling printStackTrace() on line 172.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/505/?engineType=SCA&issue=AD77F23B2F560ACFD13DFB3502BC039A"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1261",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at DOS_Login.java line 175 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1261/?engineType=SCA&issue=B85AB37C215E8F38F75A4F5BAC72C4C6"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1237",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method getIntSessionAttribute() in DefaultLessonAction.java ignores an exception on line 145, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1237/?engineType=SCA&issue=ABE768E5DB127C1880CAC97B6FD02B02"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1304",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method getIntRequestAttribute() in DefaultLessonAction.java ignores an exception on line 178, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1304/?engineType=SCA&issue=D74773F2B70F375A5CC8F8E4E041126B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "626",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 203 of DefaultLessonAction.java, the method getUserName() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\nIn this case Fortify could not determine that the source of the data is trusted.\n\n2. The data is used to dynamically construct a SQL query. \n\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.  \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one used in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can: \n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but when user-supplied data needs to be included, they create bind parameters, which are placeholders for data that is subsequently inserted. Bind parameters allow the program to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for the value of each of the bind parameters, without the risk of the data being interpreted as commands. \n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n        \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the command structure of the SQL statement, such as the addition of dynamic constraints in the WHERE clause. Do not use this requirement to justify concatenating user input into query strings. Prevent SQL injection attacks where user input must affect statement command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/626/?engineType=SCA&issue=DDA192CA04BD34CB09615F5ADA6D6D06"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "254",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getUserName() in DefaultLessonAction.java might reveal system data or debugging information by calling printStackTrace() on line 210.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/254/?engineType=SCA&issue=58FD40089E718B766C6FA96FD22C8D81"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1252",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at DefaultLessonAction.java line 213 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1252/?engineType=SCA&issue=B409E99A33FDC4241E8D86D237E45FCC"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "212",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getUserName() in DefaultLessonAction.java might reveal system data or debugging information by calling printStackTrace() on line 216.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/212/?engineType=SCA&issue=450EDF14D048E6125EA598D94E9995C0"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1173",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method isAuthenticated() in DefaultLessonAction.java ignores an exception on line 236, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1173/?engineType=SCA&issue=769FB1D68E26C32059C84C220A85D193"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "545",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 256 of DefaultLessonAction.java, the method isAuthorized() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\nIn this case Fortify could not determine that the source of the data is trusted.\n\n2. The data is used to dynamically construct a SQL query. \n\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.  \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one used in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can: \n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but when user-supplied data needs to be included, they create bind parameters, which are placeholders for data that is subsequently inserted. Bind parameters allow the program to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for the value of each of the bind parameters, without the risk of the data being interpreted as commands. \n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n        \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the command structure of the SQL statement, such as the addition of dynamic constraints in the WHERE clause. Do not use this requirement to justify concatenating user input into query strings. Prevent SQL injection attacks where user input must affect statement command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/545/?engineType=SCA&issue=B9D18A1B80F2CE2982A1DF0C011D7BFC"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "544",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 265 of DefaultLessonAction.java, the method isAuthorized() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\nIn this case Fortify could not determine that the source of the data is trusted.\n\n2. The data is used to dynamically construct a SQL query. \n\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.  \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one used in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can: \n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but when user-supplied data needs to be included, they create bind parameters, which are placeholders for data that is subsequently inserted. Bind parameters allow the program to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for the value of each of the bind parameters, without the risk of the data being interpreted as commands. \n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n        \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the command structure of the SQL statement, such as the addition of dynamic constraints in the WHERE clause. Do not use this requirement to justify concatenating user input into query strings. Prevent SQL injection attacks where user input must affect statement command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/544/?engineType=SCA&issue=B9D18A1B80F2CE2982A1DF0C011D7BFB"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "33",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function isAuthorized() in DefaultLessonAction.java might reveal system data or debugging information by calling printStackTrace() on line 272.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/33/?engineType=SCA&issue=10D794BC1E42F40B8C7789FAB6124876"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1282",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at DefaultLessonAction.java line 275 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1282/?engineType=SCA&issue=CB037CB8BCEA4B8C012A909978867083"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "569",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function isAuthorized() in DefaultLessonAction.java might reveal system data or debugging information by calling printStackTrace() on line 278.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/569/?engineType=SCA&issue=C29E60A69A0EFA8B7965E98438EF7399"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "202",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function isAuthorizedForEmployee() in DefaultLessonAction.java might reveal system data or debugging information by calling printStackTrace() on line 320.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/202/?engineType=SCA&issue=3F6FFF90338B5D7AD8036C3213B71E6F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1339",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at DefaultLessonAction.java line 323 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1339/?engineType=SCA&issue=F73424BDB903FB4CBC3231399EBF1980"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "375",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function isAuthorizedForEmployee() in DefaultLessonAction.java might reveal system data or debugging information by calling printStackTrace() on line 326.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/375/?engineType=SCA&issue=81034BADE3549CFFE651854181BA6561"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1678",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method createContent() in Encoding.java sends unvalidated data to a web browser on line 359, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at Input() in Encoding.java at line 359.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1678/?engineType=SCA&issue=7E29B49E42036569BB51EF5AD7810192"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1591",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method createContent() in Encoding.java sends unvalidated data to a web browser on line 369, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 690. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at Input() in Encoding.java at line 369.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1591/?engineType=SCA&issue=33ADB22325F193F677D42E030B2918D4"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1344",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at Encoding.java line 454 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1344/?engineType=SCA&issue=FA89BB7A1F8F3D3C0EE4DDF569255312"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "408",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in Encoding.java might reveal system data or debugging information by calling printStackTrace() on line 459.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/408/?engineType=SCA&issue=8F8078791C5A9942DFCEEC021779672F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "88",
          "shortDescription" : {
            "text" : "Weak Encryption"
          },
          "fullDescription" : {
            "text" : "The program uses a weak encryption algorithm that cannot guarantee the confidentiality of sensitive data.\n\n\n"
          },
          "help" : {
            "text" : "Antiquated encryption algorithms such as DES no longer provide sufficient protection for use with sensitive data. Encryption algorithms rely on key size as one of the primary mechanism to ensure cryptographic strength. Cryptographic strength is often measured by the time and computational power needed to generate a valid key. Advances in computing power have made it possible to obtain small encryption keys in a reasonable amount of time. For example, the 56-bit key used in DES posed a significant computational hurdle in the 1970's when the algorithm was first developed, but today DES can be cracked in less than a day using commonly available equipment.\n      \n\nUse strong encryption algorithms with large key sizes to protect sensitive data. Examples of strong alternatives to DES are Rijndael (Advanced Encryption Standard or AES) and Triple DES (3DES). Before selecting an algorithm, first determine if your organization has standardized on a specific algorithm and implementation.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/88/?engineType=SCA&issue=1D385E28C2D8A9E9F68F0AB8888B5EDF"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "165",
          "shortDescription" : {
            "text" : "Weak Encryption"
          },
          "fullDescription" : {
            "text" : "The program uses a weak encryption algorithm that cannot guarantee the confidentiality of sensitive data.\n\n\n"
          },
          "help" : {
            "text" : "Antiquated encryption algorithms such as DES no longer provide sufficient protection for use with sensitive data. Encryption algorithms rely on key size as one of the primary mechanism to ensure cryptographic strength. Cryptographic strength is often measured by the time and computational power needed to generate a valid key. Advances in computing power have made it possible to obtain small encryption keys in a reasonable amount of time. For example, the 56-bit key used in DES posed a significant computational hurdle in the 1970's when the algorithm was first developed, but today DES can be cracked in less than a day using commonly available equipment.\n      \n\nUse strong encryption algorithms with large key sizes to protect sensitive data. Examples of strong alternatives to DES are Rijndael (Advanced Encryption Standard or AES) and Triple DES (3DES). Before selecting an algorithm, first determine if your organization has standardized on a specific algorithm and implementation.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/165/?engineType=SCA&issue=348DE279CA4677D539557F0772DC215F"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "211",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at Encoding.java line 506 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/211/?engineType=SCA&issue=4393AAA5E6FF2AAE50E53DB18E0ED96E"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "374",
          "shortDescription" : {
            "text" : "Weak Encryption"
          },
          "fullDescription" : {
            "text" : "The program uses a weak encryption algorithm that cannot guarantee the confidentiality of sensitive data.\n\n\n"
          },
          "help" : {
            "text" : "Antiquated encryption algorithms such as DES no longer provide sufficient protection for use with sensitive data. Encryption algorithms rely on key size as one of the primary mechanism to ensure cryptographic strength. Cryptographic strength is often measured by the time and computational power needed to generate a valid key. Advances in computing power have made it possible to obtain small encryption keys in a reasonable amount of time. For example, the 56-bit key used in DES posed a significant computational hurdle in the 1970's when the algorithm was first developed, but today DES can be cracked in less than a day using commonly available equipment.\n      \n\nUse strong encryption algorithms with large key sizes to protect sensitive data. Examples of strong alternatives to DES are Rijndael (Advanced Encryption Standard or AES) and Triple DES (3DES). Before selecting an algorithm, first determine if your organization has standardized on a specific algorithm and implementation.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/374/?engineType=SCA&issue=80F4A07EEEB4A2FFE6B25E72C01862B9"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "387",
          "shortDescription" : {
            "text" : "Weak Encryption"
          },
          "fullDescription" : {
            "text" : "The program uses a weak encryption algorithm that cannot guarantee the confidentiality of sensitive data.\n\n\n"
          },
          "help" : {
            "text" : "Antiquated encryption algorithms such as DES no longer provide sufficient protection for use with sensitive data. Encryption algorithms rely on key size as one of the primary mechanism to ensure cryptographic strength. Cryptographic strength is often measured by the time and computational power needed to generate a valid key. Advances in computing power have made it possible to obtain small encryption keys in a reasonable amount of time. For example, the 56-bit key used in DES posed a significant computational hurdle in the 1970's when the algorithm was first developed, but today DES can be cracked in less than a day using commonly available equipment.\n      \n\nUse strong encryption algorithms with large key sizes to protect sensitive data. Examples of strong alternatives to DES are Rijndael (Advanced Encryption Standard or AES) and Triple DES (3DES). Before selecting an algorithm, first determine if your organization has standardized on a specific algorithm and implementation.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/387/?engineType=SCA&issue=8703C5DCE8BC7D1128B656E2516864AA"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "314",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at Encoding.java line 550 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/314/?engineType=SCA&issue=69AFA8F30F5B963A36227586517A896A"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "174",
          "shortDescription" : {
            "text" : "Weak Cryptographic Hash"
          },
          "fullDescription" : {
            "text" : "Weak cryptographic hashes cannot guarantee data integrity and should not be used in security-critical contexts.\n\n\n"
          },
          "help" : {
            "text" : "MD5 and SHA-1 are popular cryptographic hash algorithms often used to verify the integrity of messages and other data. Recent advances in cryptanalysis have discovered weaknesses in both algorithms. Consequently, MD5 and SHA-1 should no longer be relied upon to verify the authenticity of data in security-critical contexts.\n\nTechniques for breaking MD5 hashes are advanced and widely available enough that the algorithm must not be relied upon for security. In the case of SHA-1, current techniques still require a significant amount of computational power and are more difficult to implement. However, attackers have found the achiles heal for the algorithm, and techniques for breaking it will likely lead to the discovery of even faster attacks.\n        \n\nDiscontinue the use of MD5 and SHA-1 for data-verification in security-critical contexts. Currently, SHA-224, SHA-256, SHA-384 and SHA-512 are good alternatives. However, these variants of the Secure Hash Algorithm are not standardized and have not been scrutinized as closely as SHA-1, so be mindful of future research that might impact the security of these algorithms.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/174/?engineType=SCA&issue=387A6E66112334525B764D5859E55E28"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "106",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function hashMD5() in Encoding.java might reveal system data or debugging information by calling printStackTrace() on line 646.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/106/?engineType=SCA&issue=23B0D96DBFC08A66930F5E2F13D76E31"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "238",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function hashSHA() in Encoding.java might reveal system data or debugging information by calling printStackTrace() on line 672.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/238/?engineType=SCA&issue=4F0DE05D9365625B7CCD08D58B128F2D"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "264",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/264/?engineType=SCA&issue=5CB1C5DBB07B0DC28312DFF53243B8CB"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "265",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/265/?engineType=SCA&issue=5CB1C5DBB07B0DC28312DFF53243B8CC"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "266",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/266/?engineType=SCA&issue=5CB1C5DBB07B0DC28312DFF53243B8CD"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "267",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/267/?engineType=SCA&issue=5CB1C5DBB07B0DC28312DFF53243B8CE"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "268",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/268/?engineType=SCA&issue=5CB1C5DBB07B0DC28312DFF53243B8CF"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "269",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/269/?engineType=SCA&issue=5CB1C5DBB07B0DC28312DFF53243B8D0"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "270",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/270/?engineType=SCA&issue=5CB1C5DBB07B0DC28312DFF53243B8D1"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "271",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/271/?engineType=SCA&issue=5CB1C5DBB07B0DC28312DFF53243B8D2"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "272",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/272/?engineType=SCA&issue=5CB1C5DBB07B0DC28312DFF53243B8D3"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "273",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/273/?engineType=SCA&issue=5CB1C5DBB07B0DC28312DFF53243B8D4"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "274",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/274/?engineType=SCA&issue=5CB1C5DBB07B0DC28312DFF53243B8D5"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "275",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/275/?engineType=SCA&issue=5CB1C5DBB07B0DC28312DFF53243B8D6"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "276",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/276/?engineType=SCA&issue=5CB1C5DBB07B0DC28312DFF53243B8D7"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "277",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/277/?engineType=SCA&issue=5CB1C5DBB07B0DC28312DFF53243B8D8"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "278",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/278/?engineType=SCA&issue=5CB1C5DBB07B0DC28312DFF53243B8D9"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "279",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/279/?engineType=SCA&issue=5CB1C5DBB07B0DC28312DFF53243B8DA"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "280",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/280/?engineType=SCA&issue=5CB1C5DBB07B0DC28312DFF53243B8DB"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "281",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/281/?engineType=SCA&issue=5CB1C5DBB07B0DC28312DFF53243B8DC"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "282",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/282/?engineType=SCA&issue=5CB1C5DBB07B0DC28312DFF53243B8DD"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "283",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/283/?engineType=SCA&issue=5CB1C5DBB07B0DC28312DFF53243B8DE"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "284",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/284/?engineType=SCA&issue=5CB1C5DBB07B0DC28312DFF53243B8DF"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "285",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/285/?engineType=SCA&issue=5CB1C5DBB07B0DC28312DFF53243B8E0"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "286",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/286/?engineType=SCA&issue=5CB1C5DBB07B0DC28312DFF53243B8E1"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "287",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/287/?engineType=SCA&issue=5CB1C5DBB07B0DC28312DFF53243B8E2"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "288",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/288/?engineType=SCA&issue=5CB1C5DBB07B0DC28312DFF53243B8E3"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "3",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Encoding.java might reveal system data or debugging information by calling printStackTrace() on line 774.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/3/?engineType=SCA&issue=047AD488FEFFFA0C26F978A64B811539"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1749",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method makeRow() in Encoding.java sends unvalidated data to a web browser on line 793, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at addElement() in Encoding.java at line 793.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1749/?engineType=SCA&issue=BEDCCF5FAF96831DFB46C298DEA5D5F1"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1778",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method makeRow() in Encoding.java sends unvalidated data to a web browser on line 793, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 690. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at addElement() in Encoding.java at line 793.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1778/?engineType=SCA&issue=D06D0B220A3FD266C8526B6593E997D2"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1688",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method makeRow() in Encoding.java sends unvalidated data to a web browser on line 794, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at addElement() in Encoding.java at line 794.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1688/?engineType=SCA&issue=8ADD0449AB48BA588FCC57E4041FC215"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1774",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method makeRow() in Encoding.java sends unvalidated data to a web browser on line 794, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 690. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at addElement() in Encoding.java at line 794.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1774/?engineType=SCA&issue=CDC14D16B2CD1B1BA14427B6ECE70C10"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "355",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at Encoding.java line 888 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/355/?engineType=SCA&issue=7C97574C3CAD67BA5CD63D67D481A34A"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "162",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at Encoding.java line 913 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/162/?engineType=SCA&issue=343C03986DD94B14AE89E112D9996126"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "443",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at Encoding.java line 934 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/443/?engineType=SCA&issue=9904A183BAB676911A2289782DC66DDE"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "341",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at Encoding.java line 955 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/341/?engineType=SCA&issue=753A183455F634315530AE1E98A143DF"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "614",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at Encoding.java line 1010 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/614/?engineType=SCA&issue=DA56595234EEEA123859B0B222390CC4"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1038",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at FailOpenAuthentication.java line 83 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1038/?engineType=SCA&issue=0DE544B64FCA127F87821524FA7D9AD5"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1039",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at FailOpenAuthentication.java line 120 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1039/?engineType=SCA&issue=0DE544B64FCA127F87821524FA7D9AD6"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1812",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method doStage3() in ForgotPassword.java sends unvalidated data to a web browser on line 191, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 690. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at addElement() in ForgotPassword.java at line 191.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1812/?engineType=SCA&issue=EA39016909F45F53EEFCE398478A6CEC"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1813",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method doStage3() in ForgotPassword.java sends unvalidated data to a web browser on line 195, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 690. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at addElement() in ForgotPassword.java at line 195.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1813/?engineType=SCA&issue=EA39016909F45F53EEFCE398478A6CED"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1340",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at HiddenFieldTampering.java line 162 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1340/?engineType=SCA&issue=F781AE2F2B5CFCB65D86E93F9447C3BB"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "42",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in HiddenFieldTampering.java might reveal system data or debugging information by calling printStackTrace() on line 165.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/42/?engineType=SCA&issue=131F17E79F63F981BB3DAA10455F2822"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1104",
          "shortDescription" : {
            "text" : "Password Management: Hardcoded Password"
          },
          "fullDescription" : {
            "text" : "Hardcoded passwords can compromise system security in a way that cannot be easily remedied.\n\n\n"
          },
          "help" : {
            "text" : "It is never a good idea to hardcode a password. Not only does hardcoding a password allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. Once the code is in production, the password cannot be changed without patching the software. If the account protected by the password is compromised, the owners of the system will be forced to choose between security and availability.\n\n\nExample: The following code uses a hardcoded password to connect to a database:\n\n\n...\nDriverManager.getConnection(url, \"scott\", \"tiger\");\n...\n\n\nThis code will run successfully, but anyone who has access to it will have access to the password. Once the program has shipped, there is no going back from the database user \"scott\" with a password of \"tiger\" unless the program is patched. A devious employee with access to this information can use it to break into the system. Even worse, if attackers have access to the bytecode for application, they can use the javap -c command to access the disassembled code, which will contain the values of the passwords used. The result of this operation might look something like the following for the example above:\n\n\njavap -c ConnMngr.class\n\n22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql\n24: ldc   #38; //String scott\n26: ldc   #17; //String tiger\n\n\n\nPasswords should never be hardcoded and should generally be obfuscated and managed in an external source. Storing passwords in plaintext anywhere on the system allows anyone with sufficient permissions to read and potentially misuse the password.\n\nSome third party products claim the ability to manage passwords in a more secure way. For example, WebSphere Application Server 4.x uses a simple XOR encryption algorithm for obfuscating values, but be skeptical about such facilities. WebSphere and other application servers offer outdated and relatively weak encryption mechanisms that are insufficient for security-sensitive environments. For a secure solution, the only viable option available today appears to be a proprietary one that you create.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1104/?engineType=SCA&issue=3E9A67399C7A2107EBB53F4242B220BB"
          },
          "properties" : {
            "tags" : [ "Medium" ],
            "precision" : "high"
          }
        }, {
          "id" : "1353",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at HtmlClues.java line 117 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1353/?engineType=SCA&issue=FEE47E13497AADC6846BF2CF26134240"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1116",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Throws"
          },
          "fullDescription" : {
            "text" : "The method makeUser() in HtmlClues.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
          },
          "help" : {
            "text" : "Declaring a method to throw Exception or Throwable makes it difficult for callers to do good error handling and error recovery. Java's exception mechanism is set up to make it easy for callers to anticipate what can go wrong and write code to handle each specific exceptional circumstance. Declaring that a method throws a generic form of exception defeats this system.\n\nExample: The following method throws three types of exceptions.\n\n\npublic void doExchange()\n  throws IOException, InvocationTargetException,\n         SQLException {\n  ...\n}\n\n\n\nWhile it might seem tidier to write \n\n\npublic void doExchange()\n  throws Exception {\n  ...\n}\n\n\ndoing so hampers the caller's ability to understand and handle the exceptions that occur. Further, if a later revision of doExchange() introduces a new type of exception that should be treated differently than previous exceptions, there is no easy way to enforce this requirement.\n\nDo not declare methods to throw Exception or Throwable. If the exceptions thrown by a method are not recoverable or should not generally be caught by the caller, consider throwing unchecked exceptions rather than checked exceptions. This can be accomplished by implementing exception classes that extend RuntimeException or Error instead of Exception, or add a try/catch wrapper in your method to convert checked exceptions to unchecked exceptions.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1116/?engineType=SCA&issue=4767A39CC82624C8DF94CE558388608F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1725",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method createContent() in HttpBasics.java sends unvalidated data to a web browser on line 69, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 690. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at Input() in HttpBasics.java at line 69.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1725/?engineType=SCA&issue=AD369356003E8FDF1BE045DC0DBD47C6"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1218",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at HttpBasics.java line 75 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1218/?engineType=SCA&issue=9A64EB5F4DAAD544B98B7A3F77888671"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "326",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in HttpBasics.java might reveal system data or debugging information by calling printStackTrace() on line 78.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/326/?engineType=SCA&issue=705FAE3DBC111FD136600AFD4984E076"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1197",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at HttpOnly.java line 135 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1197/?engineType=SCA&issue=86B0143484F9727BE30DABC842B2E830"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "459",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in HttpOnly.java might reveal system data or debugging information by calling printStackTrace() on line 138.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/459/?engineType=SCA&issue=9F51D6250F83EF2B7731EF14E7136769"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "352",
          "shortDescription" : {
            "text" : "Weak Cryptographic Hash"
          },
          "fullDescription" : {
            "text" : "Weak cryptographic hashes cannot guarantee data integrity and should not be used in security-critical contexts.\n\n\n"
          },
          "help" : {
            "text" : "MD5 and SHA-1 are popular cryptographic hash algorithms often used to verify the integrity of messages and other data. Recent advances in cryptanalysis have discovered weaknesses in both algorithms. Consequently, MD5 and SHA-1 should no longer be relied upon to verify the authenticity of data in security-critical contexts.\n\nTechniques for breaking MD5 hashes are advanced and widely available enough that the algorithm must not be relied upon for security. In the case of SHA-1, current techniques still require a significant amount of computational power and are more difficult to implement. However, attackers have found the achiles heal for the algorithm, and techniques for breaking it will likely lead to the discovery of even faster attacks.\n        \n\nDiscontinue the use of MD5 and SHA-1 for data-verification in security-critical contexts. Currently, SHA-224, SHA-256, SHA-384 and SHA-512 are good alternatives. However, these variants of the Secure Hash Algorithm are not standardized and have not been scrutinized as closely as SHA-1, so be mindful of future research that might impact the security of these algorithms.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/352/?engineType=SCA&issue=7B3C46156F8E01CD8D68BF30D9E9F0D0"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "621",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at HttpOnly.java line 182 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/621/?engineType=SCA&issue=DC120EC648920C0CB86F457A3F43AE04"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "421",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createCustomCookieValue() in HttpOnly.java might reveal system data or debugging information by calling printStackTrace() on line 183.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/421/?engineType=SCA&issue=95782931E073FCBD728BDF3DA7F39E90"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1161",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method makeContent() in HttpOnly.java sends unvalidated data to a web browser on line 233, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getHeader() in WebSession.java at line 1145. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at TD() in HttpOnly.java at line 233.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1161/?engineType=SCA&issue=699EC0C6D59F22AD41D6C82B0643977E"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1742",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method doHTTPSplitting() in HttpSplitting.java sends unvalidated data to a web browser on line 112, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at print() in HttpSplitting.java at line 112.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1742/?engineType=SCA&issue=BCE407BB56586EA1ECB60962B79933E8"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1031",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at HttpSplitting.java line 134 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1031/?engineType=SCA&issue=087ABE155D9A70976AC25EB45032F4DB"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "260",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function doHTTPSplitting() in HttpSplitting.java might reveal system data or debugging information by calling printStackTrace() on line 137.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/260/?engineType=SCA&issue=5C63D969F93AD4F6406AD4E5C137651D"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1250",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Throws"
          },
          "fullDescription" : {
            "text" : "The method createAttackEnvironment() in HttpSplitting.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
          },
          "help" : {
            "text" : "Declaring a method to throw Exception or Throwable makes it difficult for callers to do good error handling and error recovery. Java's exception mechanism is set up to make it easy for callers to anticipate what can go wrong and write code to handle each specific exceptional circumstance. Declaring that a method throws a generic form of exception defeats this system.\n\nExample: The following method throws three types of exceptions.\n\n\npublic void doExchange()\n  throws IOException, InvocationTargetException,\n         SQLException {\n  ...\n}\n\n\n\nWhile it might seem tidier to write \n\n\npublic void doExchange()\n  throws Exception {\n  ...\n}\n\n\ndoing so hampers the caller's ability to understand and handle the exceptions that occur. Further, if a later revision of doExchange() introduces a new type of exception that should be treated differently than previous exceptions, there is no easy way to enforce this requirement.\n\nDo not declare methods to throw Exception or Throwable. If the exceptions thrown by a method are not recoverable or should not generally be caught by the caller, consider throwing unchecked exceptions rather than checked exceptions. This can be accomplished by implementing exception classes that extend RuntimeException or Error instead of Exception, or add a try/catch wrapper in your method to convert checked exceptions to unchecked exceptions.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1250/?engineType=SCA&issue=B1EAD77CBD01B93091502EBF26A4247B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1703",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method createAttackEnvironment() in HttpSplitting.java sends unvalidated data to a web browser on line 180, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at Input() in HttpSplitting.java at line 180.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1703/?engineType=SCA&issue=9A75C2F16C64D536498D5DE279270851"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1203",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Throws"
          },
          "fullDescription" : {
            "text" : "The method doCachePoisining() in HttpSplitting.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
          },
          "help" : {
            "text" : "Declaring a method to throw Exception or Throwable makes it difficult for callers to do good error handling and error recovery. Java's exception mechanism is set up to make it easy for callers to anticipate what can go wrong and write code to handle each specific exceptional circumstance. Declaring that a method throws a generic form of exception defeats this system.\n\nExample: The following method throws three types of exceptions.\n\n\npublic void doExchange()\n  throws IOException, InvocationTargetException,\n         SQLException {\n  ...\n}\n\n\n\nWhile it might seem tidier to write \n\n\npublic void doExchange()\n  throws Exception {\n  ...\n}\n\n\ndoing so hampers the caller's ability to understand and handle the exceptions that occur. Further, if a later revision of doExchange() introduces a new type of exception that should be treated differently than previous exceptions, there is no easy way to enforce this requirement.\n\nDo not declare methods to throw Exception or Throwable. If the exceptions thrown by a method are not recoverable or should not generally be caught by the caller, consider throwing unchecked exceptions rather than checked exceptions. This can be accomplished by implementing exception classes that extend RuntimeException or Error instead of Exception, or add a try/catch wrapper in your method to convert checked exceptions to unchecked exceptions.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1203/?engineType=SCA&issue=8C3759D2B027E1A49E71D3884549506C"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1248",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at HttpSplitting.java line 235 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1248/?engineType=SCA&issue=B02AB669464EFCA850ADAB79153AB0F3"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1284",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at JSONInjection.java line 96 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1284/?engineType=SCA&issue=CC441EE121689CBCFF5985EF5C6F0192"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "649",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in JSONInjection.java might reveal system data or debugging information by calling printStackTrace() on line 98.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/649/?engineType=SCA&issue=E8EF5733799D99324748E618EBE6DC59"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1661",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method createContent() in JavaScriptValidation.java sends unvalidated data to a web browser on line 151, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at addElement() in JavaScriptValidation.java at line 151.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1661/?engineType=SCA&issue=7254A7590AFC4358ECE78B61DC667AC7"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1561",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method createContent() in JavaScriptValidation.java sends unvalidated data to a web browser on line 152, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at addElement() in JavaScriptValidation.java at line 152.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1561/?engineType=SCA&issue=19446190ED48006EA5FC0AC7391FB73C"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1807",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method createContent() in JavaScriptValidation.java sends unvalidated data to a web browser on line 153, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at addElement() in JavaScriptValidation.java at line 153.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1807/?engineType=SCA&issue=E7650F080FCA7F6E00F264D3F365723C"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1582",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method createContent() in JavaScriptValidation.java sends unvalidated data to a web browser on line 154, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at addElement() in JavaScriptValidation.java at line 154.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1582/?engineType=SCA&issue=2B2E80C3F1C5324EC70FFBD406310CAB"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1560",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method createContent() in JavaScriptValidation.java sends unvalidated data to a web browser on line 155, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at addElement() in JavaScriptValidation.java at line 155.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1560/?engineType=SCA&issue=164F50FC73966E07C13D9DBF85E6B422"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1536",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method createContent() in JavaScriptValidation.java sends unvalidated data to a web browser on line 156, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at addElement() in JavaScriptValidation.java at line 156.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1536/?engineType=SCA&issue=011CBF50B0452709FF1FE1CC8FA779EA"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1605",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method createContent() in JavaScriptValidation.java sends unvalidated data to a web browser on line 157, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at addElement() in JavaScriptValidation.java at line 157.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1605/?engineType=SCA&issue=3E1DFE39AC6795E887C355DBA577DA93"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1070",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at JavaScriptValidation.java line 256 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1070/?engineType=SCA&issue=22A4836C713C17B989180F3ECF1010FA"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "713",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in JavaScriptValidation.java might reveal system data or debugging information by calling printStackTrace() on line 259.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/713/?engineType=SCA&issue=FC52535F6E6C764EA9B84AD5EA60A650"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1271",
          "shortDescription" : {
            "text" : "Unreleased Resource: Streams"
          },
          "fullDescription" : {
            "text" : "The function createContent() in LessonAdapter.java sometimes fails to release a system resource allocated by FileReader() on line 93.\n\n\n"
          },
          "help" : {
            "text" : "The program can potentially fail to release a system resource.\n\n    In this case, there are program paths on which the resource allocated in LessonAdapter.java at line 93 is not released.\n\n\nResource leaks have at least two common causes:\n\n- Error conditions and other exceptional circumstances.\n\n- Confusion over which part of the program is responsible for releasing the resource.\n\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.\n\nExample 1: The following method never closes the file handle it opens. The finalize() method for FileInputStream eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n\n\nprivate void processFile(String fName) throws FileNotFoundException, IOException\n{\n  FileInputStream fis = new FileInputStream(fName);\n  int sz;\n  byte[] byteArray = new byte[BLOCK_SIZE];\n  while ((sz = fis.read(byteArray)) != -1) {\n    processBytes(byteArray, sz);\n  }\n}\n\n\nExample 2: Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.\n\n\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(CXN_SQL);\n  harvestResults(rs);\n  stmt.close();\n\n\n\n1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to \"bursty\" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.\n\nFinally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang. \n\n2. Release resources in a finally block. The code for Example 2 should be rewritten as follows:\n\n\n  public void execCxnSql(Connection conn) {\n    Statement stmt;\n    try {\n      stmt = conn.createStatement();\n      ResultSet rs = stmt.executeQuery(CXN_SQL);\n      ...\n    }\n    finally {\n      if (stmt != null) {\n        safeClose(stmt);\n      }\n    }\n}\n\npublic static void safeClose(Statement stmt) {\n  if (stmt != null) {\n    try {\n      stmt.close();\n    } catch (SQLException e) {\n      log(e);\n    }\n  }\n}\n\n\nThis solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. \n\nAlso, the execCxnSql method does not initialize the stmt object to null. Instead, it checks to ensure that stmt is not null before calling safeClose(). Without the null check, the Java compiler reports that stmt might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  stmt is initialized to null in a more complex method, cases in which stmt is used without being initialized will not be detected by the compiler. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1271/?engineType=SCA&issue=C4EC2EDAF3F91A3A50B5499E737521B1"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1083",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method createContent() in LessonAdapter.java ignores an exception on line 101, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1083/?engineType=SCA&issue=2EE47323376419DC1AC49BFA7555650D"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1084",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at LessonAdapter.java line 101 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1084/?engineType=SCA&issue=2F63C2CCFAE28AED6CFE759ECFC70042"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1220",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at LessonAdapter.java line 133 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1220/?engineType=SCA&issue=9CC762D4A5363E23A8411E24D9256C7C"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "559",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createStagedContent() in LessonAdapter.java might reveal system data or debugging information by calling println() on line 136.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/559/?engineType=SCA&issue=BEB4814E49EAA11F2CEA573D16ECDB6E"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1230",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1230/?engineType=SCA&issue=A99D14BD0EF414E4CC24FC619B870E81"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "89",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createStagedContent() in LessonAdapter.java might reveal system data or debugging information by calling printStackTrace() on line 137.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/89/?engineType=SCA&issue=1D501737C15AE10645708C25342F008F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1069",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Throws"
          },
          "fullDescription" : {
            "text" : "The method doStage1() in LessonAdapter.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
          },
          "help" : {
            "text" : "Declaring a method to throw Exception or Throwable makes it difficult for callers to do good error handling and error recovery. Java's exception mechanism is set up to make it easy for callers to anticipate what can go wrong and write code to handle each specific exceptional circumstance. Declaring that a method throws a generic form of exception defeats this system.\n\nExample: The following method throws three types of exceptions.\n\n\npublic void doExchange()\n  throws IOException, InvocationTargetException,\n         SQLException {\n  ...\n}\n\n\n\nWhile it might seem tidier to write \n\n\npublic void doExchange()\n  throws Exception {\n  ...\n}\n\n\ndoing so hampers the caller's ability to understand and handle the exceptions that occur. Further, if a later revision of doExchange() introduces a new type of exception that should be treated differently than previous exceptions, there is no easy way to enforce this requirement.\n\nDo not declare methods to throw Exception or Throwable. If the exceptions thrown by a method are not recoverable or should not generally be caught by the caller, consider throwing unchecked exceptions rather than checked exceptions. This can be accomplished by implementing exception classes that extend RuntimeException or Error instead of Exception, or add a try/catch wrapper in your method to convert checked exceptions to unchecked exceptions.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1069/?engineType=SCA&issue=210AA1A8EFBCB73D3D72870FCFCE5041"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1138",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Throws"
          },
          "fullDescription" : {
            "text" : "The method doStage2() in LessonAdapter.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
          },
          "help" : {
            "text" : "Declaring a method to throw Exception or Throwable makes it difficult for callers to do good error handling and error recovery. Java's exception mechanism is set up to make it easy for callers to anticipate what can go wrong and write code to handle each specific exceptional circumstance. Declaring that a method throws a generic form of exception defeats this system.\n\nExample: The following method throws three types of exceptions.\n\n\npublic void doExchange()\n  throws IOException, InvocationTargetException,\n         SQLException {\n  ...\n}\n\n\n\nWhile it might seem tidier to write \n\n\npublic void doExchange()\n  throws Exception {\n  ...\n}\n\n\ndoing so hampers the caller's ability to understand and handle the exceptions that occur. Further, if a later revision of doExchange() introduces a new type of exception that should be treated differently than previous exceptions, there is no easy way to enforce this requirement.\n\nDo not declare methods to throw Exception or Throwable. If the exceptions thrown by a method are not recoverable or should not generally be caught by the caller, consider throwing unchecked exceptions rather than checked exceptions. This can be accomplished by implementing exception classes that extend RuntimeException or Error instead of Exception, or add a try/catch wrapper in your method to convert checked exceptions to unchecked exceptions.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1138/?engineType=SCA&issue=5503BCF906889669D3706765FAA2A3D8"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1113",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Throws"
          },
          "fullDescription" : {
            "text" : "The method doStage3() in LessonAdapter.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
          },
          "help" : {
            "text" : "Declaring a method to throw Exception or Throwable makes it difficult for callers to do good error handling and error recovery. Java's exception mechanism is set up to make it easy for callers to anticipate what can go wrong and write code to handle each specific exceptional circumstance. Declaring that a method throws a generic form of exception defeats this system.\n\nExample: The following method throws three types of exceptions.\n\n\npublic void doExchange()\n  throws IOException, InvocationTargetException,\n         SQLException {\n  ...\n}\n\n\n\nWhile it might seem tidier to write \n\n\npublic void doExchange()\n  throws Exception {\n  ...\n}\n\n\ndoing so hampers the caller's ability to understand and handle the exceptions that occur. Further, if a later revision of doExchange() introduces a new type of exception that should be treated differently than previous exceptions, there is no easy way to enforce this requirement.\n\nDo not declare methods to throw Exception or Throwable. If the exceptions thrown by a method are not recoverable or should not generally be caught by the caller, consider throwing unchecked exceptions rather than checked exceptions. This can be accomplished by implementing exception classes that extend RuntimeException or Error instead of Exception, or add a try/catch wrapper in your method to convert checked exceptions to unchecked exceptions.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1113/?engineType=SCA&issue=444E18A164A77C9987658EB0D0F46EBF"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1068",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Throws"
          },
          "fullDescription" : {
            "text" : "The method doStage4() in LessonAdapter.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
          },
          "help" : {
            "text" : "Declaring a method to throw Exception or Throwable makes it difficult for callers to do good error handling and error recovery. Java's exception mechanism is set up to make it easy for callers to anticipate what can go wrong and write code to handle each specific exceptional circumstance. Declaring that a method throws a generic form of exception defeats this system.\n\nExample: The following method throws three types of exceptions.\n\n\npublic void doExchange()\n  throws IOException, InvocationTargetException,\n         SQLException {\n  ...\n}\n\n\n\nWhile it might seem tidier to write \n\n\npublic void doExchange()\n  throws Exception {\n  ...\n}\n\n\ndoing so hampers the caller's ability to understand and handle the exceptions that occur. Further, if a later revision of doExchange() introduces a new type of exception that should be treated differently than previous exceptions, there is no easy way to enforce this requirement.\n\nDo not declare methods to throw Exception or Throwable. If the exceptions thrown by a method are not recoverable or should not generally be caught by the caller, consider throwing unchecked exceptions rather than checked exceptions. This can be accomplished by implementing exception classes that extend RuntimeException or Error instead of Exception, or add a try/catch wrapper in your method to convert checked exceptions to unchecked exceptions.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1068/?engineType=SCA&issue=20D8D8DC490B4033D5BED8E678B7B761"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1337",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Throws"
          },
          "fullDescription" : {
            "text" : "The method doStage5() in LessonAdapter.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
          },
          "help" : {
            "text" : "Declaring a method to throw Exception or Throwable makes it difficult for callers to do good error handling and error recovery. Java's exception mechanism is set up to make it easy for callers to anticipate what can go wrong and write code to handle each specific exceptional circumstance. Declaring that a method throws a generic form of exception defeats this system.\n\nExample: The following method throws three types of exceptions.\n\n\npublic void doExchange()\n  throws IOException, InvocationTargetException,\n         SQLException {\n  ...\n}\n\n\n\nWhile it might seem tidier to write \n\n\npublic void doExchange()\n  throws Exception {\n  ...\n}\n\n\ndoing so hampers the caller's ability to understand and handle the exceptions that occur. Further, if a later revision of doExchange() introduces a new type of exception that should be treated differently than previous exceptions, there is no easy way to enforce this requirement.\n\nDo not declare methods to throw Exception or Throwable. If the exceptions thrown by a method are not recoverable or should not generally be caught by the caller, consider throwing unchecked exceptions rather than checked exceptions. This can be accomplished by implementing exception classes that extend RuntimeException or Error instead of Exception, or add a try/catch wrapper in your method to convert checked exceptions to unchecked exceptions.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1337/?engineType=SCA&issue=F3E81447B7A253F2AB8E9FF9EBE13A3F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1183",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Throws"
          },
          "fullDescription" : {
            "text" : "The method doStage6() in LessonAdapter.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
          },
          "help" : {
            "text" : "Declaring a method to throw Exception or Throwable makes it difficult for callers to do good error handling and error recovery. Java's exception mechanism is set up to make it easy for callers to anticipate what can go wrong and write code to handle each specific exceptional circumstance. Declaring that a method throws a generic form of exception defeats this system.\n\nExample: The following method throws three types of exceptions.\n\n\npublic void doExchange()\n  throws IOException, InvocationTargetException,\n         SQLException {\n  ...\n}\n\n\n\nWhile it might seem tidier to write \n\n\npublic void doExchange()\n  throws Exception {\n  ...\n}\n\n\ndoing so hampers the caller's ability to understand and handle the exceptions that occur. Further, if a later revision of doExchange() introduces a new type of exception that should be treated differently than previous exceptions, there is no easy way to enforce this requirement.\n\nDo not declare methods to throw Exception or Throwable. If the exceptions thrown by a method are not recoverable or should not generally be caught by the caller, consider throwing unchecked exceptions rather than checked exceptions. This can be accomplished by implementing exception classes that extend RuntimeException or Error instead of Exception, or add a try/catch wrapper in your method to convert checked exceptions to unchecked exceptions.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1183/?engineType=SCA&issue=7DCAF2F4819DDFC80CC5DDD5783F98D8"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1283",
          "shortDescription" : {
            "text" : "Unreleased Resource: Streams"
          },
          "fullDescription" : {
            "text" : "The function getInstructions() in LessonAdapter.java sometimes fails to release a system resource allocated by FileReader() on line 285.\n\n\n"
          },
          "help" : {
            "text" : "The program can potentially fail to release a system resource.\n\n    In this case, there are program paths on which the resource allocated in LessonAdapter.java at line 285 is not released.\n\n\nResource leaks have at least two common causes:\n\n- Error conditions and other exceptional circumstances.\n\n- Confusion over which part of the program is responsible for releasing the resource.\n\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.\n\nExample 1: The following method never closes the file handle it opens. The finalize() method for FileInputStream eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n\n\nprivate void processFile(String fName) throws FileNotFoundException, IOException\n{\n  FileInputStream fis = new FileInputStream(fName);\n  int sz;\n  byte[] byteArray = new byte[BLOCK_SIZE];\n  while ((sz = fis.read(byteArray)) != -1) {\n    processBytes(byteArray, sz);\n  }\n}\n\n\nExample 2: Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.\n\n\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(CXN_SQL);\n  harvestResults(rs);\n  stmt.close();\n\n\n\n1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to \"bursty\" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.\n\nFinally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang. \n\n2. Release resources in a finally block. The code for Example 2 should be rewritten as follows:\n\n\n  public void execCxnSql(Connection conn) {\n    Statement stmt;\n    try {\n      stmt = conn.createStatement();\n      ResultSet rs = stmt.executeQuery(CXN_SQL);\n      ...\n    }\n    finally {\n      if (stmt != null) {\n        safeClose(stmt);\n      }\n    }\n}\n\npublic static void safeClose(Statement stmt) {\n  if (stmt != null) {\n    try {\n      stmt.close();\n    } catch (SQLException e) {\n      log(e);\n    }\n  }\n}\n\n\nThis solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. \n\nAlso, the execCxnSql method does not initialize the stmt object to null. Instead, it checks to ensure that stmt is not null before calling safeClose(). Without the null check, the Java compiler reports that stmt might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  stmt is initialized to null in a more complex method, cases in which stmt is used without being initialized will not be detected by the compiler. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1283/?engineType=SCA&issue=CB8421F4774F0AA99840B6DD04FD0829"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1117",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at LessonAdapter.java line 307 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1117/?engineType=SCA&issue=479D8434A7EC31083CB113B28A3585E9"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1177",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method getInstructions() in LessonAdapter.java ignores an exception on line 307, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1177/?engineType=SCA&issue=79B88F7181952E921D27629409A338C8"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "371",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in LogSpoofing.java might reveal system data or debugging information by calling printStackTrace() on line 128.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/371/?engineType=SCA&issue=808268520EA61ACECDD3CE502C001181"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1266",
          "shortDescription" : {
            "text" : "Unreleased Resource: Streams"
          },
          "fullDescription" : {
            "text" : "The function createContent() in PathBasedAccessControl.java sometimes fails to release a system resource allocated by FileReader() on line 193.\n\n\n"
          },
          "help" : {
            "text" : "The program can potentially fail to release a system resource.\n\n    In this case, there are program paths on which the resource allocated in PathBasedAccessControl.java at line 193 is not released.\n\n\nResource leaks have at least two common causes:\n\n- Error conditions and other exceptional circumstances.\n\n- Confusion over which part of the program is responsible for releasing the resource.\n\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.\n\nExample 1: The following method never closes the file handle it opens. The finalize() method for FileInputStream eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n\n\nprivate void processFile(String fName) throws FileNotFoundException, IOException\n{\n  FileInputStream fis = new FileInputStream(fName);\n  int sz;\n  byte[] byteArray = new byte[BLOCK_SIZE];\n  while ((sz = fis.read(byteArray)) != -1) {\n    processBytes(byteArray, sz);\n  }\n}\n\n\nExample 2: Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.\n\n\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(CXN_SQL);\n  harvestResults(rs);\n  stmt.close();\n\n\n\n1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to \"bursty\" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.\n\nFinally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang. \n\n2. Release resources in a finally block. The code for Example 2 should be rewritten as follows:\n\n\n  public void execCxnSql(Connection conn) {\n    Statement stmt;\n    try {\n      stmt = conn.createStatement();\n      ResultSet rs = stmt.executeQuery(CXN_SQL);\n      ...\n    }\n    finally {\n      if (stmt != null) {\n        safeClose(stmt);\n      }\n    }\n}\n\npublic static void safeClose(Statement stmt) {\n  if (stmt != null) {\n    try {\n      stmt.close();\n    } catch (SQLException e) {\n      log(e);\n    }\n  }\n}\n\n\nThis solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. \n\nAlso, the execCxnSql method does not initialize the stmt object to null. Instead, it checks to ensure that stmt is not null before calling safeClose(). Without the null check, the Java compiler reports that stmt might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  stmt is initialized to null in a more complex method, cases in which stmt is used without being initialized will not be detected by the compiler. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1266/?engineType=SCA&issue=C18864ACC2F321D56CB007715E732C95"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1081",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at PathBasedAccessControl.java line 205 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1081/?engineType=SCA&issue=2E131433EC8F7F66252F9B914828ED18"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1082",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at PathBasedAccessControl.java line 214 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1082/?engineType=SCA&issue=2E131433EC8F7F66252F9B914828ED19"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "617",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in PathBasedAccessControl.java might reveal system data or debugging information by calling printStackTrace() on line 217.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/617/?engineType=SCA&issue=DABE998A0B6FAD79EB0991E4EAAC181B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1636",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method createContent() in ReflectedXSS.java sends unvalidated data to a web browser on line 123, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 690. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at Input() in ReflectedXSS.java at line 123.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1636/?engineType=SCA&issue=67479E5D27D466B1FF4EC8510AF92AAB"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1744",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method createContent() in ReflectedXSS.java sends unvalidated data to a web browser on line 136, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 690. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at Input() in ReflectedXSS.java at line 136.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1744/?engineType=SCA&issue=BDC530F36AC693299AFA524089900733"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1578",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method createContent() in ReflectedXSS.java sends unvalidated data to a web browser on line 150, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 690. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at Input() in ReflectedXSS.java at line 150.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1578/?engineType=SCA&issue=27054C1C60FF93F008A72761A672E678"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1548",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method createContent() in ReflectedXSS.java sends unvalidated data to a web browser on line 165, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 690. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at Input() in ReflectedXSS.java at line 165.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1548/?engineType=SCA&issue=0E0CE8A9C2B1F827612536E92E906C5D"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1664",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method createContent() in ReflectedXSS.java sends unvalidated data to a web browser on line 200, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at Input() in ReflectedXSS.java at line 200.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1664/?engineType=SCA&issue=737A32658038060D09F9D4E83CEDD366"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1593",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method createContent() in ReflectedXSS.java sends unvalidated data to a web browser on line 206, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at Input() in ReflectedXSS.java at line 206.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1593/?engineType=SCA&issue=34B726630369800850C455085CAE1693"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1142",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ReflectedXSS.java line 219 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1142/?engineType=SCA&issue=5D57D541A4E77A3C27CEC7F47437BC72"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "692",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in ReflectedXSS.java might reveal system data or debugging information by calling printStackTrace() on line 222.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/692/?engineType=SCA&issue=F570B583EF594B28853E556BE72B33B8"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1305",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1305/?engineType=SCA&issue=D7742027805A041229AED9F1E04A58E2"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1689",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in DeleteProfile.java might reveal system data or debugging information by calling printStackTrace() on line 81.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1689/?engineType=SCA&issue=8B01FD5075A32F5302CF5236E389A97E"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1306",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1306/?engineType=SCA&issue=D7742027805A041229AED9F1E04A58E3"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1713",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in DeleteProfile.java might reveal system data or debugging information by calling printStackTrace() on line 86.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1713/?engineType=SCA&issue=A43277672E8AE03DDDA5863F1377295E"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "246",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function deleteEmployeeProfile() in DeleteProfile.java might reveal system data or debugging information by calling printStackTrace() on line 120.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/246/?engineType=SCA&issue=52C8ADF9D15390304DD17CB7F9DC8B02"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1106",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at DeleteProfile.java line 123 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1106/?engineType=SCA&issue=424A8CB8DF4C3613CD348380203A43AC"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "122",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function deleteEmployeeProfile() in DeleteProfile.java might reveal system data or debugging information by calling printStackTrace() on line 126.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/122/?engineType=SCA&issue=29F8047D0743AF3156E0715069C95333"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "183",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 144 of DeleteProfile.java, the method deleteEmployeeProfile_BACKUP() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\nIn this case Fortify could not determine that the source of the data is trusted.\n\n2. The data is used to dynamically construct a SQL query. \n\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.  \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one used in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can: \n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but when user-supplied data needs to be included, they create bind parameters, which are placeholders for data that is subsequently inserted. Bind parameters allow the program to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for the value of each of the bind parameters, without the risk of the data being interpreted as commands. \n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n        \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the command structure of the SQL statement, such as the addition of dynamic constraints in the WHERE clause. Do not use this requirement to justify concatenating user input into query strings. Prevent SQL injection attacks where user input must affect statement command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/183/?engineType=SCA&issue=3B9CAEDBA3EF988863E7FA1E4EDE4143"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "506",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function deleteEmployeeProfile_BACKUP() in DeleteProfile.java might reveal system data or debugging information by calling printStackTrace() on line 149.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/506/?engineType=SCA&issue=AD7C11D3EB0D8558FDC22AB525483F1A"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1189",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at DeleteProfile.java line 152 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1189/?engineType=SCA&issue=80328305A482EF3761B1FC9FE95E8CAF"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "630",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function deleteEmployeeProfile_BACKUP() in DeleteProfile.java might reveal system data or debugging information by calling printStackTrace() on line 155.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/630/?engineType=SCA&issue=E0A0EB22F4A6987698B4EBD02907B826"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1217",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method updateLessonStatus() in DeleteProfile.java ignores an exception on line 176, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1217/?engineType=SCA&issue=9A51D4CAF48BD3F8D3960159C5A77305"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "591",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getEmployeeProfile() in EditProfile.java might reveal system data or debugging information by calling printStackTrace() on line 125.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/591/?engineType=SCA&issue=D17F85CED9B5B55047EDD0446A9B17D7"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1600",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at EditProfile.java line 128 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1600/?engineType=SCA&issue=3A68691E3A25CB0691DEE03515003B96"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "114",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getEmployeeProfile() in EditProfile.java might reveal system data or debugging information by calling printStackTrace() on line 131.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/114/?engineType=SCA&issue=271C9A6472859F4F33CAACB572549F42"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "398",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getEmployeeProfile_BACKUP() in EditProfile.java might reveal system data or debugging information by calling printStackTrace() on line 186.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/398/?engineType=SCA&issue=8BD6B7903C38236E8FA6C3B3480A6A40"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1818",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at EditProfile.java line 189 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1818/?engineType=SCA&issue=ED38BB2EA4B2AB8E05B08409D36DDEC4"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "483",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getEmployeeProfile_BACKUP() in EditProfile.java might reveal system data or debugging information by calling printStackTrace() on line 192.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/483/?engineType=SCA&issue=A74A9A8AC3B36246B6F2AAA5700D66AC"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1294",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1294/?engineType=SCA&issue=D1EE3E3E679515ABBEC66C9A8682183B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1810",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in FindProfile.java might reveal system data or debugging information by calling printStackTrace() on line 84.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1810/?engineType=SCA&issue=E8F7B8415D904326CE5A76C29F60DD94"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1295",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1295/?engineType=SCA&issue=D1EE3E3E679515ABBEC66C9A8682183C"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1793",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in FindProfile.java might reveal system data or debugging information by calling printStackTrace() on line 89.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1793/?engineType=SCA&issue=DC355E945A033F5571B6641B8C9BE798"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1206",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method foundEmployee() in FindProfile.java ignores an exception on line 118, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1206/?engineType=SCA&issue=919D3DCDEEE1C50910AC7CE42DFA83A5"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "224",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function findEmployeeProfile() in FindProfile.java might reveal system data or debugging information by calling printStackTrace() on line 181.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/224/?engineType=SCA&issue=4808FFAF7D3634E85349E16A6E77465F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1639",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at FindProfile.java line 184 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1639/?engineType=SCA&issue=68CCD41D75FDFDEB656F110D33C98BEB"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "524",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function findEmployeeProfile() in FindProfile.java might reveal system data or debugging information by calling printStackTrace() on line 187.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/524/?engineType=SCA&issue=B227CC5643407A75A63DAD656CCB9DC6"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "318",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 98 of ListStaff.java, the method getAllEmployees() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\nIn this case Fortify could not determine that the source of the data is trusted.\n\n2. The data is used to dynamically construct a SQL query. \n\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.  \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one used in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can: \n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but when user-supplied data needs to be included, they create bind parameters, which are placeholders for data that is subsequently inserted. Bind parameters allow the program to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for the value of each of the bind parameters, without the risk of the data being interpreted as commands. \n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n        \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the command structure of the SQL statement, such as the addition of dynamic constraints in the WHERE clause. Do not use this requirement to justify concatenating user input into query strings. Prevent SQL injection attacks where user input must affect statement command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/318/?engineType=SCA&issue=6D819C0ADD8C403642DF5539DCD83183"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "20",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getAllEmployees() in ListStaff.java might reveal system data or debugging information by calling printStackTrace() on line 115.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/20/?engineType=SCA&issue=0A84CFB7DBE148BCA531CBABA1A42650"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1312",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ListStaff.java line 118 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1312/?engineType=SCA&issue=DE07BA20F02DE0CC255E1AB94B0DBE18"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "401",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getAllEmployees() in ListStaff.java might reveal system data or debugging information by calling printStackTrace() on line 121.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/401/?engineType=SCA&issue=8CFD6F3F11F1F76C099AC5ACA733778E"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "568",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 146 of ListStaff.java, the method getAllEmployees_BACKUP() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\nIn this case Fortify could not determine that the source of the data is trusted.\n\n2. The data is used to dynamically construct a SQL query. \n\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.  \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one used in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can: \n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but when user-supplied data needs to be included, they create bind parameters, which are placeholders for data that is subsequently inserted. Bind parameters allow the program to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for the value of each of the bind parameters, without the risk of the data being interpreted as commands. \n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n        \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the command structure of the SQL statement, such as the addition of dynamic constraints in the WHERE clause. Do not use this requirement to justify concatenating user input into query strings. Prevent SQL injection attacks where user input must affect statement command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/568/?engineType=SCA&issue=C254DB2A8D71FBAEA8349DB39FFCF7B4"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "636",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getAllEmployees_BACKUP() in ListStaff.java might reveal system data or debugging information by calling printStackTrace() on line 163.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/636/?engineType=SCA&issue=E39A9E190CF6A50B4EEB36F90B79EEEE"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1288",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ListStaff.java line 166 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1288/?engineType=SCA&issue=CF1706576AE627A199EABD745ADE9FFB"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "358",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getAllEmployees_BACKUP() in ListStaff.java might reveal system data or debugging information by calling printStackTrace() on line 169.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/358/?engineType=SCA&issue=7DEFC09894FCD4141B09E0898E429C4A"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1154",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1154/?engineType=SCA&issue=63AAE86AA63EFA0F04478DEC38636E37"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1845",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in Login.java might reveal system data or debugging information by calling printStackTrace() on line 91.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1845/?engineType=SCA&issue=FCD568019EB69AF39AA163B0918E3C7F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1155",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1155/?engineType=SCA&issue=63AAE86AA63EFA0F04478DEC38636E38"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1671",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in Login.java might reveal system data or debugging information by calling printStackTrace() on line 96.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1671/?engineType=SCA&issue=7865EB7B5AC47B29248E8C5025A008B0"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1673",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 148 of Login.java, the method login() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 690. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeQuery() in Login.java at line 148.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1673/?engineType=SCA&issue=7BB8EDC73CB58A98C025349FD6634C4B"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "73",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function login() in Login.java might reveal system data or debugging information by calling printStackTrace() on line 163.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/73/?engineType=SCA&issue=1A29C2FBFDD046228D0B134428F51657"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1145",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at Login.java line 166 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1145/?engineType=SCA&issue=5FAD05CA7E47A3D714C0E012ED7B41B0"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "581",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function login() in Login.java might reveal system data or debugging information by calling printStackTrace() on line 169.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/581/?engineType=SCA&issue=CAF560698F78E62F29FC0CF1F6955816"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "593",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getAllEmployees() in Login.java might reveal system data or debugging information by calling printStackTrace() on line 210.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/593/?engineType=SCA&issue=D2CBE98F96B851D86A2DBB88FA6101B5"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1257",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at Login.java line 213 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1257/?engineType=SCA&issue=B6451DDB15F48A240F5C0CD2D1AF8E5B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "253",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getAllEmployees() in Login.java might reveal system data or debugging information by calling printStackTrace() on line 216.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/253/?engineType=SCA&issue=578089EE6998BD5FC900CA94A6F4B9F9"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1223",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1223/?engineType=SCA&issue=A248F4EA4F9AE3C7A9F4065B29868BEA"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1628",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in Logout.java might reveal system data or debugging information by calling printStackTrace() on line 71.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1628/?engineType=SCA&issue=542A1F6930BFCE61860BFF17756539E2"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1224",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1224/?engineType=SCA&issue=A248F4EA4F9AE3C7A9F4065B29868BEB"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1691",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in Logout.java might reveal system data or debugging information by calling printStackTrace() on line 76.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1691/?engineType=SCA&issue=8E895F72A0E053B9527EBDA1C3B8F849"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1108",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1108/?engineType=SCA&issue=42D2933A94AA297DFBE1ECB83906AB85"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1618",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in RoleBasedAccessControl.java might reveal system data or debugging information by calling printStackTrace() on line 338.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1618/?engineType=SCA&issue=4C58672C07CE0B3888AD33A0CFF3D994"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1109",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1109/?engineType=SCA&issue=42D2933A94AA297DFBE1ECB83906AB86"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1095",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in RoleBasedAccessControl.java might reveal system data or debugging information by calling printStackTrace() on line 344.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1095/?engineType=SCA&issue=390CC7C47C215AE245AA7F18DFBC4FEA"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1110",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1110/?engineType=SCA&issue=42D2933A94AA297DFBE1ECB83906AB87"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1790",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in RoleBasedAccessControl.java might reveal system data or debugging information by calling printStackTrace() on line 351.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1790/?engineType=SCA&issue=D9E6C19FF94A89C45637A61042D0DCF4"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1111",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1111/?engineType=SCA&issue=42D2933A94AA297DFBE1ECB83906AB88"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1694",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in RoleBasedAccessControl.java might reveal system data or debugging information by calling printStackTrace() on line 358.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1694/?engineType=SCA&issue=92A45ABC6BEBD81AF05D783F150A01FD"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1080",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at RoleBasedAccessControl.java line 360 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1080/?engineType=SCA&issue=2CE624894A609924F7D4811F5D835C9F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1112",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1112/?engineType=SCA&issue=42D2933A94AA297DFBE1ECB83906AB89"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "586",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in RoleBasedAccessControl.java might reveal system data or debugging information by calling printStackTrace() on line 364.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/586/?engineType=SCA&issue=CD805D9C1A798A2C4DDC3D19F51A75BC"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1242",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1242/?engineType=SCA&issue=AF02319C982F88E8E439A4AF52D3A8A5"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1599",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest_BACKUP() in RoleBasedAccessControl.java might reveal system data or debugging information by calling printStackTrace() on line 432.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1599/?engineType=SCA&issue=3A34FB4634245DAC8FB32F4AEBABD802"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1243",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1243/?engineType=SCA&issue=AF02319C982F88E8E439A4AF52D3A8A6"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1323",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest_BACKUP() in RoleBasedAccessControl.java might reveal system data or debugging information by calling printStackTrace() on line 438.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1323/?engineType=SCA&issue=EAE355985C5A5A425BE5693E5B2DBE14"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1244",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1244/?engineType=SCA&issue=AF02319C982F88E8E439A4AF52D3A8A7"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1670",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest_BACKUP() in RoleBasedAccessControl.java might reveal system data or debugging information by calling printStackTrace() on line 445.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1670/?engineType=SCA&issue=784F6C1C531B36F70C18F0DABF1C7DCA"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1245",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1245/?engineType=SCA&issue=AF02319C982F88E8E439A4AF52D3A8A8"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1824",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest_BACKUP() in RoleBasedAccessControl.java might reveal system data or debugging information by calling printStackTrace() on line 452.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1824/?engineType=SCA&issue=F40DFD7D0A6A3177917B8D561E6CDCC9"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1077",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at RoleBasedAccessControl.java line 454 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1077/?engineType=SCA&issue=2A5B93F3990FF7D7E3B485F4F920B493"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1246",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1246/?engineType=SCA&issue=AF02319C982F88E8E439A4AF52D3A8A9"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "350",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest_BACKUP() in RoleBasedAccessControl.java might reveal system data or debugging information by calling printStackTrace() on line 458.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/350/?engineType=SCA&issue=7A60E2A9434AE4E21CEEE27DFBE160CF"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1045",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1045/?engineType=SCA&issue=15703B6CEB9E56DD9D02968AF88F30B3"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1805",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 125.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1805/?engineType=SCA&issue=E4EB3C3CC86A124D05029C605EAFE89D"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1046",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1046/?engineType=SCA&issue=15703B6CEB9E56DD9D02968AF88F30B4"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1698",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 130.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1698/?engineType=SCA&issue=9566BFFB8B5ACE187FB90DDCEEAC6C17"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1718",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 176 of UpdateProfile.java, the method changeEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 690. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeQuery() in UpdateProfile.java at line 176.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1718/?engineType=SCA&issue=A763A01AFCFA6EA768C7045BFF271909"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "4",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function changeEmployeeProfile() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 181.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/4/?engineType=SCA&issue=05B7CDDF96E7DFE39C750A2146B40FF2"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1584",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at UpdateProfile.java line 185 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1584/?engineType=SCA&issue=2D2BEE50E4F5B5AB5A6DF0D134FC0BE8"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "412",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function changeEmployeeProfile() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 188.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/412/?engineType=SCA&issue=91E288900A767B8B3AC64CB500252086"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "655",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 225 of UpdateProfile.java, the method changeEmployeeProfile_BACKUP() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\nIn this case Fortify could not determine that the source of the data is trusted.\n\n2. The data is used to dynamically construct a SQL query. \n\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.  \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one used in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can: \n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but when user-supplied data needs to be included, they create bind parameters, which are placeholders for data that is subsequently inserted. Bind parameters allow the program to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for the value of each of the bind parameters, without the risk of the data being interpreted as commands. \n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n        \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the command structure of the SQL statement, such as the addition of dynamic constraints in the WHERE clause. Do not use this requirement to justify concatenating user input into query strings. Prevent SQL injection attacks where user input must affect statement command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/655/?engineType=SCA&issue=EC5D2A161015138659834F595ABEC843"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "672",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function changeEmployeeProfile_BACKUP() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 230.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/672/?engineType=SCA&issue=F25983B958BB80B53993CD341D48CED5"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1732",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at UpdateProfile.java line 234 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1732/?engineType=SCA&issue=B726383BB69E9D0173CA12650859233E"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "41",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function changeEmployeeProfile_BACKUP() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 237.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/41/?engineType=SCA&issue=12A7BB006A4A13923C074307011194B8"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "428",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getNextUID() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 257.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/428/?engineType=SCA&issue=96C276DAF9BB2936A2F0FEB3DA40763A"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "98",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getNextUID() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 263.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/98/?engineType=SCA&issue=21A8BD721CDE61C4EE753B32957EA7C8"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1850",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 295 of UpdateProfile.java, the method createEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 690. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeUpdate() in UpdateProfile.java at line 295.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1850/?engineType=SCA&issue=FF21E2912F55A44C41F11B4A151F2DA6"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "400",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createEmployeeProfile() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 299.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/400/?engineType=SCA&issue=8C48CE78706C16033CB0373C60EBF66E"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "384",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 311 of UpdateProfile.java, the method createEmployeeProfile() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\nIn this case Fortify could not determine that the source of the data is trusted.\n\n2. The data is used to dynamically construct a SQL query. \n\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.  \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one used in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can: \n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but when user-supplied data needs to be included, they create bind parameters, which are placeholders for data that is subsequently inserted. Bind parameters allow the program to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for the value of each of the bind parameters, without the risk of the data being interpreted as commands. \n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n        \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the command structure of the SQL statement, such as the addition of dynamic constraints in the WHERE clause. Do not use this requirement to justify concatenating user input into query strings. Prevent SQL injection attacks where user input must affect statement command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/384/?engineType=SCA&issue=8670E2308E8A72DAAF573E8910CC3532"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "399",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createEmployeeProfile() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 315.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/399/?engineType=SCA&issue=8C48CE78706C16033CB0373C60EBF66D"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1597",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at UpdateProfile.java line 319 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1597/?engineType=SCA&issue=35E7C34DDD91F7453241A6A5F469F467"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "302",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createEmployeeProfile() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 321.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/302/?engineType=SCA&issue=65081290A748CDED3B8C7556ECE0F677"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1047",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method updateLessonStatus() in ViewProfile.java ignores an exception on line 105, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1047/?engineType=SCA&issue=159167DE098A6340587F852302B47EE0"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "615",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getEmployeeProfile() in ViewProfile.java might reveal system data or debugging information by calling printStackTrace() on line 160.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/615/?engineType=SCA&issue=DA6AE311765259AD2C01E2BC5A36B04E"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1729",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ViewProfile.java line 163 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1729/?engineType=SCA&issue=B46AC326DC1F30F6B03F47CD78124682"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "590",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getEmployeeProfile() in ViewProfile.java might reveal system data or debugging information by calling printStackTrace() on line 166.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/590/?engineType=SCA&issue=D1157449ECBB492F0958DEFDB268BDCE"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "705",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 192 of ViewProfile.java, the method getEmployeeProfile_BACKUP() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\nIn this case Fortify could not determine that the source of the data is trusted.\n\n2. The data is used to dynamically construct a SQL query. \n\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.  \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one used in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can: \n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but when user-supplied data needs to be included, they create bind parameters, which are placeholders for data that is subsequently inserted. Bind parameters allow the program to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for the value of each of the bind parameters, without the risk of the data being interpreted as commands. \n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n        \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the command structure of the SQL statement, such as the addition of dynamic constraints in the WHERE clause. Do not use this requirement to justify concatenating user input into query strings. Prevent SQL injection attacks where user input must affect statement command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/705/?engineType=SCA&issue=F88C48ED63341D13C54050C71557B4B7"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "299",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getEmployeeProfile_BACKUP() in ViewProfile.java might reveal system data or debugging information by calling printStackTrace() on line 220.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/299/?engineType=SCA&issue=62FF1026DD549BC6C832899FFA125D79"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1777",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ViewProfile.java line 223 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1777/?engineType=SCA&issue=D046B32B2A81C19087C1C3A499D9C743"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "140",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getEmployeeProfile_BACKUP() in ViewProfile.java might reveal system data or debugging information by calling printStackTrace() on line 226.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/140/?engineType=SCA&issue=2CBD712DEF62123F610AA40637D8643F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "618",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 98 of ListStaff.java, the method getAllEmployees() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\nIn this case Fortify could not determine that the source of the data is trusted.\n\n2. The data is used to dynamically construct a SQL query. \n\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.  \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one used in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can: \n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but when user-supplied data needs to be included, they create bind parameters, which are placeholders for data that is subsequently inserted. Bind parameters allow the program to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for the value of each of the bind parameters, without the risk of the data being interpreted as commands. \n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n        \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the command structure of the SQL statement, such as the addition of dynamic constraints in the WHERE clause. Do not use this requirement to justify concatenating user input into query strings. Prevent SQL injection attacks where user input must affect statement command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/618/?engineType=SCA&issue=DAF3388936B50051AC1AD8A12D19604C"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "155",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getAllEmployees() in ListStaff.java might reveal system data or debugging information by calling printStackTrace() on line 115.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/155/?engineType=SCA&issue=30BA3110C9C99222B1E03052176CC477"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1280",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ListStaff.java line 118 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1280/?engineType=SCA&issue=C9A7E69771B873400CAE5FA10ADEB634"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "696",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getAllEmployees() in ListStaff.java might reveal system data or debugging information by calling printStackTrace() on line 121.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/696/?engineType=SCA&issue=F816B701BF42B2D5F9B436A63C987F2E"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "540",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 146 of ListStaff.java, the method getAllEmployees_BACKUP() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\nIn this case Fortify could not determine that the source of the data is trusted.\n\n2. The data is used to dynamically construct a SQL query. \n\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.  \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one used in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can: \n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but when user-supplied data needs to be included, they create bind parameters, which are placeholders for data that is subsequently inserted. Bind parameters allow the program to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for the value of each of the bind parameters, without the risk of the data being interpreted as commands. \n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n        \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the command structure of the SQL statement, such as the addition of dynamic constraints in the WHERE clause. Do not use this requirement to justify concatenating user input into query strings. Prevent SQL injection attacks where user input must affect statement command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/540/?engineType=SCA&issue=B89C6E51C5549D303051AB4FFC873D4D"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "419",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getAllEmployees_BACKUP() in ListStaff.java might reveal system data or debugging information by calling printStackTrace() on line 163.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/419/?engineType=SCA&issue=9523285F3B0BA5E8E91C4E11492A65D6"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1159",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ListStaff.java line 166 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1159/?engineType=SCA&issue=689F5C908F1B8DAE49A26F85304E6B42"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "625",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getAllEmployees_BACKUP() in ListStaff.java might reveal system data or debugging information by calling printStackTrace() on line 169.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/625/?engineType=SCA&issue=DD063791D0680D5C9FF93F0599D7712B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1174",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1174/?engineType=SCA&issue=774AF09F9D9AF6B802DCB89E57DBCBA0"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1541",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in Login.java might reveal system data or debugging information by calling printStackTrace() on line 95.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1541/?engineType=SCA&issue=0399A1EC2D554723E3929010E2556E8C"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1175",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1175/?engineType=SCA&issue=774AF09F9D9AF6B802DCB89E57DBCBA1"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1537",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in Login.java might reveal system data or debugging information by calling printStackTrace() on line 100.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1537/?engineType=SCA&issue=0278C28651A419EA7D7D5DB87A1FB695"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1580",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 149 of Login.java, the method login() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeQuery() in Login.java at line 149.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1580/?engineType=SCA&issue=290AE35B54CA1238FC786348AEAD4C6D"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1674",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 149 of Login.java, the method login() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 690. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeQuery() in Login.java at line 149.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1674/?engineType=SCA&issue=7BDD81B455000B4713391796B65D396B"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "407",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function login() in Login.java might reveal system data or debugging information by calling printStackTrace() on line 162.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/407/?engineType=SCA&issue=8F523C6484F562CF74E05CFD919CB035"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1238",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at Login.java line 165 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1238/?engineType=SCA&issue=AC78C0ECCCAC39C732C6CDEF74BB1DEF"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "123",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function login() in Login.java might reveal system data or debugging information by calling printStackTrace() on line 168.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/123/?engineType=SCA&issue=2A0E5C8A8D2080682AAF42D79BC24679"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1781",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 191 of Login.java, the method login_BACKUP() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeQuery() in Login.java at line 191.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1781/?engineType=SCA&issue=D1EF88605230D7F736402E17D85C0DCE"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1848",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 191 of Login.java, the method login_BACKUP() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 690. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeQuery() in Login.java at line 191.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1848/?engineType=SCA&issue=FE929098BDBCED1E049EDA7D79C3BA13"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "666",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function login_BACKUP() in Login.java might reveal system data or debugging information by calling printStackTrace() on line 205.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/666/?engineType=SCA&issue=F0476D607FC7E88A788D476EA7DD55C0"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1179",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at Login.java line 208 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1179/?engineType=SCA&issue=7B4A94FE46C68B8E768B5669284DE4A0"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "241",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function login_BACKUP() in Login.java might reveal system data or debugging information by calling printStackTrace() on line 211.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/241/?engineType=SCA&issue=51602EFB444788618FD1F4B49284D96E"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "339",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getAllEmployees() in Login.java might reveal system data or debugging information by calling printStackTrace() on line 252.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/339/?engineType=SCA&issue=7506F4DA48F6F86385C9F1B201CA3849"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1281",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at Login.java line 255 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1281/?engineType=SCA&issue=CA272157D4AC84194B040102D6B38471"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "64",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getAllEmployees() in Login.java might reveal system data or debugging information by calling printStackTrace() on line 258.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/64/?engineType=SCA&issue=15A52F2B4AB4C9974369F7251DBFB23C"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1099",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method updateLessonStatus() in Login.java ignores an exception on line 297, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1099/?engineType=SCA&issue=3C981B07C32984A2B6FCC54FF7C3C879"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1299",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1299/?engineType=SCA&issue=D5A59CA2C8C13FB34B53721AE5C9B3D2"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1780",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in SQLInjection.java might reveal system data or debugging information by calling printStackTrace() on line 342.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1780/?engineType=SCA&issue=D13CCAFA47C75F58C2F9560901CDDCA9"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1300",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1300/?engineType=SCA&issue=D5A59CA2C8C13FB34B53721AE5C9B3D3"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1078",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in SQLInjection.java might reveal system data or debugging information by calling printStackTrace() on line 348.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1078/?engineType=SCA&issue=2C6E09CD1E289637CD671775BC99CADE"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1301",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1301/?engineType=SCA&issue=D5A59CA2C8C13FB34B53721AE5C9B3D4"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1735",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in SQLInjection.java might reveal system data or debugging information by calling printStackTrace() on line 355.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1735/?engineType=SCA&issue=B922D2C153F3FCD70F6920FBA8EF3AE2"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1302",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1302/?engineType=SCA&issue=D5A59CA2C8C13FB34B53721AE5C9B3D5"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1750",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in SQLInjection.java might reveal system data or debugging information by calling printStackTrace() on line 361.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1750/?engineType=SCA&issue=BF4701C7B0F1C825C65450C4897AB8B7"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1241",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at SQLInjection.java line 363 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1241/?engineType=SCA&issue=AE6FA423BE9EB9E79EE35D5495B7C7A5"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1303",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1303/?engineType=SCA&issue=D5A59CA2C8C13FB34B53721AE5C9B3D6"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "343",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in SQLInjection.java might reveal system data or debugging information by calling printStackTrace() on line 367.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/343/?engineType=SCA&issue=7608F03C2C01ADB55C091F61822D3207"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1614",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 118 of ViewProfile.java, the method getEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeQuery() in ViewProfile.java at line 118.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1614/?engineType=SCA&issue=4B75C779AA009A701775FF47139B7184"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "427",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getEmployeeProfile() in ViewProfile.java might reveal system data or debugging information by calling printStackTrace() on line 146.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/427/?engineType=SCA&issue=96AF7220DB83AEDCBF2DD2A39C114AF0"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1538",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ViewProfile.java line 149 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1538/?engineType=SCA&issue=0307B18A0460D1B5E9CBA4A6CB1641F1"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "141",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getEmployeeProfile() in ViewProfile.java might reveal system data or debugging information by calling printStackTrace() on line 152.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/141/?engineType=SCA&issue=2CDD488F9BB6E1BB829186146B4BA075"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1802",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 178 of ViewProfile.java, the method getEmployeeProfile_BACKUP() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeQuery() in ViewProfile.java at line 178.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1802/?engineType=SCA&issue=E38E0F334AA88DFD78863C64FC25B729"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "712",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getEmployeeProfile_BACKUP() in ViewProfile.java might reveal system data or debugging information by calling printStackTrace() on line 206.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/712/?engineType=SCA&issue=FC1E4C3D52D781762C0317B5BBFBAA8F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1573",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ViewProfile.java line 209 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1573/?engineType=SCA&issue=2377CF1BE73B3B048AA0A81997710936"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "91",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getEmployeeProfile_BACKUP() in ViewProfile.java might reveal system data or debugging information by calling printStackTrace() on line 212.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/91/?engineType=SCA&issue=1DF65556F09BBF74F1A33163DDB09405"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1730",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method updateLessonStatus() in ViewProfile.java ignores an exception on line 253, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1730/?engineType=SCA&issue=B5AE766122FA68FC09EFB2ED6960705F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1731",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method updateLessonStatus() in ViewProfile.java ignores an exception on line 268, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1731/?engineType=SCA&issue=B5AE766122FA68FC09EFB2ED69607060"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1130",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at SilentTransactions.java line 115 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1130/?engineType=SCA&issue=4E00CFEBE4072CA999C97E68292B7D0E"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "7",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in SilentTransactions.java might reveal system data or debugging information by calling printStackTrace() on line 117.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/7/?engineType=SCA&issue=067B838962D6B799229870C93909DAA7"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "624",
          "shortDescription" : {
            "text" : "Race Condition: Static Database Connection"
          },
          "fullDescription" : {
            "text" : "The class SoapRequest stores a database connection in a static field, which creates a race condition when the connection is shared between threads.\n\n\n"
          },
          "help" : {
            "text" : "A transactional resource object such as database connection can only be associated with one transaction at a time. For this reason, a connection should not be shared between threads and should not be stored in a static field. See Section 4.2.3 of the J2EE Specification for more details.\n\nExample 1: \n\n\npublic class ConnectionManager {\n\nprivate static Connection conn = initDbConn();\n...\n}\n\n\nRather than storing the database connection in a static field, use a connection pool to cache connection objects. Most modern J2EE and Servlet containers provide built-in connection pooling facilities.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/624/?engineType=SCA&issue=DCFF36250D3F64C32E667FEFA44D89EB"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "5",
          "shortDescription" : {
            "text" : "Unchecked Return Value"
          },
          "fullDescription" : {
            "text" : "The method getHints() in SoapRequest.java ignores the value returned by replaceAll() on line 140, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "It is not uncommon for Java programmers to misunderstand read() and related methods that are part of many java.io classes. Most errors and unusual events in Java result in an exception being thrown. (This is one of the advantages that Java has over languages like C: Exceptions make it easier for programmers to think about what can go wrong.) But the stream and reader classes do not consider it unusual or exceptional if only a small amount of data becomes available. These classes simply add the small amount of data to the return buffer, and set the return value to the number of bytes or characters read. There is no guarantee that the amount of data returned is equal to the amount of data requested.\n\nThis behavior makes it important for programmers to examine the return value from read() and other IO methods to ensure that they receive the amount of data they expect.\n\n\n\nExample: The following code loops through a set of users, reading a private data file for each user. The programmer assumes that the files are always exactly 1 kilobyte in size and therefore ignores the return value from read(). If an attacker can create a smaller file, the program will recycle the remainder of the data from the previous user and handle it as though it belongs to the attacker.\n\n\nFileInputStream fis;\nbyte[] byteArray = new byte[1024];\nfor (Iterator i=users.iterator(); i.hasNext();) {\n    String userName = (String) i.next();\n    String pFileName = PFILE_ROOT + \"/\" + userName;\n    FileInputStream fis = new FileInputStream(pFileName);   \n    fis.read(byteArray); // the file is always 1k bytes\n    fis.close();\n    processPFile(userName, byteArray);\n}\n\n\n\n\n  FileInputStream fis;\n  byte[] byteArray = new byte[1024];\n  for (Iterator i=users.iterator(); i.hasNext();) {\n    String userName = (String) i.next();\n    String pFileName = PFILE_ROOT + \"/\" + userName;\n    fis = new FileInputStream(pFileName);\n    int bRead = 0;\n    while (bRead &lt; 1024) {\n        int rd = fis.read(byteArray, bRead, 1024 - bRead); \n        if (rd == -1) {\n          throw new IOException(\"file is unusually small\");\n        }\n        bRead += rd;\n    }\n    // could add check to see if file is too large here\n    fis.close();\n    processPFile(userName, byteArray);\n  }\n\n\nNote: Because the fix for this problem is relatively complicated, you might be tempted to use a simpler approach, such as checking the size of the file before you begin reading. Such an approach would render the application vulnerable to a file system race condition, whereby an attacker could replace a well-formed file with a malicious file between the file size check and the call to read data from the file. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/5/?engineType=SCA&issue=064C4C93451D67B8E1CE35240CA83095"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1319",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method viewWsdl() in SoapRequest.java ignores an exception on line 265, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1319/?engineType=SCA&issue=E634F9908A591794FB74A17FCF57E637"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1356",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at SoapRequest.java line 270 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1356/?engineType=SCA&issue=FF9C422AE5C85400EE3E51EA7FEE2716"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "663",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function viewWsdl() in SoapRequest.java might reveal system data or debugging information by calling printStackTrace() on line 273.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/663/?engineType=SCA&issue=EE0D0F6E41CCBAFA3ACD09D5E3B4810A"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1277",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method determineType() in SoapRequest.java ignores an exception on line 322, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1277/?engineType=SCA&issue=C68EA40BEECE32111F72F73D44E84514"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1156",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at SoapRequest.java line 327 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1156/?engineType=SCA&issue=654431F026EFD8AFD155E91265356C4F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "55",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function determineType() in SoapRequest.java might reveal system data or debugging information by calling printStackTrace() on line 330.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/55/?engineType=SCA&issue=1483B63B83BB6AA4D820DD9274638C54"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1221",
          "shortDescription" : {
            "text" : "Unreleased Resource: Database"
          },
          "fullDescription" : {
            "text" : "The function getResults() in SoapRequest.java sometimes fails to release a system resource allocated by <a href=\"event:file=JavaSource/org/owasp/webgoat/session/DatabaseUtilities.java&amp;lineNo=82\" rel=\"nofollow\">makeConnection()</a> on line 412.\n\n\n"
          },
          "help" : {
            "text" : "The program can potentially fail to release a system resource.\n\n    In this case, there are program paths on which the resource allocated in SoapRequest.java at line 412 is not released.\n\n\nResource leaks have at least two common causes:\n\n- Error conditions and other exceptional circumstances.\n\n- Confusion over which part of the program is responsible for releasing the resource.\n\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.\n\nExample 1: The following method never closes the file handle it opens. The finalize() method for FileInputStream eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n\n\nprivate void processFile(String fName) throws FileNotFoundException, IOException\n{\n  FileInputStream fis = new FileInputStream(fName);\n  int sz;\n  byte[] byteArray = new byte[BLOCK_SIZE];\n  while ((sz = fis.read(byteArray)) != -1) {\n    processBytes(byteArray, sz);\n  }\n}\n\n\nExample 2: Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.\n\n\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(CXN_SQL);\n  harvestResults(rs);\n  stmt.close();\n\n\n\n1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to \"bursty\" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.\n\nFinally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang. \n\n2. Release resources in a finally block. The code for Example 2 should be rewritten as follows:\n\n\n  public void execCxnSql(Connection conn) {\n    Statement stmt;\n    try {\n      stmt = conn.createStatement();\n      ResultSet rs = stmt.executeQuery(CXN_SQL);\n      ...\n    }\n    finally {\n      if (stmt != null) {\n        safeClose(stmt);\n      }\n    }\n}\n\npublic static void safeClose(Statement stmt) {\n  if (stmt != null) {\n    try {\n      stmt.close();\n    } catch (SQLException e) {\n      log(e);\n    }\n  }\n}\n\n\nThis solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. \n\nAlso, the execCxnSql method does not initialize the stmt object to null. Instead, it checks to ensure that stmt is not null before calling safeClose(). Without the null check, the Java compiler reports that stmt might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  stmt is initialized to null in a more complex method, cases in which stmt is used without being initialized will not be detected by the compiler. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1221/?engineType=SCA&issue=9E04332C771DC6643C26B2FD61F35F93"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1028",
          "shortDescription" : {
            "text" : "Unreleased Resource: Database"
          },
          "fullDescription" : {
            "text" : "The function getResults() in SoapRequest.java sometimes fails to release a system resource allocated by <a href=\"event:file=JavaSource/org/owasp/webgoat/session/DatabaseUtilities.java&amp;lineNo=82\" rel=\"nofollow\">makeConnection()</a> on line 412.\n\n\n"
          },
          "help" : {
            "text" : "The program can potentially fail to release a system resource.\n\n    In this case, there are program paths on which the resource allocated in SoapRequest.java at line 412 is not released.\n\n\nResource leaks have at least two common causes:\n\n- Error conditions and other exceptional circumstances.\n\n- Confusion over which part of the program is responsible for releasing the resource.\n\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.\n\nExample 1: The following method never closes the file handle it opens. The finalize() method for FileInputStream eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n\n\nprivate void processFile(String fName) throws FileNotFoundException, IOException\n{\n  FileInputStream fis = new FileInputStream(fName);\n  int sz;\n  byte[] byteArray = new byte[BLOCK_SIZE];\n  while ((sz = fis.read(byteArray)) != -1) {\n    processBytes(byteArray, sz);\n  }\n}\n\n\nExample 2: Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.\n\n\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(CXN_SQL);\n  harvestResults(rs);\n  stmt.close();\n\n\n\n1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to \"bursty\" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.\n\nFinally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang. \n\n2. Release resources in a finally block. The code for Example 2 should be rewritten as follows:\n\n\n  public void execCxnSql(Connection conn) {\n    Statement stmt;\n    try {\n      stmt = conn.createStatement();\n      ResultSet rs = stmt.executeQuery(CXN_SQL);\n      ...\n    }\n    finally {\n      if (stmt != null) {\n        safeClose(stmt);\n      }\n    }\n}\n\npublic static void safeClose(Statement stmt) {\n  if (stmt != null) {\n    try {\n      stmt.close();\n    } catch (SQLException e) {\n      log(e);\n    }\n  }\n}\n\n\nThis solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. \n\nAlso, the execCxnSql method does not initialize the stmt object to null. Instead, it checks to ensure that stmt is not null before calling safeClose(). Without the null check, the Java compiler reports that stmt might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  stmt is initialized to null in a more complex method, cases in which stmt is used without being initialized will not be detected by the compiler. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1028/?engineType=SCA&issue=04ED8DE06DF66F9C36907FBF82DEB835"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1096",
          "shortDescription" : {
            "text" : "Unreleased Resource: Database"
          },
          "fullDescription" : {
            "text" : "The function getResults() in SoapRequest.java sometimes fails to release a system resource allocated by <a href=\"event:file=JavaSource/org/owasp/webgoat/session/DatabaseUtilities.java&amp;lineNo=82\" rel=\"nofollow\">makeConnection()</a> on line 412.\n\n\n"
          },
          "help" : {
            "text" : "The program can potentially fail to release a system resource.\n\n    In this case, there are program paths on which the resource allocated in SoapRequest.java at line 412 is not released.\n\n\nResource leaks have at least two common causes:\n\n- Error conditions and other exceptional circumstances.\n\n- Confusion over which part of the program is responsible for releasing the resource.\n\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.\n\nExample 1: The following method never closes the file handle it opens. The finalize() method for FileInputStream eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n\n\nprivate void processFile(String fName) throws FileNotFoundException, IOException\n{\n  FileInputStream fis = new FileInputStream(fName);\n  int sz;\n  byte[] byteArray = new byte[BLOCK_SIZE];\n  while ((sz = fis.read(byteArray)) != -1) {\n    processBytes(byteArray, sz);\n  }\n}\n\n\nExample 2: Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.\n\n\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(CXN_SQL);\n  harvestResults(rs);\n  stmt.close();\n\n\n\n1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to \"bursty\" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.\n\nFinally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang. \n\n2. Release resources in a finally block. The code for Example 2 should be rewritten as follows:\n\n\n  public void execCxnSql(Connection conn) {\n    Statement stmt;\n    try {\n      stmt = conn.createStatement();\n      ResultSet rs = stmt.executeQuery(CXN_SQL);\n      ...\n    }\n    finally {\n      if (stmt != null) {\n        safeClose(stmt);\n      }\n    }\n}\n\npublic static void safeClose(Statement stmt) {\n  if (stmt != null) {\n    try {\n      stmt.close();\n    } catch (SQLException e) {\n      log(e);\n    }\n  }\n}\n\n\nThis solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. \n\nAlso, the execCxnSql method does not initialize the stmt object to null. Instead, it checks to ensure that stmt is not null before calling safeClose(). Without the null check, the Java compiler reports that stmt might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  stmt is initialized to null in a more complex method, cases in which stmt is used without being initialized will not be detected by the compiler. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1096/?engineType=SCA&issue=3A61CC50D67E795CD5D9C72962426B3D"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "126",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method getResults() in SoapRequest.java ignores an exception on line 428, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/126/?engineType=SCA&issue=2B0FBB29B2ED4A753A1DF572AB283458"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "127",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method getResults() in SoapRequest.java ignores an exception on line 431, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/127/?engineType=SCA&issue=2B0FBB29B2ED4A753A1DF572AB283459"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "595",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at SoapRequest.java line 431 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/595/?engineType=SCA&issue=D402C68F2F35B97004E831047079827B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1817",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 130 of SqlNumericInjection.java, the method injectableQuery() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeQuery() in SqlNumericInjection.java at line 130.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1817/?engineType=SCA&issue=ECD88BA59A13D27920D89B9150B55964"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1066",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at SqlNumericInjection.java line 159 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1066/?engineType=SCA&issue=20177ECB226CB47AB96ECB5624B41718"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "424",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function injectableQuery() in SqlNumericInjection.java might reveal system data or debugging information by calling printStackTrace() on line 162.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/424/?engineType=SCA&issue=95DE204D0F2739B96963DADDC6173ABA"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1040",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at SqlNumericInjection.java line 239 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1040/?engineType=SCA&issue=0F0FF924977DE9C7C73A2AF3FDA77CA2"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "247",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function parameterizedQuery() in SqlNumericInjection.java might reveal system data or debugging information by calling printStackTrace() on line 242.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/247/?engineType=SCA&issue=53B038E0AE5B68AA1F4A9E8507FB4AAC"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "233",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getStations() in SqlNumericInjection.java might reveal system data or debugging information by calling printStackTrace() on line 323.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/233/?engineType=SCA&issue=4C653A33A0D6848A352377AB4CBAB1AD"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1103",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at SqlNumericInjection.java line 398 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1103/?engineType=SCA&issue=3DFB1C5A8A92E662E77EA3A291DE2B4B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1158",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1158/?engineType=SCA&issue=6794198C77BE950520AE92E98DDE52CE"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1216",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in SqlNumericInjection.java might reveal system data or debugging information by calling println() on line 400.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1216/?engineType=SCA&issue=99A79585931C6987EC2A75B20966728B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "557",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in SqlNumericInjection.java might reveal system data or debugging information by calling printStackTrace() on line 401.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/557/?engineType=SCA&issue=BCA2815261DDE9801EF85E500931CC3B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1687",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 112 of SqlStringInjection.java, the method injectableQuery() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeQuery() in SqlStringInjection.java at line 112.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1687/?engineType=SCA&issue=8A18E35BD3EFE32534AC9384A5BE6956"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1198",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at SqlStringInjection.java line 149 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1198/?engineType=SCA&issue=86B323E8F3792762476EEE992CC99816"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "357",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function injectableQuery() in SqlStringInjection.java might reveal system data or debugging information by calling printStackTrace() on line 152.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/357/?engineType=SCA&issue=7D6003CBCB0DCF48E600ED712C83AABF"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1135",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at SqlStringInjection.java line 219 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1135/?engineType=SCA&issue=534D5EF2946C55543E83552AB2236A87"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "332",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function parameterizedQuery() in SqlStringInjection.java might reveal system data or debugging information by calling printStackTrace() on line 222.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/332/?engineType=SCA&issue=72460759C5B6E978E5FE283EAEEC81F3"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1199",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at SqlStringInjection.java line 314 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1199/?engineType=SCA&issue=882B6B78EAA59D4913A171F38EBEDFD7"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1322",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1322/?engineType=SCA&issue=E997F562F8DE6D557D70AEE555AAC79C"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1325",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in SqlStringInjection.java might reveal system data or debugging information by calling println() on line 316.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1325/?engineType=SCA&issue=ED66ED89B95DC2286E131198E0F14E9C"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "579",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in SqlStringInjection.java might reveal system data or debugging information by calling printStackTrace() on line 317.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/579/?engineType=SCA&issue=C96F82E5F189CA5A0B7AAB52DD930CAB"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1170",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at StoredXss.java line 110 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1170/?engineType=SCA&issue=75A884C9E8D537F1E385E0A32F9CCF44"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1320",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at StoredXss.java line 271 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1320/?engineType=SCA&issue=E655FCB6180BE4E1728D9E4C4269B663"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "194",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function makeCurrent() in StoredXss.java might reveal system data or debugging information by calling printStackTrace() on line 274.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/194/?engineType=SCA&issue=3BF075B4B198A249D1BAC3FEB3984E40"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1324",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 343 of StoredXss.java, the method makeList() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\nIn this case Fortify could not determine that the source of the data is trusted.\n\n2. The data is used to dynamically construct a SQL query. \n\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.  \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one used in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can: \n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but when user-supplied data needs to be included, they create bind parameters, which are placeholders for data that is subsequently inserted. Bind parameters allow the program to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for the value of each of the bind parameters, without the risk of the data being interpreted as commands. \n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n        \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the command structure of the SQL statement, such as the addition of dynamic constraints in the WHERE clause. Do not use this requirement to justify concatenating user input into query strings. Prevent SQL injection attacks where user input must affect statement command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1324/?engineType=SCA&issue=EBF2B90A529B6D5F6E3A143881FF46FC"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1276",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at StoredXss.java line 361 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1276/?engineType=SCA&issue=C5C5AC1CBC1408C22FA356532AB2E6E6"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1577",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 103 of ThreadSafetyProblem.java, the method createContent() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeQuery() in ThreadSafetyProblem.java at line 103.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1577/?engineType=SCA&issue=2636332ACE18588AF8D2FAAD06436683"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1153",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ThreadSafetyProblem.java line 125 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1153/?engineType=SCA&issue=62C7FE330BAB70CA63BDA5F86313AAB4"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "543",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in ThreadSafetyProblem.java might reveal system data or debugging information by calling printStackTrace() on line 128.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/543/?engineType=SCA&issue=B9BF1DFE73632286CCBD9DB579BF1F6C"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1143",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ThreadSafetyProblem.java line 214 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1143/?engineType=SCA&issue=5D8297B8270664CD91F31526192B8A95"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1053",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in ThreadSafetyProblem.java might reveal system data or debugging information by calling println() on line 216.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1053/?engineType=SCA&issue=19CF0F630868DEF6CFF0C696A02B48A3"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1176",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1176/?engineType=SCA&issue=777AE55746C2DC9DD86A75F09986D338"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "124",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in ThreadSafetyProblem.java might reveal system data or debugging information by calling printStackTrace() on line 217.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/124/?engineType=SCA&issue=2AB41AE8E1843F47BA77436620AA16AB"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1609",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method createContent() in TraceXSS.java sends unvalidated data to a web browser on line 137, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 690. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at Input() in TraceXSS.java at line 137.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1609/?engineType=SCA&issue=44FDD9D3ECD8BB124A2D2AE3DB505BFB"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1804",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method createContent() in TraceXSS.java sends unvalidated data to a web browser on line 151, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 690. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at Input() in TraceXSS.java at line 151.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1804/?engineType=SCA&issue=E4C288AABC832D50D5EAD02C06A5B684"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1650",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method createContent() in TraceXSS.java sends unvalidated data to a web browser on line 166, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 690. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at Input() in TraceXSS.java at line 166.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1650/?engineType=SCA&issue=6D839FD4FF3C7C9D318E33593549D73A"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1825",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method createContent() in TraceXSS.java sends unvalidated data to a web browser on line 201, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at Input() in TraceXSS.java at line 201.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1825/?engineType=SCA&issue=F4234FFE417E22CE535656E88D5CCA53"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1676",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method createContent() in TraceXSS.java sends unvalidated data to a web browser on line 207, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at Input() in TraceXSS.java at line 207.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1676/?engineType=SCA&issue=7DCA70B4BA1061E14FB34018488AD663"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1196",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at TraceXSS.java line 220 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1196/?engineType=SCA&issue=865AB8CA7625D46FD1BE10801C0E6F9B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "499",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in TraceXSS.java might reveal system data or debugging information by calling printStackTrace() on line 223.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/499/?engineType=SCA&issue=ABD8BC13CE60A8E57DCFA6DABD7C58FD"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1030",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at UncheckedEmail.java line 193 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1030/?engineType=SCA&issue=074F613B1C85894BEC463C4BC282021B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "292",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in UncheckedEmail.java might reveal system data or debugging information by calling printStackTrace() on line 196.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/292/?engineType=SCA&issue=5FEF0BF8E504E8EEB64A4B64E33D7339"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "690",
          "shortDescription" : {
            "text" : "Race Condition: Static Database Connection"
          },
          "fullDescription" : {
            "text" : "The class WSDLScanning stores a database connection in a static field, which creates a race condition when the connection is shared between threads.\n\n\n"
          },
          "help" : {
            "text" : "A transactional resource object such as database connection can only be associated with one transaction at a time. For this reason, a connection should not be shared between threads and should not be stored in a static field. See Section 4.2.3 of the J2EE Specification for more details.\n\nExample 1: \n\n\npublic class ConnectionManager {\n\nprivate static Connection conn = initDbConn();\n...\n}\n\n\nRather than storing the database connection in a static field, use a connection pool to cache connection objects. Most modern J2EE and Servlet containers provide built-in connection pooling facilities.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/690/?engineType=SCA&issue=F442CD3145F2B123E11DAE0F8EC32D15"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "580",
          "shortDescription" : {
            "text" : "Password Management: Hardcoded Password"
          },
          "fullDescription" : {
            "text" : "Hardcoded passwords can compromise system security in a way that cannot be easily remedied.\n\n\n"
          },
          "help" : {
            "text" : "It is never a good idea to hardcode a password. Not only does hardcoding a password allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. Once the code is in production, the password cannot be changed without patching the software. If the account protected by the password is compromised, the owners of the system will be forced to choose between security and availability.\n\n\nExample: The following code uses a hardcoded password to connect to a database:\n\n\n...\nDriverManager.getConnection(url, \"scott\", \"tiger\");\n...\n\n\nThis code will run successfully, but anyone who has access to it will have access to the password. Once the program has shipped, there is no going back from the database user \"scott\" with a password of \"tiger\" unless the program is patched. A devious employee with access to this information can use it to break into the system. Even worse, if attackers have access to the bytecode for application, they can use the javap -c command to access the disassembled code, which will contain the values of the passwords used. The result of this operation might look something like the following for the example above:\n\n\njavap -c ConnMngr.class\n\n22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql\n24: ldc   #38; //String scott\n26: ldc   #17; //String tiger\n\n\n\nPasswords should never be hardcoded and should generally be obfuscated and managed in an external source. Storing passwords in plaintext anywhere on the system allows anyone with sufficient permissions to read and potentially misuse the password.\n\nSome third party products claim the ability to manage passwords in a more secure way. For example, WebSphere Application Server 4.x uses a simple XOR encryption algorithm for obfuscating values, but be skeptical about such facilities. WebSphere and other application servers offer outdated and relatively weak encryption mechanisms that are insufficient for security-sensitive environments. For a secure solution, the only viable option available today appears to be a proprietary one that you create.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/580/?engineType=SCA&issue=C9F66C7212252423D2CBA090538D5087"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "451",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function accessWGService() in WSDLScanning.java might reveal system data or debugging information by calling printStackTrace() on line 155.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/451/?engineType=SCA&issue=9BCB204A4306E1E6CB007BE7A2EE0469"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "450",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function accessWGService() in WSDLScanning.java might reveal system data or debugging information by calling printStackTrace() on line 159.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/450/?engineType=SCA&issue=9BCB204A4306E1E6CB007BE7A2EE0468"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "620",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at WSDLScanning.java line 161 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/620/?engineType=SCA&issue=DB817FE1BE7E92EF836558E4363C204B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "449",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function accessWGService() in WSDLScanning.java might reveal system data or debugging information by calling printStackTrace() on line 163.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/449/?engineType=SCA&issue=9BCB204A4306E1E6CB007BE7A2EE0467"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1171",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method createContent() in WSDLScanning.java ignores an exception on line 232, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1171/?engineType=SCA&issue=764375566B11856609060FAE78DD1113"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1235",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at WSDLScanning.java line 232 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1235/?engineType=SCA&issue=AB64E4CAE731235ED984445C420778D4"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1236",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at WSDLScanning.java line 261 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1236/?engineType=SCA&issue=AB64E4CAE731235ED984445C420778D5"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "22",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in WSDLScanning.java might reveal system data or debugging information by calling printStackTrace() on line 264.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/22/?engineType=SCA&issue=0C519A9DA8C7ECBC38BFA1BFE8776F64"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1049",
          "shortDescription" : {
            "text" : "Unreleased Resource: Database"
          },
          "fullDescription" : {
            "text" : "The function getResults() in WSDLScanning.java sometimes fails to release a system resource allocated by <a href=\"event:file=JavaSource/org/owasp/webgoat/session/DatabaseUtilities.java&amp;lineNo=82\" rel=\"nofollow\">makeConnection()</a> on line 274.\n\n\n"
          },
          "help" : {
            "text" : "The program can potentially fail to release a system resource.\n\n    In this case, there are program paths on which the resource allocated in WSDLScanning.java at line 274 is not released.\n\n\nResource leaks have at least two common causes:\n\n- Error conditions and other exceptional circumstances.\n\n- Confusion over which part of the program is responsible for releasing the resource.\n\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.\n\nExample 1: The following method never closes the file handle it opens. The finalize() method for FileInputStream eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n\n\nprivate void processFile(String fName) throws FileNotFoundException, IOException\n{\n  FileInputStream fis = new FileInputStream(fName);\n  int sz;\n  byte[] byteArray = new byte[BLOCK_SIZE];\n  while ((sz = fis.read(byteArray)) != -1) {\n    processBytes(byteArray, sz);\n  }\n}\n\n\nExample 2: Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.\n\n\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(CXN_SQL);\n  harvestResults(rs);\n  stmt.close();\n\n\n\n1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to \"bursty\" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.\n\nFinally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang. \n\n2. Release resources in a finally block. The code for Example 2 should be rewritten as follows:\n\n\n  public void execCxnSql(Connection conn) {\n    Statement stmt;\n    try {\n      stmt = conn.createStatement();\n      ResultSet rs = stmt.executeQuery(CXN_SQL);\n      ...\n    }\n    finally {\n      if (stmt != null) {\n        safeClose(stmt);\n      }\n    }\n}\n\npublic static void safeClose(Statement stmt) {\n  if (stmt != null) {\n    try {\n      stmt.close();\n    } catch (SQLException e) {\n      log(e);\n    }\n  }\n}\n\n\nThis solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. \n\nAlso, the execCxnSql method does not initialize the stmt object to null. Instead, it checks to ensure that stmt is not null before calling safeClose(). Without the null check, the Java compiler reports that stmt might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  stmt is initialized to null in a more complex method, cases in which stmt is used without being initialized will not be detected by the compiler. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1049/?engineType=SCA&issue=1633DEC41E18BD7F8A60AFD79EFA55AD"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1352",
          "shortDescription" : {
            "text" : "Unreleased Resource: Database"
          },
          "fullDescription" : {
            "text" : "The function getResults() in WSDLScanning.java sometimes fails to release a system resource allocated by <a href=\"event:file=JavaSource/org/owasp/webgoat/session/DatabaseUtilities.java&amp;lineNo=82\" rel=\"nofollow\">makeConnection()</a> on line 274.\n\n\n"
          },
          "help" : {
            "text" : "The program can potentially fail to release a system resource.\n\n    In this case, there are program paths on which the resource allocated in WSDLScanning.java at line 274 is not released.\n\n\nResource leaks have at least two common causes:\n\n- Error conditions and other exceptional circumstances.\n\n- Confusion over which part of the program is responsible for releasing the resource.\n\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.\n\nExample 1: The following method never closes the file handle it opens. The finalize() method for FileInputStream eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n\n\nprivate void processFile(String fName) throws FileNotFoundException, IOException\n{\n  FileInputStream fis = new FileInputStream(fName);\n  int sz;\n  byte[] byteArray = new byte[BLOCK_SIZE];\n  while ((sz = fis.read(byteArray)) != -1) {\n    processBytes(byteArray, sz);\n  }\n}\n\n\nExample 2: Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.\n\n\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(CXN_SQL);\n  harvestResults(rs);\n  stmt.close();\n\n\n\n1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to \"bursty\" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.\n\nFinally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang. \n\n2. Release resources in a finally block. The code for Example 2 should be rewritten as follows:\n\n\n  public void execCxnSql(Connection conn) {\n    Statement stmt;\n    try {\n      stmt = conn.createStatement();\n      ResultSet rs = stmt.executeQuery(CXN_SQL);\n      ...\n    }\n    finally {\n      if (stmt != null) {\n        safeClose(stmt);\n      }\n    }\n}\n\npublic static void safeClose(Statement stmt) {\n  if (stmt != null) {\n    try {\n      stmt.close();\n    } catch (SQLException e) {\n      log(e);\n    }\n  }\n}\n\n\nThis solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. \n\nAlso, the execCxnSql method does not initialize the stmt object to null. Instead, it checks to ensure that stmt is not null before calling safeClose(). Without the null check, the Java compiler reports that stmt might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  stmt is initialized to null in a more complex method, cases in which stmt is used without being initialized will not be detected by the compiler. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1352/?engineType=SCA&issue=FEA45A3D84A912105A0DEA1F42093C48"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1054",
          "shortDescription" : {
            "text" : "Unreleased Resource: Database"
          },
          "fullDescription" : {
            "text" : "The function getResults() in WSDLScanning.java sometimes fails to release a system resource allocated by <a href=\"event:file=JavaSource/org/owasp/webgoat/session/DatabaseUtilities.java&amp;lineNo=82\" rel=\"nofollow\">makeConnection()</a> on line 274.\n\n\n"
          },
          "help" : {
            "text" : "The program can potentially fail to release a system resource.\n\n    In this case, there are program paths on which the resource allocated in WSDLScanning.java at line 274 is not released.\n\n\nResource leaks have at least two common causes:\n\n- Error conditions and other exceptional circumstances.\n\n- Confusion over which part of the program is responsible for releasing the resource.\n\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.\n\nExample 1: The following method never closes the file handle it opens. The finalize() method for FileInputStream eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n\n\nprivate void processFile(String fName) throws FileNotFoundException, IOException\n{\n  FileInputStream fis = new FileInputStream(fName);\n  int sz;\n  byte[] byteArray = new byte[BLOCK_SIZE];\n  while ((sz = fis.read(byteArray)) != -1) {\n    processBytes(byteArray, sz);\n  }\n}\n\n\nExample 2: Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.\n\n\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(CXN_SQL);\n  harvestResults(rs);\n  stmt.close();\n\n\n\n1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to \"bursty\" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.\n\nFinally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang. \n\n2. Release resources in a finally block. The code for Example 2 should be rewritten as follows:\n\n\n  public void execCxnSql(Connection conn) {\n    Statement stmt;\n    try {\n      stmt = conn.createStatement();\n      ResultSet rs = stmt.executeQuery(CXN_SQL);\n      ...\n    }\n    finally {\n      if (stmt != null) {\n        safeClose(stmt);\n      }\n    }\n}\n\npublic static void safeClose(Statement stmt) {\n  if (stmt != null) {\n    try {\n      stmt.close();\n    } catch (SQLException e) {\n      log(e);\n    }\n  }\n}\n\n\nThis solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. \n\nAlso, the execCxnSql method does not initialize the stmt object to null. Instead, it checks to ensure that stmt is not null before calling safeClose(). Without the null check, the Java compiler reports that stmt might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  stmt is initialized to null in a more complex method, cases in which stmt is used without being initialized will not be detected by the compiler. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1054/?engineType=SCA&issue=1A190EDA4C62457810D8ED1385AAAC6C"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "327",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method getResults() in WSDLScanning.java ignores an exception on line 290, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/327/?engineType=SCA&issue=711C492D0F8D5CD85496BA28D71F1133"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "328",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method getResults() in WSDLScanning.java ignores an exception on line 293, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/328/?engineType=SCA&issue=711C492D0F8D5CD85496BA28D71F1134"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "706",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at WSDLScanning.java line 293 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/706/?engineType=SCA&issue=F8FCFA39D7E71A2FD62A3B00FBDC8C15"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1137",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Throws"
          },
          "fullDescription" : {
            "text" : "The method checkCookie() in WeakAuthenticationCookie.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
          },
          "help" : {
            "text" : "Declaring a method to throw Exception or Throwable makes it difficult for callers to do good error handling and error recovery. Java's exception mechanism is set up to make it easy for callers to anticipate what can go wrong and write code to handle each specific exceptional circumstance. Declaring that a method throws a generic form of exception defeats this system.\n\nExample: The following method throws three types of exceptions.\n\n\npublic void doExchange()\n  throws IOException, InvocationTargetException,\n         SQLException {\n  ...\n}\n\n\n\nWhile it might seem tidier to write \n\n\npublic void doExchange()\n  throws Exception {\n  ...\n}\n\n\ndoing so hampers the caller's ability to understand and handle the exceptions that occur. Further, if a later revision of doExchange() introduces a new type of exception that should be treated differently than previous exceptions, there is no easy way to enforce this requirement.\n\nDo not declare methods to throw Exception or Throwable. If the exceptions thrown by a method are not recoverable or should not generally be caught by the caller, consider throwing unchecked exceptions rather than checked exceptions. This can be accomplished by implementing exception classes that extend RuntimeException or Error instead of Exception, or add a try/catch wrapper in your method to convert checked exceptions to unchecked exceptions.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1137/?engineType=SCA&issue=543877893EBD02DFE17A9E604F23A9F3"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1178",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Throws"
          },
          "fullDescription" : {
            "text" : "The method checkParams() in WeakAuthenticationCookie.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
          },
          "help" : {
            "text" : "Declaring a method to throw Exception or Throwable makes it difficult for callers to do good error handling and error recovery. Java's exception mechanism is set up to make it easy for callers to anticipate what can go wrong and write code to handle each specific exceptional circumstance. Declaring that a method throws a generic form of exception defeats this system.\n\nExample: The following method throws three types of exceptions.\n\n\npublic void doExchange()\n  throws IOException, InvocationTargetException,\n         SQLException {\n  ...\n}\n\n\n\nWhile it might seem tidier to write \n\n\npublic void doExchange()\n  throws Exception {\n  ...\n}\n\n\ndoing so hampers the caller's ability to understand and handle the exceptions that occur. Further, if a later revision of doExchange() introduces a new type of exception that should be treated differently than previous exceptions, there is no easy way to enforce this requirement.\n\nDo not declare methods to throw Exception or Throwable. If the exceptions thrown by a method are not recoverable or should not generally be caught by the caller, consider throwing unchecked exceptions rather than checked exceptions. This can be accomplished by implementing exception classes that extend RuntimeException or Error instead of Exception, or add a try/catch wrapper in your method to convert checked exceptions to unchecked exceptions.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1178/?engineType=SCA&issue=7A9D14739BA15F55897876721C44C389"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1102",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at WeakAuthenticationCookie.java line 194 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1102/?engineType=SCA&issue=3D97B81482736027CF4EEF717491B02E"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "674",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in WeakAuthenticationCookie.java might reveal system data or debugging information by calling printStackTrace() on line 197.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/674/?engineType=SCA&issue=F320CD0D64400B8E8CD55AB226B1808C"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1314",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Throws"
          },
          "fullDescription" : {
            "text" : "The method makeUser() in WeakAuthenticationCookie.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
          },
          "help" : {
            "text" : "Declaring a method to throw Exception or Throwable makes it difficult for callers to do good error handling and error recovery. Java's exception mechanism is set up to make it easy for callers to anticipate what can go wrong and write code to handle each specific exceptional circumstance. Declaring that a method throws a generic form of exception defeats this system.\n\nExample: The following method throws three types of exceptions.\n\n\npublic void doExchange()\n  throws IOException, InvocationTargetException,\n         SQLException {\n  ...\n}\n\n\n\nWhile it might seem tidier to write \n\n\npublic void doExchange()\n  throws Exception {\n  ...\n}\n\n\ndoing so hampers the caller's ability to understand and handle the exceptions that occur. Further, if a later revision of doExchange() introduces a new type of exception that should be treated differently than previous exceptions, there is no easy way to enforce this requirement.\n\nDo not declare methods to throw Exception or Throwable. If the exceptions thrown by a method are not recoverable or should not generally be caught by the caller, consider throwing unchecked exceptions rather than checked exceptions. This can be accomplished by implementing exception classes that extend RuntimeException or Error instead of Exception, or add a try/catch wrapper in your method to convert checked exceptions to unchecked exceptions.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1314/?engineType=SCA&issue=DFD20D8A60BD076F656B2B332AA1F9B2"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1042",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at WeakSessionID.java line 135 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1042/?engineType=SCA&issue=125144A9692E181B4844EEA386485889"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "487",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in WeakSessionID.java might reveal system data or debugging information by calling printStackTrace() on line 138.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/487/?engineType=SCA&issue=A8A03FD3342B94A6241E845EEB5873DD"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1209",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method makeLogin() in WeakSessionID.java ignores an exception on line 228, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1209/?engineType=SCA&issue=92C43F310A3F956352502EAD36C5B551"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1210",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method makeLogin() in WeakSessionID.java ignores an exception on line 234, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1210/?engineType=SCA&issue=92C43F310A3F956352502EAD36C5B552"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1181",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at WsSAXInjection.java line 163 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1181/?engineType=SCA&issue=7CA6791DD58737AB497E5E78D71B71E6"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "125",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in WsSAXInjection.java might reveal system data or debugging information by calling printStackTrace() on line 166.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/125/?engineType=SCA&issue=2B04DD17B5D46FB70C0FD974CE08F0CD"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "670",
          "shortDescription" : {
            "text" : "Password Management: Hardcoded Password"
          },
          "fullDescription" : {
            "text" : "Hardcoded passwords can compromise system security in a way that cannot be easily remedied.\n\n\n"
          },
          "help" : {
            "text" : "It is never a good idea to hardcode a password. Not only does hardcoding a password allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. Once the code is in production, the password cannot be changed without patching the software. If the account protected by the password is compromised, the owners of the system will be forced to choose between security and availability.\n\n\nExample: The following code uses a hardcoded password to connect to a database:\n\n\n...\nDriverManager.getConnection(url, \"scott\", \"tiger\");\n...\n\n\nThis code will run successfully, but anyone who has access to it will have access to the password. Once the program has shipped, there is no going back from the database user \"scott\" with a password of \"tiger\" unless the program is patched. A devious employee with access to this information can use it to break into the system. Even worse, if attackers have access to the bytecode for application, they can use the javap -c command to access the disassembled code, which will contain the values of the passwords used. The result of this operation might look something like the following for the example above:\n\n\njavap -c ConnMngr.class\n\n22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql\n24: ldc   #38; //String scott\n26: ldc   #17; //String tiger\n\n\n\nPasswords should never be hardcoded and should generally be obfuscated and managed in an external source. Storing passwords in plaintext anywhere on the system allows anyone with sufficient permissions to read and potentially misuse the password.\n\nSome third party products claim the ability to manage passwords in a more secure way. For example, WebSphere Application Server 4.x uses a simple XOR encryption algorithm for obfuscating values, but be skeptical about such facilities. WebSphere and other application servers offer outdated and relatively weak encryption mechanisms that are insufficient for security-sensitive environments. For a secure solution, the only viable option available today appears to be a proprietary one that you create.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/670/?engineType=SCA&issue=F151F2AC57994650A3A31069D9353F5A"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1260",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at WsSqlInjection.java line 216 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1260/?engineType=SCA&issue=B80F7E5451D2354A70D8080A4A26F131"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "111",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in WsSqlInjection.java might reveal system data or debugging information by calling printStackTrace() on line 219.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/111/?engineType=SCA&issue=25742E56A92040D260B30A6926B06A6C"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1193",
          "shortDescription" : {
            "text" : "Unreleased Resource: Database"
          },
          "fullDescription" : {
            "text" : "The function getResults() in WsSqlInjection.java sometimes fails to release a system resource allocated by <a href=\"event:file=JavaSource/org/owasp/webgoat/session/DatabaseUtilities.java&amp;lineNo=82\" rel=\"nofollow\">makeConnection()</a> on line 229.\n\n\n"
          },
          "help" : {
            "text" : "The program can potentially fail to release a system resource.\n\n    In this case, there are program paths on which the resource allocated in WsSqlInjection.java at line 229 is not released.\n\n\nResource leaks have at least two common causes:\n\n- Error conditions and other exceptional circumstances.\n\n- Confusion over which part of the program is responsible for releasing the resource.\n\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.\n\nExample 1: The following method never closes the file handle it opens. The finalize() method for FileInputStream eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n\n\nprivate void processFile(String fName) throws FileNotFoundException, IOException\n{\n  FileInputStream fis = new FileInputStream(fName);\n  int sz;\n  byte[] byteArray = new byte[BLOCK_SIZE];\n  while ((sz = fis.read(byteArray)) != -1) {\n    processBytes(byteArray, sz);\n  }\n}\n\n\nExample 2: Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.\n\n\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(CXN_SQL);\n  harvestResults(rs);\n  stmt.close();\n\n\n\n1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to \"bursty\" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.\n\nFinally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang. \n\n2. Release resources in a finally block. The code for Example 2 should be rewritten as follows:\n\n\n  public void execCxnSql(Connection conn) {\n    Statement stmt;\n    try {\n      stmt = conn.createStatement();\n      ResultSet rs = stmt.executeQuery(CXN_SQL);\n      ...\n    }\n    finally {\n      if (stmt != null) {\n        safeClose(stmt);\n      }\n    }\n}\n\npublic static void safeClose(Statement stmt) {\n  if (stmt != null) {\n    try {\n      stmt.close();\n    } catch (SQLException e) {\n      log(e);\n    }\n  }\n}\n\n\nThis solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. \n\nAlso, the execCxnSql method does not initialize the stmt object to null. Instead, it checks to ensure that stmt is not null before calling safeClose(). Without the null check, the Java compiler reports that stmt might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  stmt is initialized to null in a more complex method, cases in which stmt is used without being initialized will not be detected by the compiler. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1193/?engineType=SCA&issue=82D70BA5E84D0C9D4F5969FFB9E2BB82"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1115",
          "shortDescription" : {
            "text" : "Unreleased Resource: Database"
          },
          "fullDescription" : {
            "text" : "The function getResults() in WsSqlInjection.java sometimes fails to release a system resource allocated by <a href=\"event:file=JavaSource/org/owasp/webgoat/session/DatabaseUtilities.java&amp;lineNo=82\" rel=\"nofollow\">makeConnection()</a> on line 229.\n\n\n"
          },
          "help" : {
            "text" : "The program can potentially fail to release a system resource.\n\n    In this case, there are program paths on which the resource allocated in WsSqlInjection.java at line 229 is not released.\n\n\nResource leaks have at least two common causes:\n\n- Error conditions and other exceptional circumstances.\n\n- Confusion over which part of the program is responsible for releasing the resource.\n\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.\n\nExample 1: The following method never closes the file handle it opens. The finalize() method for FileInputStream eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n\n\nprivate void processFile(String fName) throws FileNotFoundException, IOException\n{\n  FileInputStream fis = new FileInputStream(fName);\n  int sz;\n  byte[] byteArray = new byte[BLOCK_SIZE];\n  while ((sz = fis.read(byteArray)) != -1) {\n    processBytes(byteArray, sz);\n  }\n}\n\n\nExample 2: Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.\n\n\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(CXN_SQL);\n  harvestResults(rs);\n  stmt.close();\n\n\n\n1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to \"bursty\" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.\n\nFinally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang. \n\n2. Release resources in a finally block. The code for Example 2 should be rewritten as follows:\n\n\n  public void execCxnSql(Connection conn) {\n    Statement stmt;\n    try {\n      stmt = conn.createStatement();\n      ResultSet rs = stmt.executeQuery(CXN_SQL);\n      ...\n    }\n    finally {\n      if (stmt != null) {\n        safeClose(stmt);\n      }\n    }\n}\n\npublic static void safeClose(Statement stmt) {\n  if (stmt != null) {\n    try {\n      stmt.close();\n    } catch (SQLException e) {\n      log(e);\n    }\n  }\n}\n\n\nThis solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. \n\nAlso, the execCxnSql method does not initialize the stmt object to null. Instead, it checks to ensure that stmt is not null before calling safeClose(). Without the null check, the Java compiler reports that stmt might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  stmt is initialized to null in a more complex method, cases in which stmt is used without being initialized will not be detected by the compiler. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1115/?engineType=SCA&issue=451A17229ADFC2431B64826831C3B627"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "373",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 240 of WsSqlInjection.java, the method getResults() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getCreditCard() in WsSqlInjection.java at line 252. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeQuery() in WsSqlInjection.java at line 240.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/373/?engineType=SCA&issue=80F2D5A5B05EF3E157B2A00601FAC160"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1287",
          "shortDescription" : {
            "text" : "Unreleased Resource: Database"
          },
          "fullDescription" : {
            "text" : "The function getResults() in WsSqlInjection.java sometimes fails to release a system resource allocated by <a href=\"event:file=JavaSource/org/owasp/webgoat/session/DatabaseUtilities.java&amp;lineNo=82\" rel=\"nofollow\">makeConnection()</a> on line 229.\n\n\n"
          },
          "help" : {
            "text" : "The program can potentially fail to release a system resource.\n\n    In this case, there are program paths on which the resource allocated in WsSqlInjection.java at line 229 is not released.\n\n\nResource leaks have at least two common causes:\n\n- Error conditions and other exceptional circumstances.\n\n- Confusion over which part of the program is responsible for releasing the resource.\n\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.\n\nExample 1: The following method never closes the file handle it opens. The finalize() method for FileInputStream eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n\n\nprivate void processFile(String fName) throws FileNotFoundException, IOException\n{\n  FileInputStream fis = new FileInputStream(fName);\n  int sz;\n  byte[] byteArray = new byte[BLOCK_SIZE];\n  while ((sz = fis.read(byteArray)) != -1) {\n    processBytes(byteArray, sz);\n  }\n}\n\n\nExample 2: Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.\n\n\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(CXN_SQL);\n  harvestResults(rs);\n  stmt.close();\n\n\n\n1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to \"bursty\" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.\n\nFinally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang. \n\n2. Release resources in a finally block. The code for Example 2 should be rewritten as follows:\n\n\n  public void execCxnSql(Connection conn) {\n    Statement stmt;\n    try {\n      stmt = conn.createStatement();\n      ResultSet rs = stmt.executeQuery(CXN_SQL);\n      ...\n    }\n    finally {\n      if (stmt != null) {\n        safeClose(stmt);\n      }\n    }\n}\n\npublic static void safeClose(Statement stmt) {\n  if (stmt != null) {\n    try {\n      stmt.close();\n    } catch (SQLException e) {\n      log(e);\n    }\n  }\n}\n\n\nThis solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. \n\nAlso, the execCxnSql method does not initialize the stmt object to null. Instead, it checks to ensure that stmt is not null before calling safeClose(). Without the null check, the Java compiler reports that stmt might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  stmt is initialized to null in a more complex method, cases in which stmt is used without being initialized will not be detected by the compiler. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1287/?engineType=SCA&issue=CDAFF78604806F2C9413943C8A3A691B"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1776",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 240 of WsSqlInjection.java, the method getResults() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeQuery() in WsSqlInjection.java at line 240.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1776/?engineType=SCA&issue=CFA08E705B2FEB36B31081983682AFBA"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "310",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method getResults() in WsSqlInjection.java ignores an exception on line 243, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/310/?engineType=SCA&issue=6843E1A15E92F2D722831D80D2C09DE5"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "311",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method getResults() in WsSqlInjection.java ignores an exception on line 246, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/311/?engineType=SCA&issue=6843E1A15E92F2D722831D80D2C09DE6"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "491",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at WsSqlInjection.java line 246 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/491/?engineType=SCA&issue=AA803124133D98FE04A15C11A816D18D"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "389",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method getCreditCard() in WsSqlInjection.java ignores an exception on line 273, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/389/?engineType=SCA&issue=88586BB1D4487A36D1054CED59AE80BD"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1124",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at XMLInjection.java line 126 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1124/?engineType=SCA&issue=494710AD032BFD3226C4503F00F32525"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "226",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function handleRequest() in XMLInjection.java might reveal system data or debugging information by calling printStackTrace() on line 128.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/226/?engineType=SCA&issue=4955E5682DB1F23BC21B272890D9F5DD"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1107",
          "shortDescription" : {
            "text" : "Unreleased Resource: Streams"
          },
          "fullDescription" : {
            "text" : "The function createContent() in XPATHInjection.java sometimes fails to release a system resource allocated by FileInputStream() on line 155.\n\n\n"
          },
          "help" : {
            "text" : "The program can potentially fail to release a system resource.\n\n    In this case, there are program paths on which the resource allocated in XPATHInjection.java at line 155 is not released.\n\n\nResource leaks have at least two common causes:\n\n- Error conditions and other exceptional circumstances.\n\n- Confusion over which part of the program is responsible for releasing the resource.\n\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.\n\nExample 1: The following method never closes the file handle it opens. The finalize() method for FileInputStream eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n\n\nprivate void processFile(String fName) throws FileNotFoundException, IOException\n{\n  FileInputStream fis = new FileInputStream(fName);\n  int sz;\n  byte[] byteArray = new byte[BLOCK_SIZE];\n  while ((sz = fis.read(byteArray)) != -1) {\n    processBytes(byteArray, sz);\n  }\n}\n\n\nExample 2: Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.\n\n\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(CXN_SQL);\n  harvestResults(rs);\n  stmt.close();\n\n\n\n1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to \"bursty\" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.\n\nFinally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang. \n\n2. Release resources in a finally block. The code for Example 2 should be rewritten as follows:\n\n\n  public void execCxnSql(Connection conn) {\n    Statement stmt;\n    try {\n      stmt = conn.createStatement();\n      ResultSet rs = stmt.executeQuery(CXN_SQL);\n      ...\n    }\n    finally {\n      if (stmt != null) {\n        safeClose(stmt);\n      }\n    }\n}\n\npublic static void safeClose(Statement stmt) {\n  if (stmt != null) {\n    try {\n      stmt.close();\n    } catch (SQLException e) {\n      log(e);\n    }\n  }\n}\n\n\nThis solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. \n\nAlso, the execCxnSql method does not initialize the stmt object to null. Instead, it checks to ensure that stmt is not null before calling safeClose(). Without the null check, the Java compiler reports that stmt might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  stmt is initialized to null in a more complex method, cases in which stmt is used without being initialized will not be detected by the compiler. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1107/?engineType=SCA&issue=42AB68D270545768293D3D37571A4EFE"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1759",
          "shortDescription" : {
            "text" : "XPath Injection"
          },
          "fullDescription" : {
            "text" : "On line 158 of XPATHInjection.java, the method createContent() invokes an XPath query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary XPath queries.\n\n\n"
          },
          "help" : {
            "text" : "XPath injection occurs when:\n\n1.       Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627.\n\n\n2.       The data used to dynamically construct an XPath query.\n\n\nIn this case the query is passed to evaluate() in XPATHInjection.java at line 158.\n\n\nExample 1: The following code dynamically constructs and executes an XPath query that retrieves an e-mail address for a given account ID.  The account ID is read from an HTTP request, and is therefore untrusted.\n\n\n...\nString acctID = request.getParameter(\"acctID\");\nString query = null;\nif(acctID != null) {\n       StringBuffer sb = new StringBuffer(\"/accounts/account[acctID='\");\n       sb.append(acctID);\n       sb.append(\"']/email/text()\");\n       query = sb.toString();\n}\n\nDocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();\ndomFactory.setNamespaceAware(true);\nDocumentBuilder builder = domFactory.newDocumentBuilder();\nDocument doc = builder.parse(\"accounts.xml\");\nXPathFactory factory = XPathFactory.newInstance();\nXPath xpath = factory.newXPath();\nXPathExpression expr = xpath.compile(query);\nObject result = expr.evaluate(doc, XPathConstants.NODESET);\n...\n\n\nUnder normal conditions, such as searching for an e-mail address that belongs to the account number 1, the query that this code executes will look like the following:\n\n/accounts/account[acctID='1']/email/text()\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if acctID does not contain a single-quote character. If an attacker enters the string 1' or '1' = '1 for acctID, then the query becomes the following:\n\n/accounts/account[acctID='1' or '1' = '1']/email/text()\n\nThe addition of the 1' or '1' = '1 condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n//email/text()\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all e-mail addresses stored in the document, regardless of their specified owner.\n\n\nThe root cause of XPath injection vulnerability is the ability of an attacker to change context in the XPath query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead.  When an XPath query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data.\n \nTo prevent an attacker from violating the programmer's expectations, use a whitelist to ensure that user-controlled values used in an XPath query are composed from only the expected set of characters and do not contain any XPath metacharacters given the context in which they are used. If a user-controlled value requires that it contain XPath metacharacters, use an appropriate encoding mechanism to remove their significance within the XPath query.\n\nExample 2\n\n...\nString acctID = request.getParameter(\"acctID\");\nString query = null;\nif(acctID != null) {\n       Integer iAcctID = -1;\n       try {\n              iAcctID = Integer.parseInt(acctID);\n       }\n       catch (NumberFormatException e) {\n              throw new InvalidParameterException();\n       }\n       StringBuffer sb = new StringBuffer(\"/accounts/account[acctID='\");\n       sb.append(iAcctID.toString());\n       sb.append(\"']/email/text()\");\n       query = sb.toString();\n}\n\nDocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();\ndomFactory.setNamespaceAware(true);\nDocumentBuilder builder = domFactory.newDocumentBuilder();\nDocument doc = builder.parse(\"accounts.xml\");\nXPathFactory factory = XPathFactory.newInstance();\nXPath xpath = factory.newXPath();\nXPathExpression expr = xpath.compile(query);\nObject result = expr.evaluate(doc, XPathConstants.NODESET);\n...\n\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1759/?engineType=SCA&issue=C60AE754EFD609218E5CAD052E66D479"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "338",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in XPATHInjection.java might reveal system data or debugging information by calling printStackTrace() on line 202.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/338/?engineType=SCA&issue=74C884820E4739861A03F8B6D623275D"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "337",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in XPATHInjection.java might reveal system data or debugging information by calling printStackTrace() on line 207.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/337/?engineType=SCA&issue=74C884820E4739861A03F8B6D623275C"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "651",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in XPATHInjection.java might reveal system data or debugging information by calling printStackTrace() on line 212.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/651/?engineType=SCA&issue=EA9B69789F87214E21A83B60748AE677"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1251",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ProductsAdminScreen.java line 85 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1251/?engineType=SCA&issue=B25556823A56BD9833EC97928C6BE3C8"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "673",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in ProductsAdminScreen.java might reveal system data or debugging information by calling printStackTrace() on line 88.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/673/?engineType=SCA&issue=F2A3B37C92D64B9A4D3A13851DF8D76E"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1348",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at RefreshDBScreen.java line 96 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1348/?engineType=SCA&issue=FC4F6942D7BC47D8FED62F11B3107EC4"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "531",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in RefreshDBScreen.java might reveal system data or debugging information by calling printStackTrace() on line 99.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/531/?engineType=SCA&issue=B5DBB03F9B63EAF24FDBFAEEDA0E29E2"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1350",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1350/?engineType=SCA&issue=FCE9252971FBC36A1EF9D0890878DBE6"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1118",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at RefreshDBScreen.java line 165 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1118/?engineType=SCA&issue=47EE7B29EE0DDEE757C5385A1C716A5D"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "519",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function refreshDB() in RefreshDBScreen.java might reveal system data or debugging information by calling printStackTrace() on line 169.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/519/?engineType=SCA&issue=AFC4AB32F20D390E9F9D1EC215C5F28B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1060",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method createContent() in ReportCardScreen.java ignores an exception on line 87, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1060/?engineType=SCA&issue=1C951988FCDAF1CF15CAF1830327E1B7"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1351",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ReportCardScreen.java line 87 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1351/?engineType=SCA&issue=FE6BAAC5859A30F6057733FE921F1499"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1205",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at SummaryReportCardScreen.java line 99 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1205/?engineType=SCA&issue=8DF99DB0044A09539852F92D2ECEB075"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "488",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in SummaryReportCardScreen.java might reveal system data or debugging information by calling printStackTrace() on line 101.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/488/?engineType=SCA&issue=A94731E83EB1AF8526072EA57511AF95"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1048",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at UserAdminScreen.java line 85 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1048/?engineType=SCA&issue=15D987114F12FA24A0A82EA17D1EBC02"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "671",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in UserAdminScreen.java might reveal system data or debugging information by calling printStackTrace() on line 88.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/671/?engineType=SCA&issue=F1BE853B45C96F767817CE6D92D5FC4C"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1654",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 90 of ViewDatabase.java, the method createContent() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627. \n\n\n2. The data is used to dynamically construct a SQL query. \n\n\nIn this case the data is passed to executeQuery() in ViewDatabase.java at line 90.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. \n\n\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\" \n\t\t\t\t+ userName + \"' AND itemname = '\"  \n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n\t...\n\n\nThe query that this code intends to execute follows:\n\n\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\n\tSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\t--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. \n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created: \n\n\n\tSELECT * FROM items \n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\n\n\tDELETE FROM items;\n\n\tSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:\n\n- Target fields that are not quoted\n\n- Find ways to bypass the need for certain escaped meta-characters\n\n- Use stored procedures to hide the injected meta-characters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. \n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. \n\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nThe previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query =\n \t       \"SELECT * FROM items WHERE itemname=? AND owner=?\"; \nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1654/?engineType=SCA&issue=6F6AC2229DF8D02A530F051A6AD33967"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1076",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ViewDatabase.java line 102 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1076/?engineType=SCA&issue=2A58CC1547323D1AFB16464A0341A35F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "523",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in ViewDatabase.java might reveal system data or debugging information by calling printStackTrace() on line 105.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/523/?engineType=SCA&issue=B1D0DC02CF0F0466CA099B070DE0D4F7"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1092",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1092/?engineType=SCA&issue=368BE56DC03554499D14E197D9C9F157"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1308",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function Course() in Course.java might reveal system data or debugging information by calling printStackTrace() on line 72.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1308/?engineType=SCA&issue=D9886F39472E4FB32B12FB9ED7A42A23"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1169",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at Course.java line 377 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1169/?engineType=SCA&issue=757165A83BF25887A323F656ED89A76B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1253",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method loadLessons() in Course.java ignores an exception on line 377, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1253/?engineType=SCA&issue=B4314B398110D1A245F120ACF94D95B2"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1831",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1831/?engineType=SCA&issue=F6EFAEDA0214169B96CB9979E5C03C98"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1842",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in CreateDB.java might reveal system data or debugging information by calling printStackTrace() on line 63.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1842/?engineType=SCA&issue=F8A0BE43919B1CC24D313FC8505FB218"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1704",
          "shortDescription" : {
            "text" : "Unreleased Resource: Database"
          },
          "fullDescription" : {
            "text" : "The function main() in CreateDB.java sometimes fails to release a system resource allocated by getConnection() on line 70.\n\n\n"
          },
          "help" : {
            "text" : "The program can potentially fail to release a system resource.\n\n    In this case, there are program paths on which the resource allocated in CreateDB.java at line 70 is not released.\n\n\nResource leaks have at least two common causes:\n\n- Error conditions and other exceptional circumstances.\n\n- Confusion over which part of the program is responsible for releasing the resource.\n\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.\n\nExample 1: The following method never closes the file handle it opens. The finalize() method for FileInputStream eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n\n\nprivate void processFile(String fName) throws FileNotFoundException, IOException\n{\n  FileInputStream fis = new FileInputStream(fName);\n  int sz;\n  byte[] byteArray = new byte[BLOCK_SIZE];\n  while ((sz = fis.read(byteArray)) != -1) {\n    processBytes(byteArray, sz);\n  }\n}\n\n\nExample 2: Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.\n\n\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(CXN_SQL);\n  harvestResults(rs);\n  stmt.close();\n\n\n\n1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to \"bursty\" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.\n\nFinally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang. \n\n2. Release resources in a finally block. The code for Example 2 should be rewritten as follows:\n\n\n  public void execCxnSql(Connection conn) {\n    Statement stmt;\n    try {\n      stmt = conn.createStatement();\n      ResultSet rs = stmt.executeQuery(CXN_SQL);\n      ...\n    }\n    finally {\n      if (stmt != null) {\n        safeClose(stmt);\n      }\n    }\n}\n\npublic static void safeClose(Statement stmt) {\n  if (stmt != null) {\n    try {\n      stmt.close();\n    } catch (SQLException e) {\n      log(e);\n    }\n  }\n}\n\n\nThis solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. \n\nAlso, the execCxnSql method does not initialize the stmt object to null. Instead, it checks to ensure that stmt is not null before calling safeClose(). Without the null check, the Java compiler reports that stmt might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  stmt is initialized to null in a more complex method, cases in which stmt is used without being initialized will not be detected by the compiler. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1704/?engineType=SCA&issue=9CC65560EA0A2E0B99A4F34F77582BCB"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1789",
          "shortDescription" : {
            "text" : "Unreleased Resource: Database"
          },
          "fullDescription" : {
            "text" : "The function main() in CreateDB.java sometimes fails to release a system resource allocated by getConnection() on line 70.\n\n\n"
          },
          "help" : {
            "text" : "The program can potentially fail to release a system resource.\n\n    In this case, there are program paths on which the resource allocated in CreateDB.java at line 70 is not released.\n\n\nResource leaks have at least two common causes:\n\n- Error conditions and other exceptional circumstances.\n\n- Confusion over which part of the program is responsible for releasing the resource.\n\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.\n\nExample 1: The following method never closes the file handle it opens. The finalize() method for FileInputStream eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n\n\nprivate void processFile(String fName) throws FileNotFoundException, IOException\n{\n  FileInputStream fis = new FileInputStream(fName);\n  int sz;\n  byte[] byteArray = new byte[BLOCK_SIZE];\n  while ((sz = fis.read(byteArray)) != -1) {\n    processBytes(byteArray, sz);\n  }\n}\n\n\nExample 2: Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.\n\n\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(CXN_SQL);\n  harvestResults(rs);\n  stmt.close();\n\n\n\n1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to \"bursty\" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.\n\nFinally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang. \n\n2. Release resources in a finally block. The code for Example 2 should be rewritten as follows:\n\n\n  public void execCxnSql(Connection conn) {\n    Statement stmt;\n    try {\n      stmt = conn.createStatement();\n      ResultSet rs = stmt.executeQuery(CXN_SQL);\n      ...\n    }\n    finally {\n      if (stmt != null) {\n        safeClose(stmt);\n      }\n    }\n}\n\npublic static void safeClose(Statement stmt) {\n  if (stmt != null) {\n    try {\n      stmt.close();\n    } catch (SQLException e) {\n      log(e);\n    }\n  }\n}\n\n\nThis solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. \n\nAlso, the execCxnSql method does not initialize the stmt object to null. Instead, it checks to ensure that stmt is not null before calling safeClose(). Without the null check, the Java compiler reports that stmt might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  stmt is initialized to null in a more complex method, cases in which stmt is used without being initialized will not be detected by the compiler. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1789/?engineType=SCA&issue=D91D9D2F568DE51F5261A463BB23A245"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1832",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1832/?engineType=SCA&issue=F6EFAEDA0214169B96CB9979E5C03C99"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1841",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in CreateDB.java might reveal system data or debugging information by calling printStackTrace() on line 78.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1841/?engineType=SCA&issue=F8A0BE43919B1CC24D313FC8505FB217"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1779",
          "shortDescription" : {
            "text" : "Unreleased Resource: Database"
          },
          "fullDescription" : {
            "text" : "The function main() in CreateDB.java sometimes fails to release a system resource allocated by getConnection() on line 70.\n\n\n"
          },
          "help" : {
            "text" : "The program can potentially fail to release a system resource.\n\n    In this case, there are program paths on which the resource allocated in CreateDB.java at line 70 is not released.\n\n\nResource leaks have at least two common causes:\n\n- Error conditions and other exceptional circumstances.\n\n- Confusion over which part of the program is responsible for releasing the resource.\n\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.\n\nExample 1: The following method never closes the file handle it opens. The finalize() method for FileInputStream eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n\n\nprivate void processFile(String fName) throws FileNotFoundException, IOException\n{\n  FileInputStream fis = new FileInputStream(fName);\n  int sz;\n  byte[] byteArray = new byte[BLOCK_SIZE];\n  while ((sz = fis.read(byteArray)) != -1) {\n    processBytes(byteArray, sz);\n  }\n}\n\n\nExample 2: Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.\n\n\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(CXN_SQL);\n  harvestResults(rs);\n  stmt.close();\n\n\n\n1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to \"bursty\" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.\n\nFinally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang. \n\n2. Release resources in a finally block. The code for Example 2 should be rewritten as follows:\n\n\n  public void execCxnSql(Connection conn) {\n    Statement stmt;\n    try {\n      stmt = conn.createStatement();\n      ResultSet rs = stmt.executeQuery(CXN_SQL);\n      ...\n    }\n    finally {\n      if (stmt != null) {\n        safeClose(stmt);\n      }\n    }\n}\n\npublic static void safeClose(Statement stmt) {\n  if (stmt != null) {\n    try {\n      stmt.close();\n    } catch (SQLException e) {\n      log(e);\n    }\n  }\n}\n\n\nThis solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. \n\nAlso, the execCxnSql method does not initialize the stmt object to null. Instead, it checks to ensure that stmt is not null before calling safeClose(). Without the null check, the Java compiler reports that stmt might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  stmt is initialized to null in a more complex method, cases in which stmt is used without being initialized will not be detected by the compiler. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1779/?engineType=SCA&issue=D087040CC5EC38F946C4D265C04CEC7F"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1833",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1833/?engineType=SCA&issue=F6EFAEDA0214169B96CB9979E5C03C9A"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1752",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in CreateDB.java might reveal system data or debugging information by calling printStackTrace() on line 101.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1752/?engineType=SCA&issue=BF7CEA65EB8E52B7BA7F9689AD3E7319"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1834",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1834/?engineType=SCA&issue=F6EFAEDA0214169B96CB9979E5C03C9B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1835",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1835/?engineType=SCA&issue=F6EFAEDA0214169B96CB9979E5C03C9C"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1751",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in CreateDB.java might reveal system data or debugging information by calling printStackTrace() on line 126.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1751/?engineType=SCA&issue=BF7CEA65EB8E52B7BA7F9689AD3E7318"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1659",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1659/?engineType=SCA&issue=724E94D249DD72230BB4A189D83487D5"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1660",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1660/?engineType=SCA&issue=724E94D249DD72230BB4A189D83487D6"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1581",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createMessageTable() in CreateDB.java might reveal system data or debugging information by calling printStackTrace() on line 165.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1581/?engineType=SCA&issue=2A4E10165937706D57A241B308EAA8AE"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1575",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1575/?engineType=SCA&issue=24C087A4806CB569AFD1A909CC8E8E16"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1576",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1576/?engineType=SCA&issue=24C087A4806CB569AFD1A909CC8E8E17"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1632",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createProductTable() in CreateDB.java might reveal system data or debugging information by calling printStackTrace() on line 203.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1632/?engineType=SCA&issue=5C590077BD415569074E3ADC37FB4548"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1595",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1595/?engineType=SCA&issue=3542DDF0D10488FB2A1E72BBA01A617A"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1596",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1596/?engineType=SCA&issue=3542DDF0D10488FB2A1E72BBA01A617B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1829",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createUserAdminTable() in CreateDB.java might reveal system data or debugging information by calling printStackTrace() on line 255.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1829/?engineType=SCA&issue=F5CE104ADE787D309B188DA800E168D9"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1706",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1706/?engineType=SCA&issue=9DA9A88EBD392A6A7FE7FAADC8ADF8CB"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1707",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1707/?engineType=SCA&issue=9DA9A88EBD392A6A7FE7FAADC8ADF8CC"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1695",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createUserDataTable() in CreateDB.java might reveal system data or debugging information by calling printStackTrace() on line 307.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1695/?engineType=SCA&issue=93CD6DEBF68343122976265824799022"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1754",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1754/?engineType=SCA&issue=C16B16C098BEE5CE2B8634CD6CAFE7A8"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1755",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1755/?engineType=SCA&issue=C16B16C098BEE5CE2B8634CD6CAFE7A9"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1851",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createLoginTable() in CreateDB.java might reveal system data or debugging information by calling printStackTrace() on line 365.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1851/?engineType=SCA&issue=FF76220E74EDAE7E4486A521D44AFB49"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1768",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1768/?engineType=SCA&issue=CBBCD347E74E1C3A0DC1F646A88AC8DF"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1769",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1769/?engineType=SCA&issue=CBBCD347E74E1C3A0DC1F646A88AC8E0"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1602",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createWeatherDataTable() in CreateDB.java might reveal system data or debugging information by calling printStackTrace() on line 406.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1602/?engineType=SCA&issue=3D85ED8EA02BD2FB40285F67BE1CDE88"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1655",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1655/?engineType=SCA&issue=6FF27C0075EC88B18F1BC5DF6A388EC7"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1656",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1656/?engineType=SCA&issue=6FF27C0075EC88B18F1BC5DF6A388EC8"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1554",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1554/?engineType=SCA&issue=127C2D515D6915803C85A5BFF9CD96DE"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1555",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1555/?engineType=SCA&issue=127C2D515D6915803C85A5BFF9CD96DF"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1640",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1640/?engineType=SCA&issue=68E135A1A0A5F990F2281AD652A575AB"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1641",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1641/?engineType=SCA&issue=68E135A1A0A5F990F2281AD652A575AC"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1723",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1723/?engineType=SCA&issue=AAEBC31612A7257DD3CB71C4D9922BA7"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1724",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1724/?engineType=SCA&issue=AAEBC31612A7257DD3CB71C4D9922BA8"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1545",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1545/?engineType=SCA&issue=0CB45A2FA542F2ADD850FC11D2A0D93D"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1546",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1546/?engineType=SCA&issue=0CB45A2FA542F2ADD850FC11D2A0D93E"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1289",
          "shortDescription" : {
            "text" : "Unsafe Reflection"
          },
          "fullDescription" : {
            "text" : "Attackers can control an argument to the reflection method forName() at DatabaseUtilities.java line 66, which could allow them to create unexpected control flow paths through the application, potentially bypassing security checks.\n\n\n"
          },
          "help" : {
            "text" : "If an attacker can supply values that the application then uses to determine which class to instantiate or which method to invoke, the potential exists for the attacker to create control flow paths through the application that were not intended by the application developers. This attack vector may allow the attacker to bypass authentication or access control checks or otherwise cause the application to behave in an unexpected manner. Even the ability to control the arguments passed to a given method or constructor may give a wily attacker the edge necessary to mount a successful attack. \n\nThis situation becomes a doomsday scenario if the attacker can upload files into a location that appears on the application's classpath or add new entries to the application's classpath. Under either of these conditions, the attacker can use reflection to introduce new, presumably malicious, behavior into the application.\n\nIn this case the untrusted data enters the program at getInitParameter() in WebSession.java at line 275. It is passed to the reflection API at forName() in DatabaseUtilities.java at line 66.\n\nExample: A common reason that programmers use the reflection API is to implement their own command dispatcher. The following example shows a command dispatcher that does not use reflection:\n\n\nString ctl = request.getParameter(\"ctl\");\nWorker ao = null;\nif (ctl.equals(\"Add\")) {\n  ao = new AddCommand();\n} else if (ctl.equals(\"Modify\")) {\n  ao = new ModifyCommand();\n} else {\n  throw new UnknownActionError();\n}\nao.doAction(request);\n\n\nA programmer might refactor this code to use reflection as follows:\n\n\n    String ctl = request.getParameter(\"ctl\");\n    Class cmdClass = Class.forName(ctl + \"Command\");\n    Worker ao = (Worker) cmdClass.newInstance();\n    ao.doAction(request);\n\n\nThe refactoring initially appears to offer a number of advantages. There are fewer lines of code, the if/else blocks have been entirely eliminated, and it is now possible to add new command types without modifying the command dispatcher.\n\nHowever, the refactoring allows an attacker to instantiate any object that implements the Worker interface. If the command dispatcher is still responsible for access control, then whenever programmers create a new class that implements the Worker interface, they must remember to modify the dispatcher's access control code. If they fail to modify the access control code, then some Worker classes will not have any access control.\n\nOne way to address this access control problem is to make the Worker object responsible for performing the access control check. An example of the re-refactored code follows:\n\n\nString ctl = request.getParameter(\"ctl\");\nClass cmdClass = Class.forName(ctl + \"Command\");\nWorker ao = (Worker) cmdClass.newInstance();\nao.checkAccessControl(request);\nao.doAction(request);\n\n\nAlthough this is an improvement, it encourages a decentralized approach to access control, which makes it easier for programmers to make access control mistakes.\n\nThis code also highlights another security problem with using reflection to build a command dispatcher. An attacker can invoke the default constructor for any kind of object. In fact, the attacker is not even constrained to objects that implement the Worker interface; the default constructor for any object in the system can be invoked. If the object does not implement the Worker interface, a ClassCastException will be thrown before the assignment to ao, but if the constructor performs operations that work in the attacker's favor, the damage will already have been done. Although this scenario is relatively benign in simple applications, in larger applications where complexity grows exponentially it is not unreasonable that an attacker could find a constructor to leverage as part of an attack. \n\n\nThe best way to prevent unsafe reflection is with a level of indirection: create a list of legitimate names that users are allowed to specify, and only allow users to select from the list. With this approach, input provided by users is never used directly to specify a name that is passed to the reflection API.\n\nReflection can also be used to create a custom data-driven architecture, whereby a configuration file determines the types and combinations of objects that are used by the application. This style of programming introduces the following security concerns:\n\n- The configuration file that controls the program is an essential part of the program's source code and must be protected and reviewed accordingly.\n\n- Because the configuration file is unique to the application, unique work must be performed to evaluate the security of the design.\n\n- Because the semantics of the application are now governed by a configuration file with a custom format, custom rules are required for obtaining optimal static analysis results.\n\nFor these reasons, avoid using this style of design unless your team can devote a large amount of effort to security evaluation.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1289/?engineType=SCA&issue=CF6350F88FA69DDBB6F671F1EE6C01D7"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1034",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function makeConnection() in DatabaseUtilities.java might reveal system data or debugging information by calling println() on line 95.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1034/?engineType=SCA&issue=0B38BCEEE7F2B81F7433FA988C11E625"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1285",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1285/?engineType=SCA&issue=CCD4B143682A4683F6EC630E93BFB3DA"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1164",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at DatabaseUtilities.java line 108 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1164/?engineType=SCA&issue=6CA7FAD40A38050006A40F1929490FEC"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1211",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function makeConnection() in DatabaseUtilities.java might reveal system data or debugging information by calling printStackTrace() on line 110.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1211/?engineType=SCA&issue=94544F7344343065945982F8E21BCE4E"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1806",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ErrorScreen.java line 107 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1806/?engineType=SCA&issue=E4F576AD9B9099E7648A661FD3E026DC"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1590",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1590/?engineType=SCA&issue=31DEE6B21465265B07E2F227B82A1848"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1811",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in ErrorScreen.java might reveal system data or debugging information by calling println() on line 159.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1811/?engineType=SCA&issue=E8F9645A31D168CF4EB9D6B8CEF41756"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1828",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function createContent() in ErrorScreen.java might reveal system data or debugging information by calling println() on line 159.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1828/?engineType=SCA&issue=F54BAA218F40DA45D1D12747610709EA"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1692",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getStackTrace() in ErrorScreen.java might reveal system data or debugging information by calling printStackTrace() on line 258.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1692/?engineType=SCA&issue=9173282D79F380158CB220AE42554726"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1274",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method load() in LessonTracker.java ignores an exception on line 247, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1274/?engineType=SCA&issue=C5BD52D4D9034951347E8AE8481F11BC"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1090",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at LessonTracker.java line 251 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1090/?engineType=SCA&issue=3541B59CCC3B82B15BA004D41B6A464C"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1094",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1094/?engineType=SCA&issue=379104AF7B371A11C95744BFF851EF1E"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1355",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function load() in LessonTracker.java might reveal system data or debugging information by calling printStackTrace() on line 254.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1355/?engineType=SCA&issue=FF10EE5C1C632AD667838979FD8C253C"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1091",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at LessonTracker.java line 262 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1091/?engineType=SCA&issue=3541B59CCC3B82B15BA004D41B6A464D"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1275",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method load() in LessonTracker.java ignores an exception on line 262, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1275/?engineType=SCA&issue=C5BD52D4D9034951347E8AE8481F11BD"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1146",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at LessonTracker.java line 391 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1146/?engineType=SCA&issue=5FE5E75EFAB278E8A87ABDB6DFA6EB57"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1126",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1126/?engineType=SCA&issue=49BA822B92A28A157097157E71E8D54F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1147",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at LessonTracker.java line 403 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1147/?engineType=SCA&issue=5FE5E75EFAB278E8A87ABDB6DFA6EB58"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1327",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method store() in LessonTracker.java ignores an exception on line 403, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1327/?engineType=SCA&issue=EE6D0BB18FEBEFDBFB1DB27798A63FBA"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1557",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method ParameterNotFoundException() in ParameterNotFoundException.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to Exception() in ParameterNotFoundException.java at line 54.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1557/?engineType=SCA&issue=13AE22C88661F95BF75681BE4BF98F12"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1579",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method ParameterNotFoundException() in ParameterNotFoundException.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to Exception() in ParameterNotFoundException.java at line 54.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1579/?engineType=SCA&issue=287000CB289F94A2D000C2135A46B8E1"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1589",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method ParameterNotFoundException() in ParameterNotFoundException.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to Exception() in ParameterNotFoundException.java at line 54.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1589/?engineType=SCA&issue=31BE6343A0D2F95463E6967907F465AE"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1620",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method ParameterNotFoundException() in ParameterNotFoundException.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to Exception() in ParameterNotFoundException.java at line 54.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1620/?engineType=SCA&issue=4D6F5C54F83CEC6C7689E5E34BA02A74"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1635",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method ParameterNotFoundException() in ParameterNotFoundException.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to Exception() in ParameterNotFoundException.java at line 54.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1635/?engineType=SCA&issue=653BC22E0B18298FA822AEA15C8DD8A6"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1648",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method ParameterNotFoundException() in ParameterNotFoundException.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to Exception() in ParameterNotFoundException.java at line 54.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1648/?engineType=SCA&issue=6C721EF2E9704C4C94BFC11574CF04AD"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1669",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method ParameterNotFoundException() in ParameterNotFoundException.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to Exception() in ParameterNotFoundException.java at line 54.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1669/?engineType=SCA&issue=767FC201B2B8CC97B04C92814C3D8820"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1679",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method ParameterNotFoundException() in ParameterNotFoundException.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to Exception() in ParameterNotFoundException.java at line 54.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1679/?engineType=SCA&issue=7EDA4AB335E028B1A7620351353D9541"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1739",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method ParameterNotFoundException() in ParameterNotFoundException.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to Exception() in ParameterNotFoundException.java at line 54.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1739/?engineType=SCA&issue=BBDD7E47BFA6F4D3D884A16F93DACDCE"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1767",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method ParameterNotFoundException() in ParameterNotFoundException.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to Exception() in ParameterNotFoundException.java at line 54.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1767/?engineType=SCA&issue=CB4C984A1BA521A2604E9BBCEF6995F0"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1785",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method ParameterNotFoundException() in ParameterNotFoundException.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to Exception() in ParameterNotFoundException.java at line 54.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1785/?engineType=SCA&issue=D5C76C17C5FE92CA3F31722313D1D577"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1846",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method ParameterNotFoundException() in ParameterNotFoundException.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to Exception() in ParameterNotFoundException.java at line 54.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1846/?engineType=SCA&issue=FD067016C70D5FB1997E5E11D4D30D7D"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1631",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ParameterParser.java line 120 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1631/?engineType=SCA&issue=5A1F1426EE75EE3FBA9FFDAE1D0E00C5"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1570",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ParameterParser.java line 141 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1570/?engineType=SCA&issue=22D5DCF1F61F33777ABC35D715FFD8FC"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1745",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ParameterParser.java line 179 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1745/?engineType=SCA&issue=BE61BA7E4DC82B0854B087781BE03EAF"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1792",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ParameterParser.java line 223 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1792/?engineType=SCA&issue=DA6FAC864D9770BC794738AD32E422AD"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1787",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ParameterParser.java line 261 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1787/?engineType=SCA&issue=D6E0432232121ACB0F40714D5AB71B02"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1625",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ParameterParser.java line 298 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1625/?engineType=SCA&issue=52DDE6243FB32F58A3B0D46D4BEAC5BA"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1803",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ParameterParser.java line 335 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1803/?engineType=SCA&issue=E3F7FA445FC73DF499C6AFEC68297B99"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1683",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ParameterParser.java line 356 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1683/?engineType=SCA&issue=80A724A9D020652B8760D4E8E231BE77"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1796",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ParameterParser.java line 428 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1796/?engineType=SCA&issue=E01A48FB4FD50C871F401912AB854C59"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1666",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ParameterParser.java line 484 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1666/?engineType=SCA&issue=740A8235F59F66F7C610FBA1BF3186F7"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1711",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ParameterParser.java line 521 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1711/?engineType=SCA&issue=A12C31E20DFB8C2A5A81F7FE3F5B1DF8"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1563",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ParameterParser.java line 610 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1563/?engineType=SCA&issue=1CDC68976671DD5108A6F06DA34767BF"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1540",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method getRawParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to ParameterNotFoundException() in ParameterParser.java at line 631.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1540/?engineType=SCA&issue=0377CACDE1F4A610BEF25E9911551213"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1615",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method getRawParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to ParameterNotFoundException() in ParameterParser.java at line 631.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1615/?engineType=SCA&issue=4C152E7D555F91D3A6EAFEC6063DFA6B"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1623",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method getRawParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to ParameterNotFoundException() in ParameterParser.java at line 631.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1623/?engineType=SCA&issue=50934B47CAF8C39533054827417ABCDA"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1630",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method getRawParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to ParameterNotFoundException() in ParameterParser.java at line 631.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1630/?engineType=SCA&issue=57FA7046BC7D07B612A460B6E68E9B03"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1642",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method getRawParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to ParameterNotFoundException() in ParameterParser.java at line 631.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1642/?engineType=SCA&issue=69836F0C6868D3255303F4FBDCA94B26"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1753",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method getRawParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to ParameterNotFoundException() in ParameterParser.java at line 631.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1753/?engineType=SCA&issue=C1244A13CA3BF8F9BA502170CED62589"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1771",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method getRawParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to ParameterNotFoundException() in ParameterParser.java at line 631.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1771/?engineType=SCA&issue=CCF6FB905F08BCDAE1AD9CC2C1DAD709"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1544",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method getRawParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to ParameterNotFoundException() in ParameterParser.java at line 635.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1544/?engineType=SCA&issue=0C0D100B70B3A2BC5ABEB4C9B50E9312"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1558",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method getRawParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to ParameterNotFoundException() in ParameterParser.java at line 635.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1558/?engineType=SCA&issue=14A1B567247BF568D0D344ACA37916A4"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1564",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method getRawParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to ParameterNotFoundException() in ParameterParser.java at line 635.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1564/?engineType=SCA&issue=1D17CC1C85766D6D159A75DB22247288"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1598",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method getRawParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to ParameterNotFoundException() in ParameterParser.java at line 635.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1598/?engineType=SCA&issue=39BD5B82BDC59C2B5279E38B322D35F6"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1665",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method getRawParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to ParameterNotFoundException() in ParameterParser.java at line 635.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1665/?engineType=SCA&issue=74041EDF8320D2D6B8B66462C981A066"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1748",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method getRawParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to ParameterNotFoundException() in ParameterParser.java at line 635.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1748/?engineType=SCA&issue=BED13FB389450D63713AE49D474E2840"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1770",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method getRawParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to ParameterNotFoundException() in ParameterParser.java at line 635.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1770/?engineType=SCA&issue=CCCF2E26645D21ACE4F17192CB10D1D6"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1746",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ParameterParser.java line 672 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1746/?engineType=SCA&issue=BE70E7463930BF26AAF4E27EC47E9F79"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1571",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method getStringParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to ParameterNotFoundException() in ParameterParser.java at line 695.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1571/?engineType=SCA&issue=234F492B9FA93BEC5CB835B914E130C3"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1603",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method getStringParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to ParameterNotFoundException() in ParameterParser.java at line 695.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1603/?engineType=SCA&issue=3E0608F1FDEE4BB9F5EBA611961CA367"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1604",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method getStringParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to ParameterNotFoundException() in ParameterParser.java at line 695.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1604/?engineType=SCA&issue=3E10B89B5E2952BF0112AAF5A6B60C5C"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1610",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method getStringParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to ParameterNotFoundException() in ParameterParser.java at line 695.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1610/?engineType=SCA&issue=4663FD29543DC990B07C1AD5A92A1AD5"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1766",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method getStringParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to ParameterNotFoundException() in ParameterParser.java at line 695.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1766/?engineType=SCA&issue=CB29631933C8B9549C2F18F0A8BA7440"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1549",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method getStringParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to ParameterNotFoundException() in ParameterParser.java at line 699.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1549/?engineType=SCA&issue=0F9075FB829A58EDC38EE064182D0933"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1613",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method getStringParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to ParameterNotFoundException() in ParameterParser.java at line 699.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1613/?engineType=SCA&issue=486B21E65ED03BDE62D69C141662A3CD"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1644",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method getStringParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to ParameterNotFoundException() in ParameterParser.java at line 699.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1644/?engineType=SCA&issue=6A53F0B8A0211B3999F8E0DFAA5FA0C2"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1675",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method getStringParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to ParameterNotFoundException() in ParameterParser.java at line 699.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1675/?engineType=SCA&issue=7BE7D98946A7E8421C7A0322CF9FA691"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1737",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method getStringParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to ParameterNotFoundException() in ParameterParser.java at line 699.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1737/?engineType=SCA&issue=BA702E0AA648996AE8C3D20995234418"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1565",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ParameterParser.java line 731 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1565/?engineType=SCA&issue=1DF8D64FED6C5F59B7CFACAB117EFFBB"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1552",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ParameterParser.java line 752 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1552/?engineType=SCA&issue=107D5D46B5327212671D1CDE8DD190E7"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1761",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ParameterParser.java line 859 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1761/?engineType=SCA&issue=C6C902626308763F1CFA82F399CDD3E9"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1682",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at ParameterParser.java line 882 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1682/?engineType=SCA&issue=7FB1865C3542152C05F76E139A80A4DB"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1601",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at UserTracker.java line 133 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1601/?engineType=SCA&issue=3B2CBFD932D36A92199DC47C13DA9CD0"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1843",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method getAllUsers() in UserTracker.java ignores an exception on line 133, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1843/?engineType=SCA&issue=F9F54F32E40D2263C480BFDACBC06D4E"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1624",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at UserTracker.java line 161 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1624/?engineType=SCA&issue=5271617895250A2E580F5ECA4DB66EBA"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1733",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method deleteUser() in UserTracker.java ignores an exception on line 161, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1733/?engineType=SCA&issue=B7D5283FEEA8EDDE4F293D1ABEEFE6B1"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1105",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1105/?engineType=SCA&issue=401FDDB8941EABC2D0C09279338A72DB"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1278",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function WebSession() in WebSession.java might reveal system data or debugging information by calling println() on line 283.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1278/?engineType=SCA&issue=C7904A5B11FD09A0ECD5EAF045A3EA81"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1064",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getDatabaseConnectionString() in WebSession.java might reveal system data or debugging information by calling println() on line 439.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1064/?engineType=SCA&issue=1FB2CF819183512D88277250FA30C246"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1212",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1212/?engineType=SCA&issue=969986E45D1FEA078E32B58E5E84595D"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1213",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1213/?engineType=SCA&issue=969986E45D1FEA078E32B58E5E84595E"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1293",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getDatabaseConnectionString() in WebSession.java might reveal system data or debugging information by calling println() on line 441.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1293/?engineType=SCA&issue=D1BF871BD67B399815A6110FA943DC60"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1180",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at WebSession.java line 445 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1180/?engineType=SCA&issue=7BFDA23213F13C4DFA0DCDE812F9DF47"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1214",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1214/?engineType=SCA&issue=969986E45D1FEA078E32B58E5E84595F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1144",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function getDatabaseConnectionString() in WebSession.java might reveal system data or debugging information by calling printStackTrace() on line 448.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1144/?engineType=SCA&issue=5F643FA678E744ABB5F223B467A50363"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1262",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1262/?engineType=SCA&issue=BD7F96C92A07827F35E49DCFB8C9D8C5"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1290",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1290/?engineType=SCA&issue=D04EC036DB9FF599C02E3087AB9F1B07"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1345",
          "shortDescription" : {
            "text" : "Poor Error Handling: Empty Catch Block"
          },
          "fullDescription" : {
            "text" : "The method update() in WebSession.java ignores an exception on line 1027, which could cause the program to overlook unexpected states and conditions.\n\n\n"
          },
          "help" : {
            "text" : "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\n\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\n\nExample 1: The following code excerpt ignores a rarely-thrown exception from doExchange().\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n\n\nIf a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.\n\nAt a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception. \n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  throw RuntimeException(\"This can never happen\", e);\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1345/?engineType=SCA&issue=FA8A0C3A1898EAD80E9E3514FADABD65"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1349",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at WebSession.java line 1027 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1349/?engineType=SCA&issue=FC983A936500FBD36F907D60CBDB3FA5"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1291",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1291/?engineType=SCA&issue=D04EC036DB9FF599C02E3087AB9F1B08"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1168",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1168/?engineType=SCA&issue=7298F4FD0956AB4D64B7E4F6ABDF77E8"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1551",
          "shortDescription" : {
            "text" : "Unreleased Resource: Streams"
          },
          "fullDescription" : {
            "text" : "The function WebgoatProperties() in WebgoatProperties.java sometimes fails to release a system resource allocated by FileInputStream() on line 43.\n\n\n"
          },
          "help" : {
            "text" : "The program can potentially fail to release a system resource.\n\n    In this case, there are program paths on which the resource allocated in WebgoatProperties.java at line 43 is not released.\n\n\nResource leaks have at least two common causes:\n\n- Error conditions and other exceptional circumstances.\n\n- Confusion over which part of the program is responsible for releasing the resource.\n\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.\n\nExample 1: The following method never closes the file handle it opens. The finalize() method for FileInputStream eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n\n\nprivate void processFile(String fName) throws FileNotFoundException, IOException\n{\n  FileInputStream fis = new FileInputStream(fName);\n  int sz;\n  byte[] byteArray = new byte[BLOCK_SIZE];\n  while ((sz = fis.read(byteArray)) != -1) {\n    processBytes(byteArray, sz);\n  }\n}\n\n\nExample 2: Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.\n\n\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(CXN_SQL);\n  harvestResults(rs);\n  stmt.close();\n\n\n\n1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to \"bursty\" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.\n\nFinally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang. \n\n2. Release resources in a finally block. The code for Example 2 should be rewritten as follows:\n\n\n  public void execCxnSql(Connection conn) {\n    Statement stmt;\n    try {\n      stmt = conn.createStatement();\n      ResultSet rs = stmt.executeQuery(CXN_SQL);\n      ...\n    }\n    finally {\n      if (stmt != null) {\n        safeClose(stmt);\n      }\n    }\n}\n\npublic static void safeClose(Statement stmt) {\n  if (stmt != null) {\n    try {\n      stmt.close();\n    } catch (SQLException e) {\n      log(e);\n    }\n  }\n}\n\n\nThis solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. \n\nAlso, the execCxnSql method does not initialize the stmt object to null. Instead, it checks to ensure that stmt is not null before calling safeClose(). Without the null check, the Java compiler reports that stmt might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  stmt is initialized to null in a more complex method, cases in which stmt is used without being initialized will not be detected by the compiler. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1551/?engineType=SCA&issue=106C950FC6B8B677064B203028BDB065"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1622",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1622/?engineType=SCA&issue=507FB7849EF51D8DB486A5FCAB42291A"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1680",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1680/?engineType=SCA&issue=7F7F84EAD88E1BE410B4BA7DD7830C8C"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1649",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in WebgoatProperties.java might reveal system data or debugging information by calling printStackTrace() on line 122.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1649/?engineType=SCA&issue=6C9B74DBF9AFC6C9F7143AA58F624D58"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1681",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1681/?engineType=SCA&issue=7F7F84EAD88E1BE410B4BA7DD7830C8D"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1566",
          "shortDescription" : {
            "text" : "Command Injection"
          },
          "fullDescription" : {
            "text" : "The method execOptions() in Exec.java calls exec() with a command built from untrusted data. This call can cause the program to execute malicious commands on behalf of an attacker.\n\n\n"
          },
          "help" : {
            "text" : "Command injection vulnerabilities take two forms:\n\n- An attacker can change the command that the program executes: the attacker explicitly controls what the command is.\n\n- An attacker can change the environment in which the command executes: the attacker implicitly controls what the command means.\n\nIn this case we are primarily concerned with the first scenario, the possibility that an attacker may be able to control the command that is executed. Command injection vulnerabilities of this type occur when:\n\n1. Data enters the application from an untrusted source.\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627.\n\n2. The data is used as or as part of a string representing a command that is executed by the application. \n\nIn this case the command is executed by exec() in Exec.java at line 103.\n\n3. By executing the command, the application gives an attacker a privilege or capability that the attacker would not otherwise have. \n\nExample 1: The following code from a system utility uses the system property APPHOME to determine the directory in which it is installed and then executes an initialization script based on a relative path from the specified directory. \n\n\n\t...\n\tString home = System.getProperty(\"APPHOME\");\n\tString cmd = home + INITCMD; \n\tjava.lang.Runtime.getRuntime().exec(cmd);\n\t...\n\n\nThe code in Example 1 allows an attacker to execute arbitrary commands with the elevated privilege of the application by modifying the system property APPHOME to point to a different path containing a malicious version of INITCMD. Because the program does not validate the value read from the environment, if an attacker can control the value of the system property APPHOME, then they can fool the application into running malicious code and take control of the system.\n\nExample 2: The following code is from an administrative web application designed allow users to kick off a backup of an Oracle database using a batch-file wrapper around the rman utility and then run a cleanup.bat script to delete some temporary files. The script rmanDB.bat accepts a single command line parameter, which specifies what type of backup to perform. Because access to the database is restricted, the application runs the backup as a privileged user. \n\n\n...\nString btype = request.getParameter(\"backuptype\");\nString cmd = new String(\"cmd.exe /K \n\\\"c:\\\\util\\\\rmanDB.bat \"+btype+\"&amp;&amp;c:\\\\utl\\\\cleanup.bat\\\"\")\nSystem.Runtime.getRuntime().exec(cmd);\n...\n\n\nThe problem here is that the program does not do any validation on the backuptype parameter read from the user. Typically the Runtime.exec() function will not execute multiple commands, but in this case the program first runs the cmd.exe shell in order to run multiple commands with a single call to Runtime.exec(). Once the shell is invoked, it will happily execute multiple commands separated by two ampersands. If an attacker passes a string of the form \"&amp;&amp; del c:\\\\dbms\\\\*.*\", then the application will execute this command along with the others specified by the program. Because of the nature of the application, it runs with the privileges necessary to interact with the database, which means whatever command the attacker injects will run with those privileges as well. \n\nExample 3: The following code is from a web application that allows users access to an interface through which they can update their password on the system. Part of the process for updating passwords in certain network environments is to run a make command in the /var/yp directory, the code for which is shown below. \n\n\n...\nSystem.Runtime.getRuntime().exec(\"make\");\n...\n\n\nThe problem here is that the program does not specify an absolute path for make and fails to clean its environment prior to executing the call to Runtime.exec(). If an attacker can modify the $PATH variable to point to a malicious binary called make and cause the program to be executed in their environment, then the malicious binary will be loaded instead of the one intended. Because of the nature of the application, it runs with the privileges necessary to perform system operations, which means the attacker's make will now be run with these privileges, possibly giving the attacker complete control of the system.\n\nDo not allow users to have direct control over the commands executed by the program. In cases where user input must affect the command to be run, use the input only to make a selection from a predetermined set of safe commands. If the input appears to be malicious, the value passed to the command execution function should either default to some safe selection from this set or the program should decline to execute any command at all. \n\nIn cases where user input must be used as an argument to a command executed by the program, this approach often becomes impractical because the set of legitimate argument values is too large or too hard to keep track of. Developers often fall back on blacklisting in these situations. Blacklisting selectively rejects or escapes potentially dangerous characters before using the input. Any list of unsafe characters is likely to be incomplete and will be heavily dependant on the system where the commands are executed. A better approach is to create a white list of characters that are allowed to appear in the input and accept input composed exclusively of characters in the approved set.\n\nAn attacker can indirectly control commands executed by a program by modifying the environment in which they are executed. The environment should not be trusted and precautions should be taken to prevent an attacker from using some manipulation of the environment to perform an attack. Whenever possible, commands should be controlled by the application and executed using an absolute path. In cases where the path is not known at compile time, such as for cross-platform applications, an absolute path should be constructed from trusted values during execution. Command values and paths read from configuration files or the environment should be sanity-checked against a set of invariants that define valid values. \n\nOther checks can sometimes be performed to detect if these sources may have been tampered with. For example, if a configuration file is world-writable, the program might refuse to run. In cases where information about the binary to be executed is known in advance, the program may perform checks to verify the identity of the binary. If a binary should always be owned by a particular user or have a particular set of access permissions assigned to it, these properties can be verified programmatically before the binary is executed.\n\nAlthough it may be impossible to completely protect a program from an imaginative attacker bent on controlling the commands the program executes, be sure to apply the principle of least privilege wherever the program executes an external command: do not hold privileges that are not essential to the execution of the command.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1566/?engineType=SCA&issue=1EE43C8EBD079E2A1595DC2E202F0C99"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "336",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at Exec.java line 242 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/336/?engineType=SCA&issue=74B6FE7F53E88BA44158125257AF085B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "1567",
          "shortDescription" : {
            "text" : "Command Injection"
          },
          "fullDescription" : {
            "text" : "The method execOptions() in Exec.java calls exec() with a command built from untrusted data. This call can cause the program to execute malicious commands on behalf of an attacker.\n\n\n"
          },
          "help" : {
            "text" : "Command injection vulnerabilities take two forms:\n\n- An attacker can change the command that the program executes: the attacker explicitly controls what the command is.\n\n- An attacker can change the environment in which the command executes: the attacker implicitly controls what the command means.\n\nIn this case we are primarily concerned with the first scenario, the possibility that an attacker may be able to control the command that is executed. Command injection vulnerabilities of this type occur when:\n\n1. Data enters the application from an untrusted source.\n\nIn this case the data enters at getParameterValues() in ParameterParser.java at line 627.\n\n2. The data is used as or as part of a string representing a command that is executed by the application. \n\nIn this case the command is executed by exec() in Exec.java at line 292.\n\n3. By executing the command, the application gives an attacker a privilege or capability that the attacker would not otherwise have. \n\nExample 1: The following code from a system utility uses the system property APPHOME to determine the directory in which it is installed and then executes an initialization script based on a relative path from the specified directory. \n\n\n\t...\n\tString home = System.getProperty(\"APPHOME\");\n\tString cmd = home + INITCMD; \n\tjava.lang.Runtime.getRuntime().exec(cmd);\n\t...\n\n\nThe code in Example 1 allows an attacker to execute arbitrary commands with the elevated privilege of the application by modifying the system property APPHOME to point to a different path containing a malicious version of INITCMD. Because the program does not validate the value read from the environment, if an attacker can control the value of the system property APPHOME, then they can fool the application into running malicious code and take control of the system.\n\nExample 2: The following code is from an administrative web application designed allow users to kick off a backup of an Oracle database using a batch-file wrapper around the rman utility and then run a cleanup.bat script to delete some temporary files. The script rmanDB.bat accepts a single command line parameter, which specifies what type of backup to perform. Because access to the database is restricted, the application runs the backup as a privileged user. \n\n\n...\nString btype = request.getParameter(\"backuptype\");\nString cmd = new String(\"cmd.exe /K \n\\\"c:\\\\util\\\\rmanDB.bat \"+btype+\"&amp;&amp;c:\\\\utl\\\\cleanup.bat\\\"\")\nSystem.Runtime.getRuntime().exec(cmd);\n...\n\n\nThe problem here is that the program does not do any validation on the backuptype parameter read from the user. Typically the Runtime.exec() function will not execute multiple commands, but in this case the program first runs the cmd.exe shell in order to run multiple commands with a single call to Runtime.exec(). Once the shell is invoked, it will happily execute multiple commands separated by two ampersands. If an attacker passes a string of the form \"&amp;&amp; del c:\\\\dbms\\\\*.*\", then the application will execute this command along with the others specified by the program. Because of the nature of the application, it runs with the privileges necessary to interact with the database, which means whatever command the attacker injects will run with those privileges as well. \n\nExample 3: The following code is from a web application that allows users access to an interface through which they can update their password on the system. Part of the process for updating passwords in certain network environments is to run a make command in the /var/yp directory, the code for which is shown below. \n\n\n...\nSystem.Runtime.getRuntime().exec(\"make\");\n...\n\n\nThe problem here is that the program does not specify an absolute path for make and fails to clean its environment prior to executing the call to Runtime.exec(). If an attacker can modify the $PATH variable to point to a malicious binary called make and cause the program to be executed in their environment, then the malicious binary will be loaded instead of the one intended. Because of the nature of the application, it runs with the privileges necessary to perform system operations, which means the attacker's make will now be run with these privileges, possibly giving the attacker complete control of the system.\n\nDo not allow users to have direct control over the commands executed by the program. In cases where user input must affect the command to be run, use the input only to make a selection from a predetermined set of safe commands. If the input appears to be malicious, the value passed to the command execution function should either default to some safe selection from this set or the program should decline to execute any command at all. \n\nIn cases where user input must be used as an argument to a command executed by the program, this approach often becomes impractical because the set of legitimate argument values is too large or too hard to keep track of. Developers often fall back on blacklisting in these situations. Blacklisting selectively rejects or escapes potentially dangerous characters before using the input. Any list of unsafe characters is likely to be incomplete and will be heavily dependant on the system where the commands are executed. A better approach is to create a white list of characters that are allowed to appear in the input and accept input composed exclusively of characters in the approved set.\n\nAn attacker can indirectly control commands executed by a program by modifying the environment in which they are executed. The environment should not be trusted and precautions should be taken to prevent an attacker from using some manipulation of the environment to perform an attack. Whenever possible, commands should be controlled by the application and executed using an absolute path. In cases where the path is not known at compile time, such as for cross-platform applications, an absolute path should be constructed from trusted values during execution. Command values and paths read from configuration files or the environment should be sanity-checked against a set of invariants that define valid values. \n\nOther checks can sometimes be performed to detect if these sources may have been tampered with. For example, if a configuration file is world-writable, the program might refuse to run. In cases where information about the binary to be executed is known in advance, the program may perform checks to verify the identity of the binary. If a binary should always be owned by a particular user or have a particular set of access permissions assigned to it, these properties can be verified programmatically before the binary is executed.\n\nAlthough it may be impossible to completely protect a program from an imaginative attacker bent on controlling the commands the program executes, be sure to apply the principle of least privilege wherever the program executes an external command: do not hold privileges that are not essential to the execution of the command.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1567/?engineType=SCA&issue=1EE43C8EBD079E2A1595DC2E202F0C9A"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "662",
          "shortDescription" : {
            "text" : "Poor Error Handling: Overly Broad Catch"
          },
          "fullDescription" : {
            "text" : "The catch block at Exec.java line 431 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
          },
          "help" : {
            "text" : "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\n\nExample: The following code excerpt handles three types of exceptions in an identical fashion.\n\n\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\n\n\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n\n\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n\nDo not catch broad exception classes like Exception, Throwable, Error, or &lt;RuntimeException&gt; except at the very top level of the program or thread.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/662/?engineType=SCA&issue=EDFA3F9BD1D1F3E8EDF285A937CF99B4"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "675",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/675/?engineType=SCA&issue=F3C745B5FF30BF594AB3FB9613BFE4B9"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "10",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 509.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/10/?engineType=SCA&issue=07DC81F1724D3DD1F052EE4103383C30"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "57",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 509.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/57/?engineType=SCA&issue=159D205600BB0BD92FC54008D21A504B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "99",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 509.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/99/?engineType=SCA&issue=22527F24D3F8FE925A856B7C8B72C8B2"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "512",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 509.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/512/?engineType=SCA&issue=AFC420B674CFEFCF5942C21091567532"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "676",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/676/?engineType=SCA&issue=F3C745B5FF30BF594AB3FB9613BFE4BA"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "697",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 509.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/697/?engineType=SCA&issue=F82BAB3CD0F3C4174E4E45AD5A4AC744"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "677",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/677/?engineType=SCA&issue=F3C745B5FF30BF594AB3FB9613BFE4BB"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "11",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 513.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/11/?engineType=SCA&issue=07DC81F1724D3DD1F052EE4103383C31"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "58",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 513.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/58/?engineType=SCA&issue=159D205600BB0BD92FC54008D21A504C"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "100",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 513.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/100/?engineType=SCA&issue=22527F24D3F8FE925A856B7C8B72C8B3"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "513",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 513.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/513/?engineType=SCA&issue=AFC420B674CFEFCF5942C21091567533"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "678",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/678/?engineType=SCA&issue=F3C745B5FF30BF594AB3FB9613BFE4BC"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "698",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 513.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/698/?engineType=SCA&issue=F82BAB3CD0F3C4174E4E45AD5A4AC745"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "679",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/679/?engineType=SCA&issue=F3C745B5FF30BF594AB3FB9613BFE4BD"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "680",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/680/?engineType=SCA&issue=F3C745B5FF30BF594AB3FB9613BFE4BE"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "12",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 524.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/12/?engineType=SCA&issue=07DC81F1724D3DD1F052EE4103383C32"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "59",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 524.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/59/?engineType=SCA&issue=159D205600BB0BD92FC54008D21A504D"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "101",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 524.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/101/?engineType=SCA&issue=22527F24D3F8FE925A856B7C8B72C8B4"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "514",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 524.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/514/?engineType=SCA&issue=AFC420B674CFEFCF5942C21091567534"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "681",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/681/?engineType=SCA&issue=F3C745B5FF30BF594AB3FB9613BFE4BF"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "699",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 524.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/699/?engineType=SCA&issue=F82BAB3CD0F3C4174E4E45AD5A4AC746"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "682",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/682/?engineType=SCA&issue=F3C745B5FF30BF594AB3FB9613BFE4C0"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "13",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 528.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/13/?engineType=SCA&issue=07DC81F1724D3DD1F052EE4103383C33"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "60",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 528.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/60/?engineType=SCA&issue=159D205600BB0BD92FC54008D21A504E"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "102",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 528.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/102/?engineType=SCA&issue=22527F24D3F8FE925A856B7C8B72C8B5"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "515",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 528.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/515/?engineType=SCA&issue=AFC420B674CFEFCF5942C21091567535"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "683",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/683/?engineType=SCA&issue=F3C745B5FF30BF594AB3FB9613BFE4C1"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "700",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 528.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/700/?engineType=SCA&issue=F82BAB3CD0F3C4174E4E45AD5A4AC747"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "684",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/684/?engineType=SCA&issue=F3C745B5FF30BF594AB3FB9613BFE4C2"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "14",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 532.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/14/?engineType=SCA&issue=07DC81F1724D3DD1F052EE4103383C34"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "61",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 532.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/61/?engineType=SCA&issue=159D205600BB0BD92FC54008D21A504F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "103",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 532.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/103/?engineType=SCA&issue=22527F24D3F8FE925A856B7C8B72C8B6"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "516",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 532.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/516/?engineType=SCA&issue=AFC420B674CFEFCF5942C21091567536"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "685",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/685/?engineType=SCA&issue=F3C745B5FF30BF594AB3FB9613BFE4C3"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "701",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 532.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/701/?engineType=SCA&issue=F82BAB3CD0F3C4174E4E45AD5A4AC748"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "686",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/686/?engineType=SCA&issue=F3C745B5FF30BF594AB3FB9613BFE4C4"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "15",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 536.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/15/?engineType=SCA&issue=07DC81F1724D3DD1F052EE4103383C35"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "62",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 536.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/62/?engineType=SCA&issue=159D205600BB0BD92FC54008D21A5050"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "104",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 536.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/104/?engineType=SCA&issue=22527F24D3F8FE925A856B7C8B72C8B7"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "517",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 536.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/517/?engineType=SCA&issue=AFC420B674CFEFCF5942C21091567537"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "687",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/687/?engineType=SCA&issue=F3C745B5FF30BF594AB3FB9613BFE4C5"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "702",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 536.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/702/?engineType=SCA&issue=F82BAB3CD0F3C4174E4E45AD5A4AC749"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "688",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/688/?engineType=SCA&issue=F3C745B5FF30BF594AB3FB9613BFE4C6"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "16",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 540.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/16/?engineType=SCA&issue=07DC81F1724D3DD1F052EE4103383C36"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "63",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 540.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/63/?engineType=SCA&issue=159D205600BB0BD92FC54008D21A5051"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "105",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 540.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/105/?engineType=SCA&issue=22527F24D3F8FE925A856B7C8B72C8B8"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "518",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 540.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/518/?engineType=SCA&issue=AFC420B674CFEFCF5942C21091567538"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "689",
          "shortDescription" : {
            "text" : "Poor Logging Practice: Use of a System Output Stream"
          },
          "fullDescription" : {
            "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
          },
          "help" : {
            "text" : "Example 1: The first Java program that a developer learns to write often looks like this:\n\n\npublic class MyClass \n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n\n\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().\n\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\n\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.\n\nUse a Java logging facility rather than System.out or System.err. \n\nExample 2: For example, the \"hello world\" program above can be re-written using log4j like this:\n\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class MyClass {\n  private final static Logger logger =     \n            Logger.getLogger(MyClass.class);\n\n  public static void main(String[] args) {\n    BasicConfigurator.configure();\n    logger.info(\"hello world\");\n  }\n}\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/689/?engineType=SCA&issue=F3C745B5FF30BF594AB3FB9613BFE4C7"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "703",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 540.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/703/?engineType=SCA&issue=F82BAB3CD0F3C4174E4E45AD5A4AC74A"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "572",
          "shortDescription" : {
            "text" : "Resource Injection"
          },
          "fullDescription" : {
            "text" : "Attackers can control the resource identifier argument to Socket() at Interceptor.java line 93, which could enable them to access or modify otherwise protected system resources.\n\n\n"
          },
          "help" : {
            "text" : "A resource injection issue occurs when the following two conditions are met:\n    \n1. An attacker can specify the identifier used to access a system resource. \n\nFor example, an attacker might be able to specify a port number to be used to connect to a network resource. \n\n2. By specifying the resource, the attacker gains a capability that would not otherwise be permitted.\n\nFor example, the program may give the attacker the ability to transmit sensitive information to a third-party server. \n\n\nIn this case, the attacker can specify the value that enters the program at getInitParameter() in Interceptor.java at line 83, and this value is used to access a system resource at Socket() in Interceptor.java at line 93.\n\n\nNote: Resource injection that involves resources stored on the filesystem goes by the name path manipulation and is reported in separate category. See the path manipulation description for further details of this vulnerability. \n\nExample: The following code uses a port number read from an HTTP request to create a socket.  \n\n\nString remotePort = request.getParameter(\"remotePort\");\n...\nServerSocket srvr = new ServerSocket(remotePort);\nSocket skt = srvr.accept(); \n...\n\n\nThe kind of resource affected by user input indicates the kind of content that may be dangerous.  For example, data containing special characters like period, slash, and backslash are risky when used in methods that interact with the file system. Similarly, data that contains URLs and URIs is risky for functions that create remote connections.\n\n\nThe best way to prevent resource injection is with a level of indirection: create a list of legitimate resource names that a user is allowed to specify, and only allow the user to select from the list. With this approach the input provided by the user is never used directly to specify the resource name. \n\nIn some situations this approach is impractical because the set of legitimate resource names is too large or too hard to keep track of. Programmers often resort to blacklisting in these situations. Blacklisting selectively rejects or escapes potentially dangerous characters before using the input. However, any such list of unsafe characters is likely to be incomplete and will almost certainly become out of date. A better approach is to create a white list of characters that are allowed to appear in the resource name and accept input composed exclusively of characters in the approved set.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/572/?engineType=SCA&issue=C41ED2B38B12CC87733F9860635B3D57"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "94",
          "shortDescription" : {
            "text" : "Resource Injection"
          },
          "fullDescription" : {
            "text" : "Attackers can control the resource identifier argument to Socket() at Interceptor.java line 94, which could enable them to access or modify otherwise protected system resources.\n\n\n"
          },
          "help" : {
            "text" : "A resource injection issue occurs when the following two conditions are met:\n    \n1. An attacker can specify the identifier used to access a system resource. \n\nFor example, an attacker might be able to specify a port number to be used to connect to a network resource. \n\n2. By specifying the resource, the attacker gains a capability that would not otherwise be permitted.\n\nFor example, the program may give the attacker the ability to transmit sensitive information to a third-party server. \n\n\nIn this case, the attacker can specify the value that enters the program at getInitParameter() in Interceptor.java at line 85, and this value is used to access a system resource at Socket() in Interceptor.java at line 94.\n\n\nNote: Resource injection that involves resources stored on the filesystem goes by the name path manipulation and is reported in separate category. See the path manipulation description for further details of this vulnerability. \n\nExample: The following code uses a port number read from an HTTP request to create a socket.  \n\n\nString remotePort = request.getParameter(\"remotePort\");\n...\nServerSocket srvr = new ServerSocket(remotePort);\nSocket skt = srvr.accept(); \n...\n\n\nThe kind of resource affected by user input indicates the kind of content that may be dangerous.  For example, data containing special characters like period, slash, and backslash are risky when used in methods that interact with the file system. Similarly, data that contains URLs and URIs is risky for functions that create remote connections.\n\n\nThe best way to prevent resource injection is with a level of indirection: create a list of legitimate resource names that a user is allowed to specify, and only allow the user to select from the list. With this approach the input provided by the user is never used directly to specify the resource name. \n\nIn some situations this approach is impractical because the set of legitimate resource names is too large or too hard to keep track of. Programmers often resort to blacklisting in these situations. Blacklisting selectively rejects or escapes potentially dangerous characters before using the input. However, any such list of unsafe characters is likely to be incomplete and will almost certainly become out of date. A better approach is to create a white list of characters that are allowed to appear in the resource name and accept input composed exclusively of characters in the approved set.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/94/?engineType=SCA&issue=1EC821B90272EDDCE494AE29582A4CF2"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "235",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function doFilter() in Interceptor.java might reveal system data or debugging information by calling printStackTrace() on line 110.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/235/?engineType=SCA&issue=4D29817A94B639966ABCDE67289F0FAB"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "234",
          "shortDescription" : {
            "text" : "System Information Leak"
          },
          "fullDescription" : {
            "text" : "The function doFilter() in Interceptor.java might reveal system data or debugging information by calling printStackTrace() on line 115.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
          },
          "help" : {
            "text" : "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\n\n\n\nExample: The following code prints an exception to the standard error stream:\n\n\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/234/?engineType=SCA&issue=4D29817A94B639966ABCDE67289F0FAA"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "69",
          "shortDescription" : {
            "text" : "Poor Error Handling: Throw Inside Finally"
          },
          "fullDescription" : {
            "text" : "Using a <code>throw</code> statement inside a <code>finally</code> block breaks the logical progression through the <code>try-catch-finally</code>.\n\n\n"
          },
          "help" : {
            "text" : "In Java, finally blocks are always executed after their corresponding try-catch blocks and are often used to free allocated resources, such as file handles or database cursors. Throwing an exception in a finally block can bypass critical cleanup code since normal program execution will be disrupted. \n                \nExample 1: In the following code, the call to stmt.close() is bypassed when the FileNotFoundException is thrown.\n\npublic void processTransaction(Connection conn) throws FileNotFoundException\n{\n\tFileInputStream fis = null;\n\tStatement stmt = null;\n\ttry\n\t{\n\t\tstmt = conn.createStatement();\n\t\tfis = new FileInputStream(\"badFile.txt\");\n\t\t...\n\t}\n\tcatch (FileNotFoundException fe)\n\t{\n\t\tlog(\"File not found.\");\n\t}\n\tcatch (SQLException se)\n\t{\n\t\t//handle error\n\t}\n\tfinally\n\t{\n\t\tif (fis == null)\n\t\t{\n\t\t\tthrow new FileNotFoundException();\n\t\t}\n\n\t\tif (stmt != null)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tstmt.close();\n\t\t\t}\n\t\t\tcatch (SQLException e)\n\t\t\t{\n\t\t\t\tlog(e);\n\t\t\t}\n\t\t}\n\t}\n}\n\nThis category is from the Cigital Java Rulepack. http://www.cigital.com/securitypack/\n\nNever throw exceptions from within finally blocks. If you must re-throw an exception, do it inside a catch block so as not to interupt the normal execution of the finally block.\nExample 2: The following code re-throws the FileNotFoundException in the catch block.\n\npublic void processTransaction(Connection conn) throws FileNotFoundException\n{\n\tFileInputStream fis = null;\n\tStatement stmt = null;\n\ttry\n\t{\n\t\tstmt = conn.createStatement();\n\t\tfis = new FileInputStream(\"badFile.txt\");\n\t\t...\n\t}\n\tcatch (FileNotFoundException fe)\n\t{\n\t\tlog(\"File not found.\");\n\t\tthrow fe;\n\t}\n\tcatch (SQLException se)\n\t{\n\t\t//handle error\n\t}\n\tfinally\n\t{\n\t\tif (fis == null)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tfis.close();\n\t\t\t}\n\t\t\tcatch (IOException ie)\n\t\t\t{\n\t\t\t\tlog(ie);\n\t\t\t}\t\t\t\n\t\t}\n\n\t\tif (stmt != null)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tstmt.close();\n\t\t\t}\n\t\t\tcatch (SQLException e)\n\t\t\t{\n\t\t\t\tlog(e);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t            \n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/69/?engineType=SCA&issue=17E77BB9D3B68EEDFB3FFF3FE10B4377"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "290",
          "shortDescription" : {
            "text" : "Password Management: Password in Configuration File"
          },
          "fullDescription" : {
            "text" : "Storing a plaintext password in a configuration file could result in a system compromise.\n\n\n"
          },
          "help" : {
            "text" : "Storing a plaintext password in a configuration file allows anyone who can read the file access to the password-protected resource. Developers sometimes believe that they cannot defend the application from someone who has access to the configuration, but this attitude makes an attacker's job easier. Good password management guidelines require that a password never be stored in plaintext. \n\nA password should never be stored in plaintext. Instead, the password should be entered by an administrator when the system starts. If that approach is impractical, a less secure but often adequate solution is to obfuscate the password and scatter the de-obfuscation material around the system so that an attacker has to obtain and correctly combine multiple system resources to decipher the password.\n\nSome third party products claim the ability to manage passwords in a more secure way. For example, WebSphere Application Server 4.x uses a simple XOR encryption algorithm for obfuscating values, but be skeptical about such facilities. WebSphere and other application servers offer outdated and relatively weak encryption mechanisms that are insufficient for security-sensitive environments. For a secure solution the only viable option is a proprietary one. \n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/290/?engineType=SCA&issue=5E0FC7EC055048EF51BDE8974450F9CA"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "390",
          "shortDescription" : {
            "text" : "J2EE Misconfiguration: Missing Error Handling"
          },
          "fullDescription" : {
            "text" : "A web application must define default error pages in order to prevent attackers from mining information from the application container's built-in error response.\n\n\n"
          },
          "help" : {
            "text" : "When an attacker explores a web site looking for vulnerabilities, the amount of information that the site provides is crucial to the eventual success or failure of any attempted attacks. If the application shows the attacker a stack trace, it relinquishes information that makes the attacker's job significantly easier. For example, a stack trace might show the attacker a malformed SQL query string, the type of database being used, and the version of the application container. This information enables the attacker to target known vulnerabilities in these components.\n\nThe application configuration should specify a default error page in order to guarantee that the application will never leak error messages to an attacker. Handling standard HTTP error codes is useful and user-friendly in addition to being a good security practice, and a good configuration will also define a last-chance error handler that catches any exception that could possibly be thrown by the application.\n\nA web application must be configured with a default error page. Your web.xml should include at least the following entries:\n\n\n&lt;error-page&gt;\n   &lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt;\n&lt;location&gt;/error.jsp&lt;/location&gt;\n&lt;/error-page&gt;\n&lt;error-page&gt;\n   &lt;error-code&gt;404&lt;/error-code&gt;\n&lt;location&gt;/error.jsp&lt;/location&gt;\n&lt;/error-page&gt;\n&lt;error-page&gt;\n   &lt;error-code&gt;500&lt;/error-code&gt;\n&lt;location&gt;/error.jsp&lt;/location&gt;\n&lt;/error-page&gt;\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/390/?engineType=SCA&issue=88F4D7D5D6180F7BCFE26DFEB49ADCA4"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "478",
          "shortDescription" : {
            "text" : "J2EE Misconfiguration: Missing Error Handling"
          },
          "fullDescription" : {
            "text" : "A web application must define default error pages in order to prevent attackers from mining information from the application container's built-in error response.\n\n\n"
          },
          "help" : {
            "text" : "When an attacker explores a web site looking for vulnerabilities, the amount of information that the site provides is crucial to the eventual success or failure of any attempted attacks. If the application shows the attacker a stack trace, it relinquishes information that makes the attacker's job significantly easier. For example, a stack trace might show the attacker a malformed SQL query string, the type of database being used, and the version of the application container. This information enables the attacker to target known vulnerabilities in these components.\n\nThe application configuration should specify a default error page in order to guarantee that the application will never leak error messages to an attacker. Handling standard HTTP error codes is useful and user-friendly in addition to being a good security practice, and a good configuration will also define a last-chance error handler that catches any exception that could possibly be thrown by the application.\n\nA web application must be configured with a default error page. Your web.xml should include at least the following entries:\n\n\n&lt;error-page&gt;\n   &lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt;\n&lt;location&gt;/error.jsp&lt;/location&gt;\n&lt;/error-page&gt;\n&lt;error-page&gt;\n   &lt;error-code&gt;404&lt;/error-code&gt;\n&lt;location&gt;/error.jsp&lt;/location&gt;\n&lt;/error-page&gt;\n&lt;error-page&gt;\n   &lt;error-code&gt;500&lt;/error-code&gt;\n&lt;location&gt;/error.jsp&lt;/location&gt;\n&lt;/error-page&gt;\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/478/?engineType=SCA&issue=A4F1C9B64A6151C8466143432EBAA61B"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "178",
          "shortDescription" : {
            "text" : "J2EE Misconfiguration: Missing Error Handling"
          },
          "fullDescription" : {
            "text" : "A web application must define default error pages in order to prevent attackers from mining information from the application container's built-in error response.\n\n\n"
          },
          "help" : {
            "text" : "When an attacker explores a web site looking for vulnerabilities, the amount of information that the site provides is crucial to the eventual success or failure of any attempted attacks. If the application shows the attacker a stack trace, it relinquishes information that makes the attacker's job significantly easier. For example, a stack trace might show the attacker a malformed SQL query string, the type of database being used, and the version of the application container. This information enables the attacker to target known vulnerabilities in these components.\n\nThe application configuration should specify a default error page in order to guarantee that the application will never leak error messages to an attacker. Handling standard HTTP error codes is useful and user-friendly in addition to being a good security practice, and a good configuration will also define a last-chance error handler that catches any exception that could possibly be thrown by the application.\n\nA web application must be configured with a default error page. Your web.xml should include at least the following entries:\n\n\n&lt;error-page&gt;\n   &lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt;\n&lt;location&gt;/error.jsp&lt;/location&gt;\n&lt;/error-page&gt;\n&lt;error-page&gt;\n   &lt;error-code&gt;404&lt;/error-code&gt;\n&lt;location&gt;/error.jsp&lt;/location&gt;\n&lt;/error-page&gt;\n&lt;error-page&gt;\n   &lt;error-code&gt;500&lt;/error-code&gt;\n&lt;location&gt;/error.jsp&lt;/location&gt;\n&lt;/error-page&gt;\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/178/?engineType=SCA&issue=399A248E35AE0FBB04255DE45FA9754C"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "570",
          "shortDescription" : {
            "text" : "J2EE Misconfiguration: Excessive Session Timeout"
          },
          "fullDescription" : {
            "text" : "An overly long session timeout gives attackers more time to potentially compromise user accounts.\n\n\n"
          },
          "help" : {
            "text" : "The longer a session stays open, the larger the window of opportunity an attacker has to compromise user accounts. While a session remains active, an attacker might be able to brute force a user's password, crack a user's wireless encryption key, or commandeer a session from an open browser. Longer session timeouts can also prevent memory from being released and eventually result in a denial of service if a sufficiently large number of sessions are created.\n\nExample 1: If the session timeout is zero or less than zero, the session never expires. The following example shows a session timeout set to -1, which will cause the session to remain active indefinitely.\n\n&lt;session-config&gt;\n    &lt;session-timeout&gt;-1&lt;/session-timeout&gt;\n&lt;/session-config&gt;\n\n\nThe &lt;session-timeout&gt; tag defines the default session timeout interval for all sessions in the web application. If the &lt;session-timeout&gt; tag is missing, it is left to the container to set the default timeout.\n\n            \nThis category is from the Cigital Java Rulepack. http://www.cigital.com/securitypack/\n\nSet a session timeout that is 30 minutes or less, which both allows users to interact with the application over a period of time and provides a reasonable bound for the window of attack.\n\nExample 2: The following example sets the session timeout to 20 minutes.\n\n&lt;session-config&gt;\n  &lt;session-timeout&gt;20&lt;/session-timeout&gt;\n&lt;/session-config&gt;\n\n            \n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/570/?engineType=SCA&issue=C2F39B963AB1AFACD8D57325EEAF747F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "220",
          "shortDescription" : {
            "text" : "J2EE Misconfiguration: Missing Data Transport Constraint"
          },
          "fullDescription" : {
            "text" : "A security constraint that does not specify a user data constraint cannot guarantee that restricted resources will be protected at the transport layer.\n\n\n"
          },
          "help" : {
            "text" : "web.xml security constraints are typically used for role based access control, but the optional user-data-constraint element specifies a transport guarantee that prevents content from being transmitted insecurely.\n\nWithin the &lt;user-data-constraint&gt; tag, the &lt;transport-guarantee&gt; tag defines how communication should be handled. There are three levels of transport guarantee:\n\n1) NONE means that the application does not require any transport guarantees.\n2) INTEGRAL means that the application requires that data sent between the client and server be sent in such a way that it cant be changed in transit.\n3) CONFIDENTIAL means that the application requires that data be transmitted in a fashion that prevents other entities from observing the contents of the transmission.\n\nIn this case, the security constraint defined at line 274 in web.xml does not specify a transport guarantee.\n\nIn most circumstances, the use of INTEGRAL or CONFIDENTIAL means that SSL/TLS is required. If the &lt;user-data-constraint&gt; and &lt;transport-guarantee&gt; tags are omitted, the transport guarantee defaults to NONE.\n\nExample 1: The following security constraint does not specify a transport guarantee.\n\n&lt;security-constraint&gt;\n    &lt;web-resource-collection&gt;\n        &lt;web-resource-name&gt;Storefront&lt;/web-resource-name&gt;\n        &lt;description&gt;Allow Customers and Employees access to online store front&lt;/description&gt;\n        &lt;url-pattern&gt;/store/shop/*&lt;/url-pattern&gt;\n    &lt;/web-resource-collection&gt;\n    &lt;auth-constraint&gt;\n        &lt;description&gt;Anyone&lt;/description&gt;\n        &lt;role-name&gt;anyone&lt;/role-name&gt;\n    &lt;/auth-constraint&gt;\n&lt;/security-constraint&gt;\n\n            \nThis category is from the Cigital Java Rulepack. http://www.cigital.com/securitypack/\n\nSpecify a CONFIDENTIAL transport guarantee whenever you define a authorization constraint. Once you decide to encrypt traffic to any part of your application, do not make the mistake of allowing unencrypted traffic to other parts of the application, which could allow session cookies or other sensitive information to be transmitted over insecure channels. \n\nExample 2: The following security constraint specifies a CONFIDENTIAL transport guarantee.\n\n&lt;security-constraint&gt;\n    &lt;web-resource-collection&gt;\n        &lt;web-resource-name&gt;Storefront&lt;/web-resource-name&gt;\n        &lt;description&gt;Allow Customers and Employees access to online store front&lt;/description&gt;\n        &lt;url-pattern&gt;/store/shop/*&lt;/url-pattern&gt;\n    &lt;/web-resource-collection&gt;\n    &lt;auth-constraint&gt;\n        &lt;description&gt;Anyone&lt;/description&gt;\n        &lt;role-name&gt;anyone&lt;/role-name&gt;\n    &lt;/auth-constraint&gt;\n    &lt;user-data-constraint&gt;\n        &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;\n    &lt;/user-data-constraint&gt;\n&lt;/security-constraint&gt;\n\n            \n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/220/?engineType=SCA&issue=4745492F4C56918DB027E1B7D27069F8"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "221",
          "shortDescription" : {
            "text" : "J2EE Misconfiguration: Missing Data Transport Constraint"
          },
          "fullDescription" : {
            "text" : "A security constraint that does not specify a user data constraint cannot guarantee that restricted resources will be protected at the transport layer.\n\n\n"
          },
          "help" : {
            "text" : "web.xml security constraints are typically used for role based access control, but the optional user-data-constraint element specifies a transport guarantee that prevents content from being transmitted insecurely.\n\nWithin the &lt;user-data-constraint&gt; tag, the &lt;transport-guarantee&gt; tag defines how communication should be handled. There are three levels of transport guarantee:\n\n1) NONE means that the application does not require any transport guarantees.\n2) INTEGRAL means that the application requires that data sent between the client and server be sent in such a way that it cant be changed in transit.\n3) CONFIDENTIAL means that the application requires that data be transmitted in a fashion that prevents other entities from observing the contents of the transmission.\n\nIn this case, the security constraint defined at line 286 in web.xml does not specify a transport guarantee.\n\nIn most circumstances, the use of INTEGRAL or CONFIDENTIAL means that SSL/TLS is required. If the &lt;user-data-constraint&gt; and &lt;transport-guarantee&gt; tags are omitted, the transport guarantee defaults to NONE.\n\nExample 1: The following security constraint does not specify a transport guarantee.\n\n&lt;security-constraint&gt;\n    &lt;web-resource-collection&gt;\n        &lt;web-resource-name&gt;Storefront&lt;/web-resource-name&gt;\n        &lt;description&gt;Allow Customers and Employees access to online store front&lt;/description&gt;\n        &lt;url-pattern&gt;/store/shop/*&lt;/url-pattern&gt;\n    &lt;/web-resource-collection&gt;\n    &lt;auth-constraint&gt;\n        &lt;description&gt;Anyone&lt;/description&gt;\n        &lt;role-name&gt;anyone&lt;/role-name&gt;\n    &lt;/auth-constraint&gt;\n&lt;/security-constraint&gt;\n\n            \nThis category is from the Cigital Java Rulepack. http://www.cigital.com/securitypack/\n\nSpecify a CONFIDENTIAL transport guarantee whenever you define a authorization constraint. Once you decide to encrypt traffic to any part of your application, do not make the mistake of allowing unencrypted traffic to other parts of the application, which could allow session cookies or other sensitive information to be transmitted over insecure channels. \n\nExample 2: The following security constraint specifies a CONFIDENTIAL transport guarantee.\n\n&lt;security-constraint&gt;\n    &lt;web-resource-collection&gt;\n        &lt;web-resource-name&gt;Storefront&lt;/web-resource-name&gt;\n        &lt;description&gt;Allow Customers and Employees access to online store front&lt;/description&gt;\n        &lt;url-pattern&gt;/store/shop/*&lt;/url-pattern&gt;\n    &lt;/web-resource-collection&gt;\n    &lt;auth-constraint&gt;\n        &lt;description&gt;Anyone&lt;/description&gt;\n        &lt;role-name&gt;anyone&lt;/role-name&gt;\n    &lt;/auth-constraint&gt;\n    &lt;user-data-constraint&gt;\n        &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;\n    &lt;/user-data-constraint&gt;\n&lt;/security-constraint&gt;\n\n            \n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/221/?engineType=SCA&issue=4745492F4C56918DB027E1B7D27069F9"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "157",
          "shortDescription" : {
            "text" : "Header Manipulation"
          },
          "fullDescription" : {
            "text" : "The method _jspService() in config.jsp includes unvalidated data in an HTTP response header on line 12.  This enables attacks such as cache-poisoning, cross-site scripting, cross-user defacement, page hijacking, cookie manipulation or open redirect.\n\n\n"
          },
          "help" : {
            "text" : "Header Manipulation vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source, most frequently an HTTP request.\n\nIn this case the data enters at getParameter() in config.jsp at line 12. \n\n2. The data is included in an HTTP response header sent to a web user without being validated.\n\nIn this case the data is sent at sendRedirect() in config.jsp at line 12.\n\nAs with many software security vulnerabilities, Header Manipulation is a means to an end, not an end in itself. At its root, the vulnerability is straightforward: an attacker passes malicious data to a vulnerable application, and the application includes the data in an HTTP response header.\n\nOne of the most common Header Manipulation attacks is HTTP Response Splitting. To mount a successful Http Response Splitting exploit, the application must allow input that contains CR (carriage return, also given by %0d or \\r) and LF (line feed, also given by %0a or \n)characters into the header. These characters not only give attackers control of the remaining headers and body of the response the application intends to send, but also allows them to create additional responses entirely under their control.\n\nExample: The following code segment reads the name of the author of a weblog entry, author, from an HTTP request and sets it in a cookie header of an HTTP response. \n\n\nString author = request.getParameter(AUTHOR_PARAM);\n...\nCookie cookie = new Cookie(\"author\", author);\n     cookie.setMaxAge(cookieExpiration);\n     response.addCookie(cookie);\n\n\nAssuming a string consisting of standard alpha-numeric characters, such as \"Jane Smith\", is submitted in the request the HTTP response including this cookie might take the following form:\n\n\nHTTP/1.1 200 OK\n...\nSet-Cookie: author=Jane Smith\n...\n\n\nHowever, because the value of the cookie is formed of unvalidated user input the response will only maintain this form if the value submitted for AUTHOR_PARAM does not contain any CR and LF characters. If an attacker submits a malicious string, such as \"Wiley Hacker\\r\nHTTP/1.1 200 OK\\r\n...\", then the HTTP response would be split into two responses of the following form:\n\n\nHTTP/1.1 200 OK\n...\nSet-Cookie: author=Wiley Hacker\n\nHTTP/1.1 200 OK\n...\n\n\nClearly, the second response is completely controlled by the attacker and can be constructed with any header and body content desired. The ability of attacker to construct arbitrary HTTP responses permits a variety of resulting attacks, including: cross-user defacement, web and browser cache poisoning, cross-site scripting and page hijacking. \n\nCross-User Defacement: An attacker can make a single request to a vulnerable server that will cause the server to create two responses, the second of which may be misinterpreted as a response to a different request, possibly one made by another user sharing the same TCP connection with the server. This can be accomplished by convincing the user to submit the malicious request themselves, or remotely in situations where the attacker and the user share a common TCP connection to the server, such as a shared proxy server. In the best case, an attacker can leverage this ability to convince users that the application has been hacked, causing users to lose confidence in the security of the application. In the worst case, an attacker may provide specially crafted content designed to mimic the behavior of the application but redirect private information, such as account numbers and passwords, back to the attacker.\n\nCache Poisoning: The impact of a maliciously constructed response can be magnified if it is cached either by a web cache used by multiple users or even the browser cache of a single user. If a response is cached in a shared web cache, such as those commonly found in proxy servers, then all users of that cache will continue receive the malicious content until the cache entry is purged. Similarly, if the response is cached in the browser of an individual user, then that user will continue to receive the malicious content until the cache entry is purged, although only the user of the local browser instance will be affected. \n\nCross-Site Scripting: Once attackers have control of the responses sent by an application, they have a choice of a variety of malicious content to provide users. Cross-site scripting is common form of attack where malicious JavaScript or other code included in a response is executed in the user's browser. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site. The most common and dangerous attack vector against users of a vulnerable application uses JavaScript to transmit session and authentication information back to the attacker who can then take complete control of the victim's account. \n\nPage Hijacking: In addition to using a vulnerable application to send malicious content to a user, the same root vulnerability can also be leveraged to redirect sensitive content generated by the server and intended for the user to the attacker instead. By submitting a request that results in two responses, the intended response from the server and the response generated by the attacker, an attacker can cause an intermediate node, such as a shared proxy server, to misdirect a response generated by the server for the user to the attacker. Because the request made by the attacker generates two responses, the first is interpreted as a response to the attacker's request, while the second remains in limbo. When the user makes a legitimate request through the same TCP connection, the attacker's request is already waiting and is interpreted as a response to the victim's request. The attacker then sends a second request to the server, to which the proxy server responds with the server generated request intended for the victim, thereby compromising any sensitive information in the headers or body of the response intended for the victim.\n\nCookie Manipulation: When combined with attacks like Cross-Site Request Forgery, attackers can change, add to, or even overwrite a legitimate user's cookies.\n\nOpen Redirect: Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.\n\nMany of today's modern application servers will prevent the injection of malicious characters into HTTP headers. For example, recent versions of Apache Tomcat will throw an IllegalArgumentException if you attempt to set a header with prohibited characters. If your application server prevents setting headers with new line characters, then your application is not vulnerable to HTTP Response Splitting. However, solely filtering for new line characters can leave an application vulnerable to Cookie Manipulation or Open Redirects, so care must still be taken when setting HTTP headers with user input.\n\n\n\nThe solution to Header Manipulation is to ensure that input validation occurs in the correct places and checks for the correct properties.\n\nSince Header Manipulation vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating responses dynamically, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for Header Manipulation.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for Header Manipulation is generally relatively easy. Despite its value, input validation for Header Manipulation does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent Header Manipulation vulnerabilities is to validate everything that enters the application or leaves the application destined for the user.\n\nThe most secure approach to validation for Header Manipulation is to create a whitelist of safe characters that are allowed to appear in HTTP response headers and accept input composed exclusively of characters in the approved set. For example, a valid name might only include alpha-numeric characters or an account number might only include digits 0-9.\n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning in HTTP response headers. Although the CR and LF characters are at the heart of an HTTP response splitting attack, other characters, such as ':' (colon) and '=' (equal), have special meaning in response headers as well.\n\nOnce you identify the correct points in an application to perform validation for Header Manipulation attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. The application should reject any input destined to be included in HTTP response headers that contains special characters, particularly CR and LF, as invalid.\n\nMany application servers attempt to limit an application's exposure to HTTP response splitting vulnerabilities by providing implementations for the functions responsible for setting HTTP headers and cookies that perform validation for the characters essential to an HTTP response splitting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/157/?engineType=SCA&issue=321240CF763825D3F0C44AF194CBEB47"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "652",
          "shortDescription" : {
            "text" : "Header Manipulation"
          },
          "fullDescription" : {
            "text" : "The method _jspService() in config.jsp includes unvalidated data in an HTTP response header on line 12.  This enables attacks such as cache-poisoning, cross-site scripting, cross-user defacement, page hijacking, cookie manipulation or open redirect.\n\n\n"
          },
          "help" : {
            "text" : "Header Manipulation vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source, most frequently an HTTP request.\n\nIn this case the data enters at getParameter() in config.jsp at line 11. \n\n2. The data is included in an HTTP response header sent to a web user without being validated.\n\nIn this case the data is sent at sendRedirect() in config.jsp at line 12.\n\nAs with many software security vulnerabilities, Header Manipulation is a means to an end, not an end in itself. At its root, the vulnerability is straightforward: an attacker passes malicious data to a vulnerable application, and the application includes the data in an HTTP response header.\n\nOne of the most common Header Manipulation attacks is HTTP Response Splitting. To mount a successful Http Response Splitting exploit, the application must allow input that contains CR (carriage return, also given by %0d or \\r) and LF (line feed, also given by %0a or \n)characters into the header. These characters not only give attackers control of the remaining headers and body of the response the application intends to send, but also allows them to create additional responses entirely under their control.\n\nExample: The following code segment reads the name of the author of a weblog entry, author, from an HTTP request and sets it in a cookie header of an HTTP response. \n\n\nString author = request.getParameter(AUTHOR_PARAM);\n...\nCookie cookie = new Cookie(\"author\", author);\n     cookie.setMaxAge(cookieExpiration);\n     response.addCookie(cookie);\n\n\nAssuming a string consisting of standard alpha-numeric characters, such as \"Jane Smith\", is submitted in the request the HTTP response including this cookie might take the following form:\n\n\nHTTP/1.1 200 OK\n...\nSet-Cookie: author=Jane Smith\n...\n\n\nHowever, because the value of the cookie is formed of unvalidated user input the response will only maintain this form if the value submitted for AUTHOR_PARAM does not contain any CR and LF characters. If an attacker submits a malicious string, such as \"Wiley Hacker\\r\nHTTP/1.1 200 OK\\r\n...\", then the HTTP response would be split into two responses of the following form:\n\n\nHTTP/1.1 200 OK\n...\nSet-Cookie: author=Wiley Hacker\n\nHTTP/1.1 200 OK\n...\n\n\nClearly, the second response is completely controlled by the attacker and can be constructed with any header and body content desired. The ability of attacker to construct arbitrary HTTP responses permits a variety of resulting attacks, including: cross-user defacement, web and browser cache poisoning, cross-site scripting and page hijacking. \n\nCross-User Defacement: An attacker can make a single request to a vulnerable server that will cause the server to create two responses, the second of which may be misinterpreted as a response to a different request, possibly one made by another user sharing the same TCP connection with the server. This can be accomplished by convincing the user to submit the malicious request themselves, or remotely in situations where the attacker and the user share a common TCP connection to the server, such as a shared proxy server. In the best case, an attacker can leverage this ability to convince users that the application has been hacked, causing users to lose confidence in the security of the application. In the worst case, an attacker may provide specially crafted content designed to mimic the behavior of the application but redirect private information, such as account numbers and passwords, back to the attacker.\n\nCache Poisoning: The impact of a maliciously constructed response can be magnified if it is cached either by a web cache used by multiple users or even the browser cache of a single user. If a response is cached in a shared web cache, such as those commonly found in proxy servers, then all users of that cache will continue receive the malicious content until the cache entry is purged. Similarly, if the response is cached in the browser of an individual user, then that user will continue to receive the malicious content until the cache entry is purged, although only the user of the local browser instance will be affected. \n\nCross-Site Scripting: Once attackers have control of the responses sent by an application, they have a choice of a variety of malicious content to provide users. Cross-site scripting is common form of attack where malicious JavaScript or other code included in a response is executed in the user's browser. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site. The most common and dangerous attack vector against users of a vulnerable application uses JavaScript to transmit session and authentication information back to the attacker who can then take complete control of the victim's account. \n\nPage Hijacking: In addition to using a vulnerable application to send malicious content to a user, the same root vulnerability can also be leveraged to redirect sensitive content generated by the server and intended for the user to the attacker instead. By submitting a request that results in two responses, the intended response from the server and the response generated by the attacker, an attacker can cause an intermediate node, such as a shared proxy server, to misdirect a response generated by the server for the user to the attacker. Because the request made by the attacker generates two responses, the first is interpreted as a response to the attacker's request, while the second remains in limbo. When the user makes a legitimate request through the same TCP connection, the attacker's request is already waiting and is interpreted as a response to the victim's request. The attacker then sends a second request to the server, to which the proxy server responds with the server generated request intended for the victim, thereby compromising any sensitive information in the headers or body of the response intended for the victim.\n\nCookie Manipulation: When combined with attacks like Cross-Site Request Forgery, attackers can change, add to, or even overwrite a legitimate user's cookies.\n\nOpen Redirect: Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.\n\nMany of today's modern application servers will prevent the injection of malicious characters into HTTP headers. For example, recent versions of Apache Tomcat will throw an IllegalArgumentException if you attempt to set a header with prohibited characters. If your application server prevents setting headers with new line characters, then your application is not vulnerable to HTTP Response Splitting. However, solely filtering for new line characters can leave an application vulnerable to Cookie Manipulation or Open Redirects, so care must still be taken when setting HTTP headers with user input.\n\n\n\nThe solution to Header Manipulation is to ensure that input validation occurs in the correct places and checks for the correct properties.\n\nSince Header Manipulation vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating responses dynamically, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for Header Manipulation.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for Header Manipulation is generally relatively easy. Despite its value, input validation for Header Manipulation does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent Header Manipulation vulnerabilities is to validate everything that enters the application or leaves the application destined for the user.\n\nThe most secure approach to validation for Header Manipulation is to create a whitelist of safe characters that are allowed to appear in HTTP response headers and accept input composed exclusively of characters in the approved set. For example, a valid name might only include alpha-numeric characters or an account number might only include digits 0-9.\n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning in HTTP response headers. Although the CR and LF characters are at the heart of an HTTP response splitting attack, other characters, such as ':' (colon) and '=' (equal), have special meaning in response headers as well.\n\nOnce you identify the correct points in an application to perform validation for Header Manipulation attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. The application should reject any input destined to be included in HTTP response headers that contains special characters, particularly CR and LF, as invalid.\n\nMany application servers attempt to limit an application's exposure to HTTP response splitting vulnerabilities by providing implementations for the functions responsible for setting HTTP headers and cookies that perform validation for the characters essential to an HTTP response splitting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/652/?engineType=SCA&issue=EB45BE23BC667630C8D71F49CF38686F"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1542",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method _jspService() in EditProfile.jsp mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to print() in EditProfile.jsp at line 54.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1542/?engineType=SCA&issue=051D7BA95A2D42257D911A40F0E94C51"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "455",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method _jspService() in SearchStaff.jsp sends unvalidated data to a web browser on line 11, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameter() in SearchStaff.jsp at line 7. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at print() in SearchStaff.jsp at line 11.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/455/?engineType=SCA&issue=9DCDB59233971BE82AB2FD810501FC1F"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1708",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method _jspService() in ViewProfile.jsp mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to print() in ViewProfile.jsp at line 58.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1708/?engineType=SCA&issue=9E05E5300B01063AF49BBCD16B41A873"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "231",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method _jspService() in EditProfile.jsp mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to print() in EditProfile.jsp at line 53.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/231/?engineType=SCA&issue=4BFE6B2E3F7D26204AA3796D3F83DA94"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1585",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method _jspService() in EditProfile.jsp mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to print() in EditProfile.jsp at line 53.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1585/?engineType=SCA&issue=2E406966112D6EA14467FF26B134C3D2"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "204",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method _jspService() in SearchStaff.jsp sends unvalidated data to a web browser on line 11, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameter() in SearchStaff.jsp at line 7. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at print() in SearchStaff.jsp at line 11.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/204/?engineType=SCA&issue=40889BA9E6868AC4207C03E0903DDE85"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1667",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method _jspService() in ViewProfile.jsp mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to print() in ViewProfile.jsp at line 54.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1667/?engineType=SCA&issue=756376895FB2B27F7B72E30C4E55F9C6"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "110",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method _jspService() in EditProfile.jsp mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to print() in EditProfile.jsp at line 54.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/110/?engineType=SCA&issue=253A24B2ACDB895D685D2C495F6FDCBF"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "1782",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method _jspService() in EditProfile.jsp mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to print() in EditProfile.jsp at line 54.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1782/?engineType=SCA&issue=D1FD83E074351358B66985F188CF4E9D"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "144",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method _jspService() in SearchStaff.jsp sends unvalidated data to a web browser on line 11, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameter() in SearchStaff.jsp at line 7. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at print() in SearchStaff.jsp at line 11.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/144/?engineType=SCA&issue=2DF475BDE7FB507FB1C0BF848C0063EF"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "1647",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method _jspService() in ViewProfile.jsp mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system, or network. \n\n    In this case the data is passed to print() in ViewProfile.jsp at line 54.\n\n\nExample: The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the getPassword() function returns the user-supplied plaintext password associated with the account. \n\n\npass = getPassword();\n...\ndbmsLog.println(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. \n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. \n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. \n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency. \n\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/1647/?engineType=SCA&issue=6C1C6D3E16F2B1CFFBEAE37D1C717BC9"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "461",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method _jspService() in main.jsp sends unvalidated data to a web browser on line 114, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameter() in main.jsp at line 34. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at print() in main.jsp at line 114.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/461/?engineType=SCA&issue=A02F8DBE56F5F4CDBAFBD7733B07B7B0"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "462",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method _jspService() in main.jsp sends unvalidated data to a web browser on line 119, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameter() in main.jsp at line 34. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at print() in main.jsp at line 119.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/462/?engineType=SCA&issue=A02F8DBE56F5F4CDBAFBD7733B07B7B1"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "463",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method _jspService() in main.jsp sends unvalidated data to a web browser on line 124, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameter() in main.jsp at line 34. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at print() in main.jsp at line 124.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/463/?engineType=SCA&issue=A02F8DBE56F5F4CDBAFBD7733B07B7B2"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "464",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method _jspService() in main.jsp sends unvalidated data to a web browser on line 130, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameter() in main.jsp at line 34. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at print() in main.jsp at line 130.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/464/?engineType=SCA&issue=A02F8DBE56F5F4CDBAFBD7733B07B7B3"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "465",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method _jspService() in main.jsp sends unvalidated data to a web browser on line 135, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.\n\n\nIn this case the data enters at getParameter() in main.jsp at line 34. \n\n2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. \n\nIn this case the data is sent at print() in main.jsp at line 135.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user. \n\n\n&lt;% String eid = request.getParameter(\"eid\"); %&gt; \n...\nEmployee ID: &lt;%= eid %&gt;\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.\n\n \n&lt;%... \n Statement stmt = conn.createStatement();\n ResultSet rs = stmt.executeQuery(\"select * from emp where id=\"+eid);\n if (rs != null) {\n  rs.next(); \n  String name = rs.getString(\"name\");\n%&gt;\n\nEmployee Name: &lt;%= name %&gt;\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.\n\nSince XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. \n\nThe most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. \n\nA more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity. \n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. \n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering. \n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nOnce you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/3/fix/465/?engineType=SCA&issue=A02F8DBE56F5F4CDBAFBD7733B07B7B4"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        } ]
      }
    },
    "results" : [ {
      "ruleId" : "635",
      "message" : {
        "text" : "The class HammerHead is a singleton, so the member field mySession is shared between users.  The result is that one user could see another user's data.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "E2D4A2D542D71542FC025DF66EF28C26"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/HammerHead.java"
          },
          "region" : {
            "startLine" : 135,
            "endLine" : 135,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "542",
      "message" : {
        "text" : "The function doPost() in HammerHead.java might reveal system data or debugging information by calling printStackTrace() on line 192.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B98B6B12E7E2107A2C5FB412E8074669"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/HammerHead.java"
          },
          "region" : {
            "startLine" : 192,
            "endLine" : 192,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "537",
      "message" : {
        "text" : "The function doPost() in HammerHead.java might reveal system data or debugging information by calling log() on line 193.  The information revealed by log() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B7C1C1CB2A70786BA5A237EC0231FBC0"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/HammerHead.java"
          },
          "region" : {
            "startLine" : 193,
            "endLine" : 193,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "604",
      "message" : {
        "text" : "The function doPost() in HammerHead.java might reveal system data or debugging information by calling printStackTrace() on line 204.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D7EA539980EA0892CA2126A54762616A"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/HammerHead.java"
          },
          "region" : {
            "startLine" : 204,
            "endLine" : 204,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "605",
      "message" : {
        "text" : "The function doPost() in HammerHead.java might reveal system data or debugging information by calling printStackTrace() on line 204.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D7EA539980EA0892CA2126A54762616B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/HammerHead.java"
          },
          "region" : {
            "startLine" : 204,
            "endLine" : 204,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "606",
      "message" : {
        "text" : "The function doPost() in HammerHead.java might reveal system data or debugging information by calling printStackTrace() on line 204.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D7EA539980EA0892CA2126A54762616C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/HammerHead.java"
          },
          "region" : {
            "startLine" : 204,
            "endLine" : 204,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "377",
      "message" : {
        "text" : "The method doPost() in HammerHead.java writes unvalidated user input to the log on line 205.  An attacker could take advantage of this behavior to forge log entries or inject malicious content into the log.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "81E68A780910D710E6290EA2FEFC6A98"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/HammerHead.java"
          },
          "region" : {
            "startLine" : 205,
            "endLine" : 205,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "582",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "CBC1A299785CBB6162BAC7CE6631AC42"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/HammerHead.java"
          },
          "region" : {
            "startLine" : 245,
            "endLine" : 245,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "583",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "CBC1A299785CBB6162BAC7CE6631AC43"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/HammerHead.java"
          },
          "region" : {
            "startLine" : 246,
            "endLine" : 246,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "176",
      "message" : {
        "text" : "The function log() in HammerHead.java might reveal system data or debugging information by calling log() on line 306.  The information revealed by log() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "395FF4482C440E0DFFFDBE3D38ACE125"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/HammerHead.java"
          },
          "region" : {
            "startLine" : 306,
            "endLine" : 306,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "476",
      "message" : {
        "text" : "The function log() in HammerHead.java might reveal system data or debugging information by calling log() on line 306.  The information revealed by log() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "A442B6350AC6E369A724F565263FE717"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/HammerHead.java"
          },
          "region" : {
            "startLine" : 306,
            "endLine" : 306,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1606",
      "message" : {
        "text" : "The method log() in HammerHead.java writes unvalidated user input to the log on line 306.  An attacker could take advantage of this behavior to forge log entries or inject malicious content into the log.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "3E3C937B3D0198B6F1DE184BAF51F1E6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/HammerHead.java"
          },
          "region" : {
            "startLine" : 306,
            "endLine" : 306,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1608",
      "message" : {
        "text" : "The method log() in HammerHead.java writes unvalidated user input to the log on line 306.  An attacker could take advantage of this behavior to forge log entries or inject malicious content into the log.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "4179E644761CD4A3FAF2F275662F135A"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/HammerHead.java"
          },
          "region" : {
            "startLine" : 306,
            "endLine" : 306,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "116",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "2770E49728E1EE378BC0BD7B34A122C9"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/HammerHead.java"
          },
          "region" : {
            "startLine" : 307,
            "endLine" : 307,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "444",
      "message" : {
        "text" : "The function log() in HammerHead.java might reveal system data or debugging information by calling println() on line 307.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "99230E892495D721C9D0F9664711B616"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/HammerHead.java"
          },
          "region" : {
            "startLine" : 307,
            "endLine" : 307,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "496",
      "message" : {
        "text" : "The function log() in HammerHead.java might reveal system data or debugging information by calling println() on line 307.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "AB4E42C5163F2C47C0CE0592AD5E896C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/HammerHead.java"
          },
          "region" : {
            "startLine" : 307,
            "endLine" : 307,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "329",
      "message" : {
        "text" : "The function doPost() in LessonSource.java might reveal system data or debugging information by calling printStackTrace() on line 93.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "71BF097995A06C0A5E79ED93F9DFA30B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/LessonSource.java"
          },
          "region" : {
            "startLine" : 93,
            "endLine" : 93,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1025",
      "message" : {
        "text" : "The function doPost() in LessonSource.java might reveal system data or debugging information by calling log() on line 94.  The information revealed by log() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "01C7651E942A3833D17DC17AB436A13F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/LessonSource.java"
          },
          "region" : {
            "startLine" : 94,
            "endLine" : 94,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "108",
      "message" : {
        "text" : "The function doPost() in LessonSource.java might reveal system data or debugging information by calling printStackTrace() on line 104.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "2509DC39A77F6D65BBCF8ACCFF657FFE"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/LessonSource.java"
          },
          "region" : {
            "startLine" : 104,
            "endLine" : 104,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "646",
      "message" : {
        "text" : "The catch block at AbstractLesson.java line 420 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "E80E51AB9225B4EA3FA4674302DC130A"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/AbstractLesson.java"
          },
          "region" : {
            "startLine" : 420,
            "endLine" : 420,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "553",
      "message" : {
        "text" : "The function getFileMethod() in AbstractLesson.java might reveal system data or debugging information by calling println() on line 422.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "BC4C3AFB66A9949C193A3809DDA9E40C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/AbstractLesson.java"
          },
          "region" : {
            "startLine" : 422,
            "endLine" : 422,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "629",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "DEF38D529FC2FAD74E4EB1C518722812"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/AbstractLesson.java"
          },
          "region" : {
            "startLine" : 422,
            "endLine" : 422,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "667",
      "message" : {
        "text" : "The function getFileMethod() in AbstractLesson.java might reveal system data or debugging information by calling printStackTrace() on line 423.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F0AF230D6D4B8FD61D448F00098EF862"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/AbstractLesson.java"
          },
          "region" : {
            "startLine" : 423,
            "endLine" : 423,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "707",
      "message" : {
        "text" : "The catch block at AbstractLesson.java line 476 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F93C83B4FFD27A376FB49DE36A9D44D2"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/AbstractLesson.java"
          },
          "region" : {
            "startLine" : 476,
            "endLine" : 476,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "93",
      "message" : {
        "text" : "The function getFileText() in AbstractLesson.java might reveal system data or debugging information by calling println() on line 478.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "1E98A6F7A122158FAD7179B0502E34B1"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/AbstractLesson.java"
          },
          "region" : {
            "startLine" : 478,
            "endLine" : 478,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "117",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "27BC666113F2CFC868E3CA65D2C89F34"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/AbstractLesson.java"
          },
          "region" : {
            "startLine" : 478,
            "endLine" : 478,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "601",
      "message" : {
        "text" : "The function getFileText() in AbstractLesson.java might reveal system data or debugging information by calling printStackTrace() on line 479.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D76FD51A11E5483E308232F0748769C5"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/AbstractLesson.java"
          },
          "region" : {
            "startLine" : 479,
            "endLine" : 479,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1204",
      "message" : {
        "text" : "The function getLessonPlan() in AbstractLesson.java sometimes fails to release a system resource allocated by FileReader() on line 567.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "8D2F9470457AA1DBB019D65452C98DCC"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/AbstractLesson.java"
          },
          "region" : {
            "startLine" : 567,
            "endLine" : 567,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1067",
      "message" : {
        "text" : "The catch block at AbstractLesson.java line 571 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "20BA5BBCC9DDDA06B46463E3D6B3E983"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/AbstractLesson.java"
          },
          "region" : {
            "startLine" : 571,
            "endLine" : 571,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1162",
      "message" : {
        "text" : "The function getSource() in AbstractLesson.java sometimes fails to release a system resource allocated by FileReader() on line 670.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "6A452E3BFF473737F95196432C59610A"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/AbstractLesson.java"
          },
          "region" : {
            "startLine" : 669,
            "endLine" : 669,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "228",
      "message" : {
        "text" : "On line 801 of AbstractLesson.java, the method isAuthorized() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "4B43C1C4D3D99D2A7DFE1A2192D7A6AB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/AbstractLesson.java"
          },
          "region" : {
            "startLine" : 801,
            "endLine" : 801,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "600",
      "message" : {
        "text" : "The function isAuthorized() in AbstractLesson.java might reveal system data or debugging information by calling printStackTrace() on line 807.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D613F7CF5C9DCE819D72E14B4C1612FB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/AbstractLesson.java"
          },
          "region" : {
            "startLine" : 807,
            "endLine" : 807,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1086",
      "message" : {
        "text" : "The catch block at AbstractLesson.java line 810 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "30F39BBC28D0369D663791E91DDFBFA6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/AbstractLesson.java"
          },
          "region" : {
            "startLine" : 810,
            "endLine" : 810,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "245",
      "message" : {
        "text" : "The function isAuthorized() in AbstractLesson.java might reveal system data or debugging information by calling printStackTrace() on line 813.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "52AB825BF8B0D376878A2332E3C287FB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/AbstractLesson.java"
          },
          "region" : {
            "startLine" : 813,
            "endLine" : 813,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1801",
      "message" : {
        "text" : "The method makeParamDump_DELETEME() in AbstractLesson.java sends unvalidated data to a web browser on line 872, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "E37E79651849FC3D1A90C1ABAD6E637D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/AbstractLesson.java"
          },
          "region" : {
            "startLine" : 872,
            "endLine" : 872,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1819",
      "message" : {
        "text" : "The method makeParamDump_DELETEME() in AbstractLesson.java sends unvalidated data to a web browser on line 872, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "EEC853E23854174F9A6951A9CC55840E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/AbstractLesson.java"
          },
          "region" : {
            "startLine" : 872,
            "endLine" : 872,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1219",
      "message" : {
        "text" : "The catch block at AbstractLesson.java line 903 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "9BCF360F710A55757FC8BD2BCC652BF0"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/AbstractLesson.java"
          },
          "region" : {
            "startLine" : 903,
            "endLine" : 903,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1139",
      "message" : {
        "text" : "The method makeRequestDump_DELETEME() in AbstractLesson.java sends unvalidated data to a web browser on line 920, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "56F91135D0561F50D05F151536F819F8"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/AbstractLesson.java"
          },
          "region" : {
            "startLine" : 920,
            "endLine" : 920,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1298",
      "message" : {
        "text" : "The function makeSourceDump_DELETEME() in AbstractLesson.java sometimes fails to release a system resource allocated by FileReader() on line 955.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "D56D1FEF7BB4EBA49C9A395DF0D88AC4"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/AbstractLesson.java"
          },
          "region" : {
            "startLine" : 954,
            "endLine" : 954,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1093",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "37635EECC3C6B321C571737A2EDF72D7"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/AbstractLesson.java"
          },
          "region" : {
            "startLine" : 960,
            "endLine" : 960,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1330",
      "message" : {
        "text" : "The function makeSourceDump_DELETEME() in AbstractLesson.java might reveal system data or debugging information by calling println() on line 960.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F0879411EBC690469AFC6E5E7FF4EDC1"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/AbstractLesson.java"
          },
          "region" : {
            "startLine" : 960,
            "endLine" : 960,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "65",
      "message" : {
        "text" : "The function readFromURL() in AbstractLesson.java sometimes fails to release a system resource allocated by getInputStream() on line 1032.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "15C50D550084CFABCE3D6DBB896ACCE3"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/AbstractLesson.java"
          },
          "region" : {
            "startLine" : 1031,
            "endLine" : 1031,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "345",
      "message" : {
        "text" : "The catch block at AbstractLesson.java line 1042 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "788548B8FF65CC4AF3A944A36AD831BA"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/AbstractLesson.java"
          },
          "region" : {
            "startLine" : 1042,
            "endLine" : 1042,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "237",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "4DB0C4C7484B1BC7DED7FD5D654E0315"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/AbstractLesson.java"
          },
          "region" : {
            "startLine" : 1044,
            "endLine" : 1044,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "300",
      "message" : {
        "text" : "The function readFromURL() in AbstractLesson.java might reveal system data or debugging information by calling println() on line 1044.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "63B451D8A2A6D70B0E55D1795D455FAF"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/AbstractLesson.java"
          },
          "region" : {
            "startLine" : 1044,
            "endLine" : 1044,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "346",
      "message" : {
        "text" : "The function readFromURL() in AbstractLesson.java might reveal system data or debugging information by calling printStackTrace() on line 1045.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "791A891A76696CCE5590E44AE11A9C91"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/AbstractLesson.java"
          },
          "region" : {
            "startLine" : 1045,
            "endLine" : 1045,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1307",
      "message" : {
        "text" : "The catch block at AccessControlMatrix.java line 111 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D85F7F08CD96663CB4852A0166EBAC84"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/AccessControlMatrix.java"
          },
          "region" : {
            "startLine" : 111,
            "endLine" : 111,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "244",
      "message" : {
        "text" : "The function createContent() in AccessControlMatrix.java might reveal system data or debugging information by calling printStackTrace() on line 114.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "51D7D308BD3345DCA7B15A0BEB7EBE70"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/AccessControlMatrix.java"
          },
          "region" : {
            "startLine" : 114,
            "endLine" : 114,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1026",
      "message" : {
        "text" : "The method concept1() in BackDoors.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "022767F21A8D334E484C3E7CEC2C6749"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/BackDoors.java"
          },
          "region" : {
            "startLine" : 87,
            "endLine" : 87,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1677",
      "message" : {
        "text" : "On line 106 of BackDoors.java, the method concept1() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "7DE5CB2BC4041A1E67F217526A3B5F3A"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/BackDoors.java"
          },
          "region" : {
            "startLine" : 106,
            "endLine" : 106,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1637",
      "message" : {
        "text" : "On line 113 of BackDoors.java, the method concept1() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "675BD3A413F61AD447FA0DCCD6661859"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/BackDoors.java"
          },
          "region" : {
            "startLine" : 113,
            "endLine" : 113,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "452",
      "message" : {
        "text" : "The method concept1() in BackDoors.java sends unvalidated data to a web browser on line 125, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "9BF8789DF9C0CCB6DBF071D592563C54"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/BackDoors.java"
          },
          "region" : {
            "startLine" : 125,
            "endLine" : 125,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "213",
      "message" : {
        "text" : "The method concept1() in BackDoors.java sends unvalidated data to a web browser on line 126, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "45708E1EF2D60DAC753B122522A7537E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/BackDoors.java"
          },
          "region" : {
            "startLine" : 126,
            "endLine" : 126,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "426",
      "message" : {
        "text" : "The method concept1() in BackDoors.java sends unvalidated data to a web browser on line 127, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "961B750FFA42A8955E468768E4F13CCF"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/BackDoors.java"
          },
          "region" : {
            "startLine" : 127,
            "endLine" : 127,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "193",
      "message" : {
        "text" : "The method concept1() in BackDoors.java sends unvalidated data to a web browser on line 128, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "3BC31286F68156D8BF9A7F34BA37635B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/BackDoors.java"
          },
          "region" : {
            "startLine" : 128,
            "endLine" : 128,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1346",
      "message" : {
        "text" : "The catch block at BackDoors.java line 134 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "FB25471481DE82711751425170451DD3"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/BackDoors.java"
          },
          "region" : {
            "startLine" : 134,
            "endLine" : 134,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1101",
      "message" : {
        "text" : "The method concept2() in BackDoors.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "3CEFB658C858D961F2C1942155C3C953"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/BackDoors.java"
          },
          "region" : {
            "startLine" : 142,
            "endLine" : 142,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1643",
      "message" : {
        "text" : "The method makeUsername() in BackDoors.java sends unvalidated data to a web browser on line 235, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "6999DE3FC99AF2500FE3F95C518BC7D3"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/BackDoors.java"
          },
          "region" : {
            "startLine" : 235,
            "endLine" : 235,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1784",
      "message" : {
        "text" : "The method doStage1() in BasicAuthentication.java sends unvalidated data to a web browser on line 143, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "D5C3ED4CE0DAF762A1F6D507F0B2914F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/BasicAuthentication.java"
          },
          "region" : {
            "startLine" : 143,
            "endLine" : 143,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1800",
      "message" : {
        "text" : "The method doStage1() in BasicAuthentication.java sends unvalidated data to a web browser on line 145, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "E350095CB012D2ECF7AC8B80E4032750"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/BasicAuthentication.java"
          },
          "region" : {
            "startLine" : 145,
            "endLine" : 145,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1087",
      "message" : {
        "text" : "The catch block at BasicAuthentication.java line 157 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "319D6AB060984AB435CFC2164A196538"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/BasicAuthentication.java"
          },
          "region" : {
            "startLine" : 157,
            "endLine" : 157,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "495",
      "message" : {
        "text" : "The function doStage1() in BasicAuthentication.java might reveal system data or debugging information by calling printStackTrace() on line 160.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "AB0F9C0F0179DC45DB936C0CAB702657"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/BasicAuthentication.java"
          },
          "region" : {
            "startLine" : 160,
            "endLine" : 160,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1240",
      "message" : {
        "text" : "The catch block at BasicAuthentication.java line 248 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "AD2FEB0CD76C9ED8B99A2A5F61415514"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/BasicAuthentication.java"
          },
          "region" : {
            "startLine" : 248,
            "endLine" : 248,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "32",
      "message" : {
        "text" : "The function doStage2() in BasicAuthentication.java might reveal system data or debugging information by calling printStackTrace() on line 251.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "10D4432215FC1D906CED38AA5E8FCC55"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/BasicAuthentication.java"
          },
          "region" : {
            "startLine" : 251,
            "endLine" : 251,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1617",
      "message" : {
        "text" : "On line 122 of BlindSqlInjection.java, the method createContent() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "4C2F0A022D42BDB810AB61020436E6EE"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/BlindSqlInjection.java"
          },
          "region" : {
            "startLine" : 122,
            "endLine" : 122,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1228",
      "message" : {
        "text" : "The catch block at BlindSqlInjection.java line 142 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "A638BBFC9558DCBD6543396FED7E085F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/BlindSqlInjection.java"
          },
          "region" : {
            "startLine" : 142,
            "endLine" : 142,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "457",
      "message" : {
        "text" : "The function createContent() in BlindSqlInjection.java might reveal system data or debugging information by calling printStackTrace() on line 145.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "9DE7F1DA6C0A12A6FD5E01E6393AB3DA"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/BlindSqlInjection.java"
          },
          "region" : {
            "startLine" : 145,
            "endLine" : 145,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1227",
      "message" : {
        "text" : "The catch block at BlindSqlInjection.java line 341 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "A5C4F2CFD0C6A55CD11A173A3EC43334"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/BlindSqlInjection.java"
          },
          "region" : {
            "startLine" : 341,
            "endLine" : 341,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1208",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "9240DA4A67F3261C56DD14951F08BFAC"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/BlindSqlInjection.java"
          },
          "region" : {
            "startLine" : 343,
            "endLine" : 343,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1321",
      "message" : {
        "text" : "The function handleRequest() in BlindSqlInjection.java might reveal system data or debugging information by calling println() on line 343.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "E8944AADCF578C5024D1735F7C279E48"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/BlindSqlInjection.java"
          },
          "region" : {
            "startLine" : 343,
            "endLine" : 343,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "39",
      "message" : {
        "text" : "The function handleRequest() in BlindSqlInjection.java might reveal system data or debugging information by calling printStackTrace() on line 344.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "125F01FC217C384431D1097619DF9AD9"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/BlindSqlInjection.java"
          },
          "region" : {
            "startLine" : 344,
            "endLine" : 344,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1338",
      "message" : {
        "text" : "The catch block at CSRF.java line 100 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F718D43EBA284DCE994D82A30120BE9B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CSRF.java"
          },
          "region" : {
            "startLine" : 100,
            "endLine" : 100,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1207",
      "message" : {
        "text" : "On line 181 of CSRF.java, the method makeList() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "91BE8A9509668E194A8C877526E7160F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CSRF.java"
          },
          "region" : {
            "startLine" : 181,
            "endLine" : 181,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1186",
      "message" : {
        "text" : "The method makeList() in CSRF.java sends unvalidated data to a web browser on line 193, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "7F5910D8AF054AAE63BCB1A22ECFA207"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CSRF.java"
          },
          "region" : {
            "startLine" : 193,
            "endLine" : 193,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1089",
      "message" : {
        "text" : "The catch block at CSRF.java line 199 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "34584650395D5F2534406558498B5C27"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CSRF.java"
          },
          "region" : {
            "startLine" : 199,
            "endLine" : 199,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "562",
      "message" : {
        "text" : "The method makeCurrent() in CSRF.java sends unvalidated data to a web browser on line 245, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "BFC40FBA3F9B73C3A8654B3F76C62244"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CSRF.java"
          },
          "region" : {
            "startLine" : 245,
            "endLine" : 245,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "492",
      "message" : {
        "text" : "The method makeCurrent() in CSRF.java sends unvalidated data to a web browser on line 248, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "AAFC1F7059CAAA46A9CD6BDBA80E9307"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CSRF.java"
          },
          "region" : {
            "startLine" : 248,
            "endLine" : 248,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "493",
      "message" : {
        "text" : "The method makeCurrent() in CSRF.java sends unvalidated data to a web browser on line 253, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "AAFC1F7059CAAA46A9CD6BDBA80E9308"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CSRF.java"
          },
          "region" : {
            "startLine" : 253,
            "endLine" : 253,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "494",
      "message" : {
        "text" : "The method makeCurrent() in CSRF.java sends unvalidated data to a web browser on line 257, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "AAFC1F7059CAAA46A9CD6BDBA80E9309"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CSRF.java"
          },
          "region" : {
            "startLine" : 257,
            "endLine" : 257,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1187",
      "message" : {
        "text" : "The catch block at CSRF.java line 272 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "7FCE6A612F85C47C347711EDAAA88EFA"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CSRF.java"
          },
          "region" : {
            "startLine" : 272,
            "endLine" : 272,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "647",
      "message" : {
        "text" : "The function makeCurrent() in CSRF.java might reveal system data or debugging information by calling printStackTrace() on line 275.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "E8DC3D6ED853BCA5483F2920F6C6F78F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CSRF.java"
          },
          "region" : {
            "startLine" : 275,
            "endLine" : 275,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1167",
      "message" : {
        "text" : "On line 220 of Challenge2Screen.java, the method doStage2() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "722C045E93DFA161A8B0B9F3C11E00B5"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Challenge2Screen.java"
          },
          "region" : {
            "startLine" : 220,
            "endLine" : 220,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1123",
      "message" : {
        "text" : "The catch block at Challenge2Screen.java line 265 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "4919F2422E04E3C4D0B440616F633827"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Challenge2Screen.java"
          },
          "region" : {
            "startLine" : 265,
            "endLine" : 265,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1259",
      "message" : {
        "text" : "The catch block at Challenge2Screen.java line 346 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B78E4DB4CCF0A63E485127E81BAEB186"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Challenge2Screen.java"
          },
          "region" : {
            "startLine" : 346,
            "endLine" : 346,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1043",
      "message" : {
        "text" : "The function isDefaced() in Challenge2Screen.java sometimes fails to release a system resource allocated by FileReader() on line 381.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "13D5F7ED75A3AB864A34A5714569EF65"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Challenge2Screen.java"
          },
          "region" : {
            "startLine" : 381,
            "endLine" : 381,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1044",
      "message" : {
        "text" : "The function isDefaced() in Challenge2Screen.java sometimes fails to release a system resource allocated by FileReader() on line 383.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "13D5F7ED75A3AB864A34A5714569EF66"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Challenge2Screen.java"
          },
          "region" : {
            "startLine" : 383,
            "endLine" : 383,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1133",
      "message" : {
        "text" : "The catch block at Challenge2Screen.java line 388 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "51B54953C34AEE1514439CF36E4EF00F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Challenge2Screen.java"
          },
          "region" : {
            "startLine" : 388,
            "endLine" : 388,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "609",
      "message" : {
        "text" : "The function isDefaced() in Challenge2Screen.java might reveal system data or debugging information by calling printStackTrace() on line 390.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D91B3091E8E264DF8C6FF60BC35600BA"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Challenge2Screen.java"
          },
          "region" : {
            "startLine" : 390,
            "endLine" : 390,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1309",
      "message" : {
        "text" : "The method showDefaceAttempt() in Challenge2Screen.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D9C7CC39D5B7A558E88FA78611553BF4"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Challenge2Screen.java"
          },
          "region" : {
            "startLine" : 397,
            "endLine" : 397,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1121",
      "message" : {
        "text" : "The function showDefaceAttempt() in Challenge2Screen.java sometimes fails to release a system resource allocated by FileReader() on line 405.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "48CFC4960DE0E45B88DAE1B75077B408"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Challenge2Screen.java"
          },
          "region" : {
            "startLine" : 404,
            "endLine" : 404,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1122",
      "message" : {
        "text" : "The function showDefaceAttempt() in Challenge2Screen.java sometimes fails to release a system resource allocated by FileReader() on line 406.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "48CFC4960DE0E45B88DAE1B75077B409"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Challenge2Screen.java"
          },
          "region" : {
            "startLine" : 406,
            "endLine" : 406,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1125",
      "message" : {
        "text" : "The function resetWebPage() in Challenge2Screen.java sometimes fails to release a system resource allocated by FileWriter() on line 433.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "49AC82522DFE5219AF616B4DD208B330"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Challenge2Screen.java"
          },
          "region" : {
            "startLine" : 433,
            "endLine" : 433,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1059",
      "message" : {
        "text" : "The function resetWebPage() in Challenge2Screen.java sometimes fails to release a system resource allocated by FileReader() on line 434.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "1C63C03CDAD3AAC473C04FED33047A6E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Challenge2Screen.java"
          },
          "region" : {
            "startLine" : 434,
            "endLine" : 434,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1329",
      "message" : {
        "text" : "The catch block at Challenge2Screen.java line 439 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F07967E12A769BEE46B8C32F248610D0"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Challenge2Screen.java"
          },
          "region" : {
            "startLine" : 439,
            "endLine" : 439,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "654",
      "message" : {
        "text" : "The function resetWebPage() in Challenge2Screen.java might reveal system data or debugging information by calling printStackTrace() on line 441.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "EC550B01611ECF96AB4E36233F98E1DA"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Challenge2Screen.java"
          },
          "region" : {
            "startLine" : 441,
            "endLine" : 441,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "587",
      "message" : {
        "text" : "The catch block at Challenge2Screen.java line 726 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "CF1625E05308FFEA3F1E0E6E3565D80D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Challenge2Screen.java"
          },
          "region" : {
            "startLine" : 726,
            "endLine" : 726,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "96",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "208CC9439D8BBD0EF6A7FA217C42BAF8"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Challenge2Screen.java"
          },
          "region" : {
            "startLine" : 728,
            "endLine" : 728,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "208",
      "message" : {
        "text" : "The function sendMessage() in Challenge2Screen.java might reveal system data or debugging information by calling printStackTrace() on line 729.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "434C02AFB8035E739BE7929C0035BE55"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Challenge2Screen.java"
          },
          "region" : {
            "startLine" : 729,
            "endLine" : 729,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1256",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B5CEF3088653D1EB0FC57A1296AD4BAF"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CommandInjection.java"
          },
          "region" : {
            "startLine" : 87,
            "endLine" : 87,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1185",
      "message" : {
        "text" : "The catch block at CommandInjection.java line 208 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "7EF40D82A5F7C67496FCA5ABE720E01E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CommandInjection.java"
          },
          "region" : {
            "startLine" : 208,
            "endLine" : 208,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "66",
      "message" : {
        "text" : "The function createContent() in CommandInjection.java might reveal system data or debugging information by calling printStackTrace() on line 211.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "160F81FA3700C4ACF05278016D591DEE"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CommandInjection.java"
          },
          "region" : {
            "startLine" : 211,
            "endLine" : 211,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "154",
      "message" : {
        "text" : "The method parseResults() in CommandInjection.java ignores the value returned by replaceAll() on line 220, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "30AE8696BEA3CD405C5B06406DC2D875"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CommandInjection.java"
          },
          "region" : {
            "startLine" : 220,
            "endLine" : 220,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1229",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "A762ABB9403892D49EFC78C3720C32AB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CommandInjection.java"
          },
          "region" : {
            "startLine" : 264,
            "endLine" : 264,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1114",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "45061B1E02B98799473F8A6E78BC4A66"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CommandInjection.java"
          },
          "region" : {
            "startLine" : 285,
            "endLine" : 285,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1041",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "115DE7E55178D4232C6ABF96346DEC56"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CommandInjection.java"
          },
          "region" : {
            "startLine" : 306,
            "endLine" : 306,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1332",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F3622B291F5D16CC3A727AF90D75988B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/CrossSiteScripting.java"
          },
          "region" : {
            "startLine" : 359,
            "endLine" : 359,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1697",
      "message" : {
        "text" : "The function handleRequest() in CrossSiteScripting.java might reveal system data or debugging information by calling printStackTrace() on line 360.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "94BC2CB125163422C63F4E162F0FF0CB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/CrossSiteScripting.java"
          },
          "region" : {
            "startLine" : 360,
            "endLine" : 360,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1333",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F3622B291F5D16CC3A727AF90D75988C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/CrossSiteScripting.java"
          },
          "region" : {
            "startLine" : 365,
            "endLine" : 365,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1050",
      "message" : {
        "text" : "The function handleRequest() in CrossSiteScripting.java might reveal system data or debugging information by calling printStackTrace() on line 366.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "163B719F69C0908312A41CC536248C81"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/CrossSiteScripting.java"
          },
          "region" : {
            "startLine" : 366,
            "endLine" : 366,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1334",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F3622B291F5D16CC3A727AF90D75988D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/CrossSiteScripting.java"
          },
          "region" : {
            "startLine" : 372,
            "endLine" : 372,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1539",
      "message" : {
        "text" : "The function handleRequest() in CrossSiteScripting.java might reveal system data or debugging information by calling printStackTrace() on line 373.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "031C838BEA3E68948136390E110422AA"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/CrossSiteScripting.java"
          },
          "region" : {
            "startLine" : 373,
            "endLine" : 373,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1335",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F3622B291F5D16CC3A727AF90D75988E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/CrossSiteScripting.java"
          },
          "region" : {
            "startLine" : 378,
            "endLine" : 378,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1535",
      "message" : {
        "text" : "The function handleRequest() in CrossSiteScripting.java might reveal system data or debugging information by calling printStackTrace() on line 379.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "0010C1C949B6B1146790E9BA51866F0D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/CrossSiteScripting.java"
          },
          "region" : {
            "startLine" : 379,
            "endLine" : 379,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1328",
      "message" : {
        "text" : "The catch block at CrossSiteScripting.java line 381 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "EFBAC65F8FEB6F6E14FACDBB742BCC7E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/CrossSiteScripting.java"
          },
          "region" : {
            "startLine" : 381,
            "endLine" : 381,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1336",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F3622B291F5D16CC3A727AF90D75988F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/CrossSiteScripting.java"
          },
          "region" : {
            "startLine" : 384,
            "endLine" : 384,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "312",
      "message" : {
        "text" : "The function handleRequest() in CrossSiteScripting.java might reveal system data or debugging information by calling printStackTrace() on line 385.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "6848A018EE47A64FCA5A0F716FFE688A"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/CrossSiteScripting.java"
          },
          "region" : {
            "startLine" : 385,
            "endLine" : 385,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "558",
      "message" : {
        "text" : "The function getEmployeeProfile() in EditProfile.java might reveal system data or debugging information by calling printStackTrace() on line 125.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "BD4FADFC5F19C155B261ECC46F46E82D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/EditProfile.java"
          },
          "region" : {
            "startLine" : 125,
            "endLine" : 125,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1840",
      "message" : {
        "text" : "The catch block at EditProfile.java line 128 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F895A6CAB37A1636D3B9FBBEA23C9674"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/EditProfile.java"
          },
          "region" : {
            "startLine" : 128,
            "endLine" : 128,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "469",
      "message" : {
        "text" : "The function getEmployeeProfile() in EditProfile.java might reveal system data or debugging information by calling printStackTrace() on line 131.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "A1F3CAB3AF6B424ADC408CBF64AACBA5"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/EditProfile.java"
          },
          "region" : {
            "startLine" : 131,
            "endLine" : 131,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "471",
      "message" : {
        "text" : "The function getEmployeeProfile_BACKUP() in EditProfile.java might reveal system data or debugging information by calling printStackTrace() on line 183.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "A35E8449693CFFD71A5DF12FFDCBA587"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/EditProfile.java"
          },
          "region" : {
            "startLine" : 183,
            "endLine" : 183,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1821",
      "message" : {
        "text" : "The catch block at EditProfile.java line 186 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F225C68286E6C19D93D2C1E94F95F7D3"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/EditProfile.java"
          },
          "region" : {
            "startLine" : 186,
            "endLine" : 186,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "67",
      "message" : {
        "text" : "The function getEmployeeProfile_BACKUP() in EditProfile.java might reveal system data or debugging information by calling printStackTrace() on line 189.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "1628D80D60254DD5FE7AF2F02C279A5B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/EditProfile.java"
          },
          "region" : {
            "startLine" : 189,
            "endLine" : 189,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1119",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "481CC74E021AC4A5CE81F944517BE70B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/FindProfile.java"
          },
          "region" : {
            "startLine" : 120,
            "endLine" : 120,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1788",
      "message" : {
        "text" : "The function handleRequest() in FindProfile.java might reveal system data or debugging information by calling printStackTrace() on line 121.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D872647971F4264544026202303B0C13"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/FindProfile.java"
          },
          "region" : {
            "startLine" : 121,
            "endLine" : 121,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1120",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "481CC74E021AC4A5CE81F944517BE70C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/FindProfile.java"
          },
          "region" : {
            "startLine" : 125,
            "endLine" : 125,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1836",
      "message" : {
        "text" : "The function handleRequest() in FindProfile.java might reveal system data or debugging information by calling printStackTrace() on line 126.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F7FD358E0D1F0374731F1FA9D063D96F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/FindProfile.java"
          },
          "region" : {
            "startLine" : 126,
            "endLine" : 126,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "353",
      "message" : {
        "text" : "The function findEmployeeProfile() in FindProfile.java might reveal system data or debugging information by calling printStackTrace() on line 213.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "7BA6A8A7BD79BE08A61BCA60190284D4"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/FindProfile.java"
          },
          "region" : {
            "startLine" : 213,
            "endLine" : 213,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1592",
      "message" : {
        "text" : "The catch block at FindProfile.java line 216 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "349863551B1440EF6513F300D1F84040"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/FindProfile.java"
          },
          "region" : {
            "startLine" : 216,
            "endLine" : 216,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "166",
      "message" : {
        "text" : "The function findEmployeeProfile() in FindProfile.java might reveal system data or debugging information by calling printStackTrace() on line 219.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "35E084BA77E09CEA853C2E8B67EC5A90"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/FindProfile.java"
          },
          "region" : {
            "startLine" : 219,
            "endLine" : 219,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1331",
      "message" : {
        "text" : "The method foundEmployee() in FindProfile.java ignores an exception on line 235, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F23C1087E34409F5607C5C5C9FF79069"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/FindProfile.java"
          },
          "region" : {
            "startLine" : 235,
            "endLine" : 235,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1127",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "4CFCAFDD85B95ADCE288F8E77CEAB6F2"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 109,
            "endLine" : 109,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1684",
      "message" : {
        "text" : "The function handleRequest() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 110.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "820D9127C18956E39B7BFD623247D3DA"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 110,
            "endLine" : 110,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1128",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "4CFCAFDD85B95ADCE288F8E77CEAB6F3"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 114,
            "endLine" : 114,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1594",
      "message" : {
        "text" : "The function handleRequest() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 115.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "34F7DA75494088350E0041164CF31E69"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 115,
            "endLine" : 115,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1550",
      "message" : {
        "text" : "On line 248 of UpdateProfile.java, the method changeEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "102133874B3B236067674F95CDA65378"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 248,
            "endLine" : 248,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1562",
      "message" : {
        "text" : "On line 248 of UpdateProfile.java, the method changeEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "1BA016A253E02A521F93B3FE8326D3B6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 248,
            "endLine" : 248,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1616",
      "message" : {
        "text" : "On line 248 of UpdateProfile.java, the method changeEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "4C1FCFCA2C8B123EF5A2352B71C40263"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 248,
            "endLine" : 248,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1621",
      "message" : {
        "text" : "On line 248 of UpdateProfile.java, the method changeEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "4EEAB05EB064C3B925D99AAE170F718D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 248,
            "endLine" : 248,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1653",
      "message" : {
        "text" : "On line 248 of UpdateProfile.java, the method changeEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "6EB2F2FA65B0712F919DA4A441EA91C4"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 248,
            "endLine" : 248,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1712",
      "message" : {
        "text" : "On line 248 of UpdateProfile.java, the method changeEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "A17C4D04E1782E491588042AC8FE1D41"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 248,
            "endLine" : 248,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1741",
      "message" : {
        "text" : "On line 248 of UpdateProfile.java, the method changeEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "BCA3D333363FC5AC917286E91F517058"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 248,
            "endLine" : 248,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1762",
      "message" : {
        "text" : "On line 248 of UpdateProfile.java, the method changeEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "C7251E9EB27461586D6CA0B5DD1FED0C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 248,
            "endLine" : 248,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1786",
      "message" : {
        "text" : "On line 248 of UpdateProfile.java, the method changeEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "D6285BDE3B6367571257E12E7237E331"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 248,
            "endLine" : 248,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1795",
      "message" : {
        "text" : "On line 248 of UpdateProfile.java, the method changeEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "DECADC8CF18805DE8D393C1FF350A884"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 248,
            "endLine" : 248,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "70",
      "message" : {
        "text" : "The function changeEmployeeProfile() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 253.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "181A204DA906FACB0A0455C47657CF13"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 253,
            "endLine" : 253,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1587",
      "message" : {
        "text" : "The catch block at UpdateProfile.java line 257 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "2EF06EFC80CA9FC3BE40DB3F601F8239"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 257,
            "endLine" : 257,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "607",
      "message" : {
        "text" : "The function changeEmployeeProfile() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 260.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D8119249773A39CD022B883126F43C24"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 260,
            "endLine" : 260,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "592",
      "message" : {
        "text" : "On line 297 of UpdateProfile.java, the method doChangeEmployeeProfile_BACKUP() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D22EAF3DF450EDEF696802635C6007D6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 297,
            "endLine" : 297,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "405",
      "message" : {
        "text" : "The function doChangeEmployeeProfile_BACKUP() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 302.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "8E8BA4B0E6CF6803058E507305B358C3"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 302,
            "endLine" : 302,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1726",
      "message" : {
        "text" : "The catch block at UpdateProfile.java line 306 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B2272914D82DDB38D16D455828C529E1"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 306,
            "endLine" : 306,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "608",
      "message" : {
        "text" : "The function doChangeEmployeeProfile_BACKUP() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 309.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D9077301391A2AB9CFF320A0941B7299"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 309,
            "endLine" : 309,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1543",
      "message" : {
        "text" : "On line 340 of UpdateProfile.java, the method createEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "0AE1973FD4FF73765D0BEC7F8886DBFB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 340,
            "endLine" : 340,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1572",
      "message" : {
        "text" : "On line 340 of UpdateProfile.java, the method createEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "23738AA4672374B793E3F0B3EF6F77C2"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 340,
            "endLine" : 340,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1607",
      "message" : {
        "text" : "On line 340 of UpdateProfile.java, the method createEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "40F182886B5388EEFE531DC0B78022F2"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 340,
            "endLine" : 340,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1651",
      "message" : {
        "text" : "On line 340 of UpdateProfile.java, the method createEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "6D8E8E746A0B2870F8099EC8D0CBF6A0"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 340,
            "endLine" : 340,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1662",
      "message" : {
        "text" : "On line 340 of UpdateProfile.java, the method createEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "72F28D8F000869CC39934273918DB898"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 340,
            "endLine" : 340,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1705",
      "message" : {
        "text" : "On line 340 of UpdateProfile.java, the method createEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "9D3EBB494D095ACB73F8E6265896C275"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 340,
            "endLine" : 340,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1734",
      "message" : {
        "text" : "On line 340 of UpdateProfile.java, the method createEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "B8EC49F42C1791942978ED0508097358"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 340,
            "endLine" : 340,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1772",
      "message" : {
        "text" : "On line 340 of UpdateProfile.java, the method createEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "CD2D57A971D7F45E4E5903C44BB03E13"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 340,
            "endLine" : 340,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1773",
      "message" : {
        "text" : "On line 340 of UpdateProfile.java, the method createEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "CDB62E3970E486E23A3869664BE02CE7"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 340,
            "endLine" : 340,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1783",
      "message" : {
        "text" : "On line 340 of UpdateProfile.java, the method createEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "D32951D526755AC8D8AE2790B9BC4289"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 340,
            "endLine" : 340,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1822",
      "message" : {
        "text" : "On line 340 of UpdateProfile.java, the method createEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "F241067F505B2D49558AEB12BAEB3A86"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 340,
            "endLine" : 340,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1844",
      "message" : {
        "text" : "On line 340 of UpdateProfile.java, the method createEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "FBEE1D44AE79C9DBD77CF348837EC499"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 340,
            "endLine" : 340,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "164",
      "message" : {
        "text" : "The function createEmployeeProfile() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 345.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "348D9FB5ADC466B0BF5C0E5163F660CB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 345,
            "endLine" : 345,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1820",
      "message" : {
        "text" : "The catch block at UpdateProfile.java line 348 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F15DA3960EE5AC46A5FFA169F84C1F62"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 348,
            "endLine" : 348,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "201",
      "message" : {
        "text" : "The function createEmployeeProfile() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 351.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "3DDF4C741AC3A01CBE48D925C7B3268F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 351,
            "endLine" : 351,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "508",
      "message" : {
        "text" : "On line 382 of UpdateProfile.java, the method createEmployeeProfile_BACKUP() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "ADB2838EEF4321355CBA5524A2E21C12"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 382,
            "endLine" : 382,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "599",
      "message" : {
        "text" : "The function createEmployeeProfile_BACKUP() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 387.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D60D775DBDAE54DDEBF316C5113E73DC"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 387,
            "endLine" : 387,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1799",
      "message" : {
        "text" : "The catch block at UpdateProfile.java line 390 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "E1B463F82834469B4244B82822DE919E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 390,
            "endLine" : 390,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "612",
      "message" : {
        "text" : "The function createEmployeeProfile_BACKUP() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 393.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D9A6AE2AC85C0E39449C242C052F302B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 393,
            "endLine" : 393,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "239",
      "message" : {
        "text" : "The function getEmployeeProfile() in ViewProfile.java might reveal system data or debugging information by calling printStackTrace() on line 140.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "4FDA9B15885A673A877D3550A8CABB1E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/ViewProfile.java"
          },
          "region" : {
            "startLine" : 140,
            "endLine" : 140,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1758",
      "message" : {
        "text" : "The catch block at ViewProfile.java line 143 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "C4D54C64E816134C129CC4FB04CE5624"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/ViewProfile.java"
          },
          "region" : {
            "startLine" : 143,
            "endLine" : 143,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "348",
      "message" : {
        "text" : "The function getEmployeeProfile() in ViewProfile.java might reveal system data or debugging information by calling printStackTrace() on line 146.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "7A4AD89F74574F83E5609198EF01BDC2"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/ViewProfile.java"
          },
          "region" : {
            "startLine" : 146,
            "endLine" : 146,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "38",
      "message" : {
        "text" : "On line 172 of ViewProfile.java, the method getEmployeeProfile_BACKUP() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "125AFBB5C27425AA50E71B144AE97786"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/ViewProfile.java"
          },
          "region" : {
            "startLine" : 172,
            "endLine" : 172,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "210",
      "message" : {
        "text" : "The function getEmployeeProfile_BACKUP() in ViewProfile.java might reveal system data or debugging information by calling printStackTrace() on line 200.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "435FCB107394C1B62FA1D1B941C914E7"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/ViewProfile.java"
          },
          "region" : {
            "startLine" : 200,
            "endLine" : 200,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1696",
      "message" : {
        "text" : "The catch block at ViewProfile.java line 203 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "93CE2393E73626FF83259F7BF183836D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/ViewProfile.java"
          },
          "region" : {
            "startLine" : 203,
            "endLine" : 203,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "195",
      "message" : {
        "text" : "The function getEmployeeProfile_BACKUP() in ViewProfile.java might reveal system data or debugging information by calling printStackTrace() on line 206.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "3C5D38A41A6EB2D7820B964AB70ED332"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/CrossSiteScripting/ViewProfile.java"
          },
          "region" : {
            "startLine" : 206,
            "endLine" : 206,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1316",
      "message" : {
        "text" : "The catch block at DOMInjection.java line 89 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "E094301BE5A2AD6CE88C5C1EA1DF7303"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/DOMInjection.java"
          },
          "region" : {
            "startLine" : 89,
            "endLine" : 89,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "458",
      "message" : {
        "text" : "The function createContent() in DOMInjection.java might reveal system data or debugging information by calling printStackTrace() on line 92.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "9EA2F7ECE0EB7F2DFEA0C97602F3136D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/DOMInjection.java"
          },
          "region" : {
            "startLine" : 92,
            "endLine" : 92,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "413",
      "message" : {
        "text" : "Hardcoded passwords can compromise system security in a way that cannot be easily remedied.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "92F0529952890D159704864A64A192D1"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/DOS_Login.java"
          },
          "region" : {
            "startLine" : 64,
            "endLine" : 64,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1273",
      "message" : {
        "text" : "Empty passwords can compromise system security in a way that cannot be easily remedied.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "C59C95ED474FD05F7CB5280ED6D5E9E6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/DOS_Login.java"
          },
          "region" : {
            "startLine" : 87,
            "endLine" : 87,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1743",
      "message" : {
        "text" : "On line 114 of DOS_Login.java, the method createContent() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "BDB979C5A4BED6AFC08178F9E4372662"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/DOS_Login.java"
          },
          "region" : {
            "startLine" : 114,
            "endLine" : 114,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1634",
      "message" : {
        "text" : "On line 134 of DOS_Login.java, the method createContent() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "609AB6BC75F18101BAF34F183F5F90BB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/DOS_Login.java"
          },
          "region" : {
            "startLine" : 134,
            "endLine" : 134,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "169",
      "message" : {
        "text" : "On line 139 of DOS_Login.java, the method createContent() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "360E3CE77448ED1F01C49BC9140332C0"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/DOS_Login.java"
          },
          "region" : {
            "startLine" : 139,
            "endLine" : 139,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "473",
      "message" : {
        "text" : "On line 147 of DOS_Login.java, the method createContent() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "A3CC95BCD894EAD3D13DABC323E3D63B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/DOS_Login.java"
          },
          "region" : {
            "startLine" : 147,
            "endLine" : 147,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "168",
      "message" : {
        "text" : "On line 162 of DOS_Login.java, the method createContent() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "360E3CE77448ED1F01C49BC9140332BF"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/DOS_Login.java"
          },
          "region" : {
            "startLine" : 162,
            "endLine" : 162,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "505",
      "message" : {
        "text" : "The function createContent() in DOS_Login.java might reveal system data or debugging information by calling printStackTrace() on line 172.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "AD77F23B2F560ACFD13DFB3502BC039A"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/DOS_Login.java"
          },
          "region" : {
            "startLine" : 172,
            "endLine" : 172,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1261",
      "message" : {
        "text" : "The catch block at DOS_Login.java line 175 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B85AB37C215E8F38F75A4F5BAC72C4C6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/DOS_Login.java"
          },
          "region" : {
            "startLine" : 175,
            "endLine" : 175,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1237",
      "message" : {
        "text" : "The method getIntSessionAttribute() in DefaultLessonAction.java ignores an exception on line 145, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "ABE768E5DB127C1880CAC97B6FD02B02"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/DefaultLessonAction.java"
          },
          "region" : {
            "startLine" : 145,
            "endLine" : 145,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1304",
      "message" : {
        "text" : "The method getIntRequestAttribute() in DefaultLessonAction.java ignores an exception on line 178, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D74773F2B70F375A5CC8F8E4E041126B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/DefaultLessonAction.java"
          },
          "region" : {
            "startLine" : 178,
            "endLine" : 178,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "626",
      "message" : {
        "text" : "On line 203 of DefaultLessonAction.java, the method getUserName() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "DDA192CA04BD34CB09615F5ADA6D6D06"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/DefaultLessonAction.java"
          },
          "region" : {
            "startLine" : 203,
            "endLine" : 203,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "254",
      "message" : {
        "text" : "The function getUserName() in DefaultLessonAction.java might reveal system data or debugging information by calling printStackTrace() on line 210.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "58FD40089E718B766C6FA96FD22C8D81"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/DefaultLessonAction.java"
          },
          "region" : {
            "startLine" : 210,
            "endLine" : 210,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1252",
      "message" : {
        "text" : "The catch block at DefaultLessonAction.java line 213 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B409E99A33FDC4241E8D86D237E45FCC"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/DefaultLessonAction.java"
          },
          "region" : {
            "startLine" : 213,
            "endLine" : 213,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "212",
      "message" : {
        "text" : "The function getUserName() in DefaultLessonAction.java might reveal system data or debugging information by calling printStackTrace() on line 216.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "450EDF14D048E6125EA598D94E9995C0"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/DefaultLessonAction.java"
          },
          "region" : {
            "startLine" : 216,
            "endLine" : 216,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1173",
      "message" : {
        "text" : "The method isAuthenticated() in DefaultLessonAction.java ignores an exception on line 236, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "769FB1D68E26C32059C84C220A85D193"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/DefaultLessonAction.java"
          },
          "region" : {
            "startLine" : 236,
            "endLine" : 236,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "545",
      "message" : {
        "text" : "On line 256 of DefaultLessonAction.java, the method isAuthorized() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B9D18A1B80F2CE2982A1DF0C011D7BFC"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/DefaultLessonAction.java"
          },
          "region" : {
            "startLine" : 256,
            "endLine" : 256,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "544",
      "message" : {
        "text" : "On line 265 of DefaultLessonAction.java, the method isAuthorized() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B9D18A1B80F2CE2982A1DF0C011D7BFB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/DefaultLessonAction.java"
          },
          "region" : {
            "startLine" : 265,
            "endLine" : 265,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "33",
      "message" : {
        "text" : "The function isAuthorized() in DefaultLessonAction.java might reveal system data or debugging information by calling printStackTrace() on line 272.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "10D794BC1E42F40B8C7789FAB6124876"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/DefaultLessonAction.java"
          },
          "region" : {
            "startLine" : 272,
            "endLine" : 272,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1282",
      "message" : {
        "text" : "The catch block at DefaultLessonAction.java line 275 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "CB037CB8BCEA4B8C012A909978867083"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/DefaultLessonAction.java"
          },
          "region" : {
            "startLine" : 275,
            "endLine" : 275,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "569",
      "message" : {
        "text" : "The function isAuthorized() in DefaultLessonAction.java might reveal system data or debugging information by calling printStackTrace() on line 278.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "C29E60A69A0EFA8B7965E98438EF7399"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/DefaultLessonAction.java"
          },
          "region" : {
            "startLine" : 278,
            "endLine" : 278,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "202",
      "message" : {
        "text" : "The function isAuthorizedForEmployee() in DefaultLessonAction.java might reveal system data or debugging information by calling printStackTrace() on line 320.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "3F6FFF90338B5D7AD8036C3213B71E6F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/DefaultLessonAction.java"
          },
          "region" : {
            "startLine" : 320,
            "endLine" : 320,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1339",
      "message" : {
        "text" : "The catch block at DefaultLessonAction.java line 323 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F73424BDB903FB4CBC3231399EBF1980"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/DefaultLessonAction.java"
          },
          "region" : {
            "startLine" : 323,
            "endLine" : 323,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "375",
      "message" : {
        "text" : "The function isAuthorizedForEmployee() in DefaultLessonAction.java might reveal system data or debugging information by calling printStackTrace() on line 326.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "81034BADE3549CFFE651854181BA6561"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/DefaultLessonAction.java"
          },
          "region" : {
            "startLine" : 326,
            "endLine" : 326,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1678",
      "message" : {
        "text" : "The method createContent() in Encoding.java sends unvalidated data to a web browser on line 359, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "7E29B49E42036569BB51EF5AD7810192"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 359,
            "endLine" : 359,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1591",
      "message" : {
        "text" : "The method createContent() in Encoding.java sends unvalidated data to a web browser on line 369, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "33ADB22325F193F677D42E030B2918D4"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 369,
            "endLine" : 369,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1344",
      "message" : {
        "text" : "The catch block at Encoding.java line 454 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "FA89BB7A1F8F3D3C0EE4DDF569255312"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 454,
            "endLine" : 454,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "408",
      "message" : {
        "text" : "The function createContent() in Encoding.java might reveal system data or debugging information by calling printStackTrace() on line 459.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "8F8078791C5A9942DFCEEC021779672F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 459,
            "endLine" : 459,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "88",
      "message" : {
        "text" : "The program uses a weak encryption algorithm that cannot guarantee the confidentiality of sensitive data.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "1D385E28C2D8A9E9F68F0AB8888B5EDF"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 489,
            "endLine" : 489,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "165",
      "message" : {
        "text" : "The program uses a weak encryption algorithm that cannot guarantee the confidentiality of sensitive data.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "348DE279CA4677D539557F0772DC215F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 491,
            "endLine" : 491,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "211",
      "message" : {
        "text" : "The catch block at Encoding.java line 506 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "4393AAA5E6FF2AAE50E53DB18E0ED96E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 506,
            "endLine" : 506,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "374",
      "message" : {
        "text" : "The program uses a weak encryption algorithm that cannot guarantee the confidentiality of sensitive data.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "80F4A07EEEB4A2FFE6B25E72C01862B9"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 533,
            "endLine" : 533,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "387",
      "message" : {
        "text" : "The program uses a weak encryption algorithm that cannot guarantee the confidentiality of sensitive data.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "8703C5DCE8BC7D1128B656E2516864AA"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 535,
            "endLine" : 535,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "314",
      "message" : {
        "text" : "The catch block at Encoding.java line 550 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "69AFA8F30F5B963A36227586517A896A"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 550,
            "endLine" : 550,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "174",
      "message" : {
        "text" : "Weak cryptographic hashes cannot guarantee data integrity and should not be used in security-critical contexts.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "387A6E66112334525B764D5859E55E28"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 640,
            "endLine" : 640,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "106",
      "message" : {
        "text" : "The function hashMD5() in Encoding.java might reveal system data or debugging information by calling printStackTrace() on line 646.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "23B0D96DBFC08A66930F5E2F13D76E31"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 646,
            "endLine" : 646,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "238",
      "message" : {
        "text" : "The function hashSHA() in Encoding.java might reveal system data or debugging information by calling printStackTrace() on line 672.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "4F0DE05D9365625B7CCD08D58B128F2D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 672,
            "endLine" : 672,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "264",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5CB1C5DBB07B0DC28312DFF53243B8CB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 746,
            "endLine" : 746,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "265",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5CB1C5DBB07B0DC28312DFF53243B8CC"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 747,
            "endLine" : 747,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "266",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5CB1C5DBB07B0DC28312DFF53243B8CD"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 748,
            "endLine" : 748,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "267",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5CB1C5DBB07B0DC28312DFF53243B8CE"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 749,
            "endLine" : 749,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "268",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5CB1C5DBB07B0DC28312DFF53243B8CF"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 750,
            "endLine" : 750,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "269",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5CB1C5DBB07B0DC28312DFF53243B8D0"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 751,
            "endLine" : 751,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "270",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5CB1C5DBB07B0DC28312DFF53243B8D1"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 752,
            "endLine" : 752,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "271",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5CB1C5DBB07B0DC28312DFF53243B8D2"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 753,
            "endLine" : 753,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "272",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5CB1C5DBB07B0DC28312DFF53243B8D3"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 754,
            "endLine" : 754,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "273",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5CB1C5DBB07B0DC28312DFF53243B8D4"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 755,
            "endLine" : 755,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "274",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5CB1C5DBB07B0DC28312DFF53243B8D5"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 756,
            "endLine" : 756,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "275",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5CB1C5DBB07B0DC28312DFF53243B8D6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 757,
            "endLine" : 757,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "276",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5CB1C5DBB07B0DC28312DFF53243B8D7"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 758,
            "endLine" : 758,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "277",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5CB1C5DBB07B0DC28312DFF53243B8D8"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 759,
            "endLine" : 759,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "278",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5CB1C5DBB07B0DC28312DFF53243B8D9"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 760,
            "endLine" : 760,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "279",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5CB1C5DBB07B0DC28312DFF53243B8DA"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 761,
            "endLine" : 761,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "280",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5CB1C5DBB07B0DC28312DFF53243B8DB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 762,
            "endLine" : 762,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "281",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5CB1C5DBB07B0DC28312DFF53243B8DC"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 763,
            "endLine" : 763,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "282",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5CB1C5DBB07B0DC28312DFF53243B8DD"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 764,
            "endLine" : 764,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "283",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5CB1C5DBB07B0DC28312DFF53243B8DE"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 765,
            "endLine" : 765,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "284",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5CB1C5DBB07B0DC28312DFF53243B8DF"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 766,
            "endLine" : 766,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "285",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5CB1C5DBB07B0DC28312DFF53243B8E0"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 767,
            "endLine" : 767,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "286",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5CB1C5DBB07B0DC28312DFF53243B8E1"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 768,
            "endLine" : 768,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "287",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5CB1C5DBB07B0DC28312DFF53243B8E2"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 769,
            "endLine" : 769,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "288",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5CB1C5DBB07B0DC28312DFF53243B8E3"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 770,
            "endLine" : 770,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "3",
      "message" : {
        "text" : "The function main() in Encoding.java might reveal system data or debugging information by calling printStackTrace() on line 774.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "047AD488FEFFFA0C26F978A64B811539"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 774,
            "endLine" : 774,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1749",
      "message" : {
        "text" : "The method makeRow() in Encoding.java sends unvalidated data to a web browser on line 793, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "BEDCCF5FAF96831DFB46C298DEA5D5F1"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 793,
            "endLine" : 793,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1778",
      "message" : {
        "text" : "The method makeRow() in Encoding.java sends unvalidated data to a web browser on line 793, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "D06D0B220A3FD266C8526B6593E997D2"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 793,
            "endLine" : 793,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1688",
      "message" : {
        "text" : "The method makeRow() in Encoding.java sends unvalidated data to a web browser on line 794, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "8ADD0449AB48BA588FCC57E4041FC215"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 794,
            "endLine" : 794,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1774",
      "message" : {
        "text" : "The method makeRow() in Encoding.java sends unvalidated data to a web browser on line 794, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "CDC14D16B2CD1B1BA14427B6ECE70C10"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 794,
            "endLine" : 794,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "355",
      "message" : {
        "text" : "The catch block at Encoding.java line 888 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "7C97574C3CAD67BA5CD63D67D481A34A"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 888,
            "endLine" : 888,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "162",
      "message" : {
        "text" : "The catch block at Encoding.java line 913 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "343C03986DD94B14AE89E112D9996126"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 913,
            "endLine" : 913,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "443",
      "message" : {
        "text" : "The catch block at Encoding.java line 934 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "9904A183BAB676911A2289782DC66DDE"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 934,
            "endLine" : 934,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "341",
      "message" : {
        "text" : "The catch block at Encoding.java line 955 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "753A183455F634315530AE1E98A143DF"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 955,
            "endLine" : 955,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "614",
      "message" : {
        "text" : "The catch block at Encoding.java line 1010 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "DA56595234EEEA123859B0B222390CC4"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/Encoding.java"
          },
          "region" : {
            "startLine" : 1010,
            "endLine" : 1010,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1038",
      "message" : {
        "text" : "The catch block at FailOpenAuthentication.java line 83 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "0DE544B64FCA127F87821524FA7D9AD5"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/FailOpenAuthentication.java"
          },
          "region" : {
            "startLine" : 83,
            "endLine" : 83,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1039",
      "message" : {
        "text" : "The catch block at FailOpenAuthentication.java line 120 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "0DE544B64FCA127F87821524FA7D9AD6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/FailOpenAuthentication.java"
          },
          "region" : {
            "startLine" : 120,
            "endLine" : 120,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1812",
      "message" : {
        "text" : "The method doStage3() in ForgotPassword.java sends unvalidated data to a web browser on line 191, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "EA39016909F45F53EEFCE398478A6CEC"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/ForgotPassword.java"
          },
          "region" : {
            "startLine" : 191,
            "endLine" : 191,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1813",
      "message" : {
        "text" : "The method doStage3() in ForgotPassword.java sends unvalidated data to a web browser on line 195, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "EA39016909F45F53EEFCE398478A6CED"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/ForgotPassword.java"
          },
          "region" : {
            "startLine" : 195,
            "endLine" : 195,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1340",
      "message" : {
        "text" : "The catch block at HiddenFieldTampering.java line 162 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F781AE2F2B5CFCB65D86E93F9447C3BB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/HiddenFieldTampering.java"
          },
          "region" : {
            "startLine" : 162,
            "endLine" : 162,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "42",
      "message" : {
        "text" : "The function createContent() in HiddenFieldTampering.java might reveal system data or debugging information by calling printStackTrace() on line 165.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "131F17E79F63F981BB3DAA10455F2822"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/HiddenFieldTampering.java"
          },
          "region" : {
            "startLine" : 165,
            "endLine" : 165,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1104",
      "message" : {
        "text" : "Hardcoded passwords can compromise system security in a way that cannot be easily remedied.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "3E9A67399C7A2107EBB53F4242B220BB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/HtmlClues.java"
          },
          "region" : {
            "startLine" : 83,
            "endLine" : 83,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1353",
      "message" : {
        "text" : "The catch block at HtmlClues.java line 117 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "FEE47E13497AADC6846BF2CF26134240"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/HtmlClues.java"
          },
          "region" : {
            "startLine" : 117,
            "endLine" : 117,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1116",
      "message" : {
        "text" : "The method makeUser() in HtmlClues.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "4767A39CC82624C8DF94CE558388608F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/HtmlClues.java"
          },
          "region" : {
            "startLine" : 135,
            "endLine" : 135,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1725",
      "message" : {
        "text" : "The method createContent() in HttpBasics.java sends unvalidated data to a web browser on line 69, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "AD369356003E8FDF1BE045DC0DBD47C6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/HttpBasics.java"
          },
          "region" : {
            "startLine" : 69,
            "endLine" : 69,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1218",
      "message" : {
        "text" : "The catch block at HttpBasics.java line 75 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "9A64EB5F4DAAD544B98B7A3F77888671"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/HttpBasics.java"
          },
          "region" : {
            "startLine" : 75,
            "endLine" : 75,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "326",
      "message" : {
        "text" : "The function createContent() in HttpBasics.java might reveal system data or debugging information by calling printStackTrace() on line 78.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "705FAE3DBC111FD136600AFD4984E076"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/HttpBasics.java"
          },
          "region" : {
            "startLine" : 78,
            "endLine" : 78,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1197",
      "message" : {
        "text" : "The catch block at HttpOnly.java line 135 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "86B0143484F9727BE30DABC842B2E830"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/HttpOnly.java"
          },
          "region" : {
            "startLine" : 135,
            "endLine" : 135,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "459",
      "message" : {
        "text" : "The function createContent() in HttpOnly.java might reveal system data or debugging information by calling printStackTrace() on line 138.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "9F51D6250F83EF2B7731EF14E7136769"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/HttpOnly.java"
          },
          "region" : {
            "startLine" : 138,
            "endLine" : 138,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "352",
      "message" : {
        "text" : "Weak cryptographic hashes cannot guarantee data integrity and should not be used in security-critical contexts.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "7B3C46156F8E01CD8D68BF30D9E9F0D0"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/HttpOnly.java"
          },
          "region" : {
            "startLine" : 175,
            "endLine" : 175,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "621",
      "message" : {
        "text" : "The catch block at HttpOnly.java line 182 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "DC120EC648920C0CB86F457A3F43AE04"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/HttpOnly.java"
          },
          "region" : {
            "startLine" : 182,
            "endLine" : 182,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "421",
      "message" : {
        "text" : "The function createCustomCookieValue() in HttpOnly.java might reveal system data or debugging information by calling printStackTrace() on line 183.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "95782931E073FCBD728BDF3DA7F39E90"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/HttpOnly.java"
          },
          "region" : {
            "startLine" : 183,
            "endLine" : 183,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1161",
      "message" : {
        "text" : "The method makeContent() in HttpOnly.java sends unvalidated data to a web browser on line 233, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "699EC0C6D59F22AD41D6C82B0643977E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/HttpOnly.java"
          },
          "region" : {
            "startLine" : 233,
            "endLine" : 233,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1742",
      "message" : {
        "text" : "The method doHTTPSplitting() in HttpSplitting.java sends unvalidated data to a web browser on line 112, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "BCE407BB56586EA1ECB60962B79933E8"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/HttpSplitting.java"
          },
          "region" : {
            "startLine" : 112,
            "endLine" : 112,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1031",
      "message" : {
        "text" : "The catch block at HttpSplitting.java line 134 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "087ABE155D9A70976AC25EB45032F4DB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/HttpSplitting.java"
          },
          "region" : {
            "startLine" : 134,
            "endLine" : 134,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "260",
      "message" : {
        "text" : "The function doHTTPSplitting() in HttpSplitting.java might reveal system data or debugging information by calling printStackTrace() on line 137.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5C63D969F93AD4F6406AD4E5C137651D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/HttpSplitting.java"
          },
          "region" : {
            "startLine" : 137,
            "endLine" : 137,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1250",
      "message" : {
        "text" : "The method createAttackEnvironment() in HttpSplitting.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B1EAD77CBD01B93091502EBF26A4247B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/HttpSplitting.java"
          },
          "region" : {
            "startLine" : 161,
            "endLine" : 161,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1703",
      "message" : {
        "text" : "The method createAttackEnvironment() in HttpSplitting.java sends unvalidated data to a web browser on line 180, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "9A75C2F16C64D536498D5DE279270851"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/HttpSplitting.java"
          },
          "region" : {
            "startLine" : 180,
            "endLine" : 180,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1203",
      "message" : {
        "text" : "The method doCachePoisining() in HttpSplitting.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "8C3759D2B027E1A49E71D3884549506C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/HttpSplitting.java"
          },
          "region" : {
            "startLine" : 191,
            "endLine" : 191,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1248",
      "message" : {
        "text" : "The catch block at HttpSplitting.java line 235 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B02AB669464EFCA850ADAB79153AB0F3"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/HttpSplitting.java"
          },
          "region" : {
            "startLine" : 235,
            "endLine" : 235,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1284",
      "message" : {
        "text" : "The catch block at JSONInjection.java line 96 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "CC441EE121689CBCFF5985EF5C6F0192"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/JSONInjection.java"
          },
          "region" : {
            "startLine" : 96,
            "endLine" : 96,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "649",
      "message" : {
        "text" : "The function handleRequest() in JSONInjection.java might reveal system data or debugging information by calling printStackTrace() on line 98.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "E8EF5733799D99324748E618EBE6DC59"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/JSONInjection.java"
          },
          "region" : {
            "startLine" : 98,
            "endLine" : 98,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1661",
      "message" : {
        "text" : "The method createContent() in JavaScriptValidation.java sends unvalidated data to a web browser on line 151, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "7254A7590AFC4358ECE78B61DC667AC7"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/JavaScriptValidation.java"
          },
          "region" : {
            "startLine" : 151,
            "endLine" : 151,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1561",
      "message" : {
        "text" : "The method createContent() in JavaScriptValidation.java sends unvalidated data to a web browser on line 152, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "19446190ED48006EA5FC0AC7391FB73C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/JavaScriptValidation.java"
          },
          "region" : {
            "startLine" : 152,
            "endLine" : 152,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1807",
      "message" : {
        "text" : "The method createContent() in JavaScriptValidation.java sends unvalidated data to a web browser on line 153, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "E7650F080FCA7F6E00F264D3F365723C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/JavaScriptValidation.java"
          },
          "region" : {
            "startLine" : 153,
            "endLine" : 153,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1582",
      "message" : {
        "text" : "The method createContent() in JavaScriptValidation.java sends unvalidated data to a web browser on line 154, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "2B2E80C3F1C5324EC70FFBD406310CAB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/JavaScriptValidation.java"
          },
          "region" : {
            "startLine" : 154,
            "endLine" : 154,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1560",
      "message" : {
        "text" : "The method createContent() in JavaScriptValidation.java sends unvalidated data to a web browser on line 155, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "164F50FC73966E07C13D9DBF85E6B422"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/JavaScriptValidation.java"
          },
          "region" : {
            "startLine" : 155,
            "endLine" : 155,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1536",
      "message" : {
        "text" : "The method createContent() in JavaScriptValidation.java sends unvalidated data to a web browser on line 156, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "011CBF50B0452709FF1FE1CC8FA779EA"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/JavaScriptValidation.java"
          },
          "region" : {
            "startLine" : 156,
            "endLine" : 156,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1605",
      "message" : {
        "text" : "The method createContent() in JavaScriptValidation.java sends unvalidated data to a web browser on line 157, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "3E1DFE39AC6795E887C355DBA577DA93"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/JavaScriptValidation.java"
          },
          "region" : {
            "startLine" : 157,
            "endLine" : 157,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1070",
      "message" : {
        "text" : "The catch block at JavaScriptValidation.java line 256 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "22A4836C713C17B989180F3ECF1010FA"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/JavaScriptValidation.java"
          },
          "region" : {
            "startLine" : 256,
            "endLine" : 256,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "713",
      "message" : {
        "text" : "The function createContent() in JavaScriptValidation.java might reveal system data or debugging information by calling printStackTrace() on line 259.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "FC52535F6E6C764EA9B84AD5EA60A650"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/JavaScriptValidation.java"
          },
          "region" : {
            "startLine" : 259,
            "endLine" : 259,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1271",
      "message" : {
        "text" : "The function createContent() in LessonAdapter.java sometimes fails to release a system resource allocated by FileReader() on line 93.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "C4EC2EDAF3F91A3A50B5499E737521B1"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/LessonAdapter.java"
          },
          "region" : {
            "startLine" : 93,
            "endLine" : 93,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1083",
      "message" : {
        "text" : "The method createContent() in LessonAdapter.java ignores an exception on line 101, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "2EE47323376419DC1AC49BFA7555650D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/LessonAdapter.java"
          },
          "region" : {
            "startLine" : 101,
            "endLine" : 101,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1084",
      "message" : {
        "text" : "The catch block at LessonAdapter.java line 101 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "2F63C2CCFAE28AED6CFE759ECFC70042"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/LessonAdapter.java"
          },
          "region" : {
            "startLine" : 101,
            "endLine" : 101,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1220",
      "message" : {
        "text" : "The catch block at LessonAdapter.java line 133 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "9CC762D4A5363E23A8411E24D9256C7C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/LessonAdapter.java"
          },
          "region" : {
            "startLine" : 133,
            "endLine" : 133,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "559",
      "message" : {
        "text" : "The function createStagedContent() in LessonAdapter.java might reveal system data or debugging information by calling println() on line 136.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "BEB4814E49EAA11F2CEA573D16ECDB6E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/LessonAdapter.java"
          },
          "region" : {
            "startLine" : 136,
            "endLine" : 136,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1230",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "A99D14BD0EF414E4CC24FC619B870E81"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/LessonAdapter.java"
          },
          "region" : {
            "startLine" : 136,
            "endLine" : 136,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "89",
      "message" : {
        "text" : "The function createStagedContent() in LessonAdapter.java might reveal system data or debugging information by calling printStackTrace() on line 137.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "1D501737C15AE10645708C25342F008F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/LessonAdapter.java"
          },
          "region" : {
            "startLine" : 137,
            "endLine" : 137,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1069",
      "message" : {
        "text" : "The method doStage1() in LessonAdapter.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "210AA1A8EFBCB73D3D72870FCFCE5041"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/LessonAdapter.java"
          },
          "region" : {
            "startLine" : 144,
            "endLine" : 144,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1138",
      "message" : {
        "text" : "The method doStage2() in LessonAdapter.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5503BCF906889669D3706765FAA2A3D8"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/LessonAdapter.java"
          },
          "region" : {
            "startLine" : 152,
            "endLine" : 152,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1113",
      "message" : {
        "text" : "The method doStage3() in LessonAdapter.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "444E18A164A77C9987658EB0D0F46EBF"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/LessonAdapter.java"
          },
          "region" : {
            "startLine" : 160,
            "endLine" : 160,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1068",
      "message" : {
        "text" : "The method doStage4() in LessonAdapter.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "20D8D8DC490B4033D5BED8E678B7B761"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/LessonAdapter.java"
          },
          "region" : {
            "startLine" : 168,
            "endLine" : 168,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1337",
      "message" : {
        "text" : "The method doStage5() in LessonAdapter.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F3E81447B7A253F2AB8E9FF9EBE13A3F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/LessonAdapter.java"
          },
          "region" : {
            "startLine" : 176,
            "endLine" : 176,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1183",
      "message" : {
        "text" : "The method doStage6() in LessonAdapter.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "7DCAF2F4819DDFC80CC5DDD5783F98D8"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/LessonAdapter.java"
          },
          "region" : {
            "startLine" : 184,
            "endLine" : 184,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1283",
      "message" : {
        "text" : "The function getInstructions() in LessonAdapter.java sometimes fails to release a system resource allocated by FileReader() on line 285.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "CB8421F4774F0AA99840B6DD04FD0829"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/LessonAdapter.java"
          },
          "region" : {
            "startLine" : 285,
            "endLine" : 285,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1117",
      "message" : {
        "text" : "The catch block at LessonAdapter.java line 307 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "479D8434A7EC31083CB113B28A3585E9"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/LessonAdapter.java"
          },
          "region" : {
            "startLine" : 307,
            "endLine" : 307,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1177",
      "message" : {
        "text" : "The method getInstructions() in LessonAdapter.java ignores an exception on line 307, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "79B88F7181952E921D27629409A338C8"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/LessonAdapter.java"
          },
          "region" : {
            "startLine" : 307,
            "endLine" : 307,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "371",
      "message" : {
        "text" : "The function createContent() in LogSpoofing.java might reveal system data or debugging information by calling printStackTrace() on line 128.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "808268520EA61ACECDD3CE502C001181"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/LogSpoofing.java"
          },
          "region" : {
            "startLine" : 128,
            "endLine" : 128,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1266",
      "message" : {
        "text" : "The function createContent() in PathBasedAccessControl.java sometimes fails to release a system resource allocated by FileReader() on line 193.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "C18864ACC2F321D56CB007715E732C95"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/PathBasedAccessControl.java"
          },
          "region" : {
            "startLine" : 192,
            "endLine" : 192,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1081",
      "message" : {
        "text" : "The catch block at PathBasedAccessControl.java line 205 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "2E131433EC8F7F66252F9B914828ED18"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/PathBasedAccessControl.java"
          },
          "region" : {
            "startLine" : 205,
            "endLine" : 205,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1082",
      "message" : {
        "text" : "The catch block at PathBasedAccessControl.java line 214 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "2E131433EC8F7F66252F9B914828ED19"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/PathBasedAccessControl.java"
          },
          "region" : {
            "startLine" : 214,
            "endLine" : 214,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "617",
      "message" : {
        "text" : "The function createContent() in PathBasedAccessControl.java might reveal system data or debugging information by calling printStackTrace() on line 217.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "DABE998A0B6FAD79EB0991E4EAAC181B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/PathBasedAccessControl.java"
          },
          "region" : {
            "startLine" : 217,
            "endLine" : 217,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1636",
      "message" : {
        "text" : "The method createContent() in ReflectedXSS.java sends unvalidated data to a web browser on line 123, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "67479E5D27D466B1FF4EC8510AF92AAB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/ReflectedXSS.java"
          },
          "region" : {
            "startLine" : 123,
            "endLine" : 123,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1744",
      "message" : {
        "text" : "The method createContent() in ReflectedXSS.java sends unvalidated data to a web browser on line 136, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "BDC530F36AC693299AFA524089900733"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/ReflectedXSS.java"
          },
          "region" : {
            "startLine" : 136,
            "endLine" : 136,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1578",
      "message" : {
        "text" : "The method createContent() in ReflectedXSS.java sends unvalidated data to a web browser on line 150, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "27054C1C60FF93F008A72761A672E678"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/ReflectedXSS.java"
          },
          "region" : {
            "startLine" : 150,
            "endLine" : 150,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1548",
      "message" : {
        "text" : "The method createContent() in ReflectedXSS.java sends unvalidated data to a web browser on line 165, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "0E0CE8A9C2B1F827612536E92E906C5D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/ReflectedXSS.java"
          },
          "region" : {
            "startLine" : 165,
            "endLine" : 165,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1664",
      "message" : {
        "text" : "The method createContent() in ReflectedXSS.java sends unvalidated data to a web browser on line 200, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "737A32658038060D09F9D4E83CEDD366"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/ReflectedXSS.java"
          },
          "region" : {
            "startLine" : 200,
            "endLine" : 200,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1593",
      "message" : {
        "text" : "The method createContent() in ReflectedXSS.java sends unvalidated data to a web browser on line 206, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "34B726630369800850C455085CAE1693"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/ReflectedXSS.java"
          },
          "region" : {
            "startLine" : 206,
            "endLine" : 206,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1142",
      "message" : {
        "text" : "The catch block at ReflectedXSS.java line 219 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5D57D541A4E77A3C27CEC7F47437BC72"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/ReflectedXSS.java"
          },
          "region" : {
            "startLine" : 219,
            "endLine" : 219,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "692",
      "message" : {
        "text" : "The function createContent() in ReflectedXSS.java might reveal system data or debugging information by calling printStackTrace() on line 222.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F570B583EF594B28853E556BE72B33B8"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/ReflectedXSS.java"
          },
          "region" : {
            "startLine" : 222,
            "endLine" : 222,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1305",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D7742027805A041229AED9F1E04A58E2"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/DeleteProfile.java"
          },
          "region" : {
            "startLine" : 80,
            "endLine" : 80,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1689",
      "message" : {
        "text" : "The function handleRequest() in DeleteProfile.java might reveal system data or debugging information by calling printStackTrace() on line 81.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "8B01FD5075A32F5302CF5236E389A97E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/DeleteProfile.java"
          },
          "region" : {
            "startLine" : 81,
            "endLine" : 81,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1306",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D7742027805A041229AED9F1E04A58E3"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/DeleteProfile.java"
          },
          "region" : {
            "startLine" : 85,
            "endLine" : 85,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1713",
      "message" : {
        "text" : "The function handleRequest() in DeleteProfile.java might reveal system data or debugging information by calling printStackTrace() on line 86.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "A43277672E8AE03DDDA5863F1377295E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/DeleteProfile.java"
          },
          "region" : {
            "startLine" : 86,
            "endLine" : 86,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "246",
      "message" : {
        "text" : "The function deleteEmployeeProfile() in DeleteProfile.java might reveal system data or debugging information by calling printStackTrace() on line 120.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "52C8ADF9D15390304DD17CB7F9DC8B02"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/DeleteProfile.java"
          },
          "region" : {
            "startLine" : 120,
            "endLine" : 120,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1106",
      "message" : {
        "text" : "The catch block at DeleteProfile.java line 123 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "424A8CB8DF4C3613CD348380203A43AC"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/DeleteProfile.java"
          },
          "region" : {
            "startLine" : 123,
            "endLine" : 123,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "122",
      "message" : {
        "text" : "The function deleteEmployeeProfile() in DeleteProfile.java might reveal system data or debugging information by calling printStackTrace() on line 126.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "29F8047D0743AF3156E0715069C95333"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/DeleteProfile.java"
          },
          "region" : {
            "startLine" : 126,
            "endLine" : 126,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "183",
      "message" : {
        "text" : "On line 144 of DeleteProfile.java, the method deleteEmployeeProfile_BACKUP() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "3B9CAEDBA3EF988863E7FA1E4EDE4143"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/DeleteProfile.java"
          },
          "region" : {
            "startLine" : 144,
            "endLine" : 144,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "506",
      "message" : {
        "text" : "The function deleteEmployeeProfile_BACKUP() in DeleteProfile.java might reveal system data or debugging information by calling printStackTrace() on line 149.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "AD7C11D3EB0D8558FDC22AB525483F1A"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/DeleteProfile.java"
          },
          "region" : {
            "startLine" : 149,
            "endLine" : 149,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1189",
      "message" : {
        "text" : "The catch block at DeleteProfile.java line 152 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "80328305A482EF3761B1FC9FE95E8CAF"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/DeleteProfile.java"
          },
          "region" : {
            "startLine" : 152,
            "endLine" : 152,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "630",
      "message" : {
        "text" : "The function deleteEmployeeProfile_BACKUP() in DeleteProfile.java might reveal system data or debugging information by calling printStackTrace() on line 155.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "E0A0EB22F4A6987698B4EBD02907B826"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/DeleteProfile.java"
          },
          "region" : {
            "startLine" : 155,
            "endLine" : 155,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1217",
      "message" : {
        "text" : "The method updateLessonStatus() in DeleteProfile.java ignores an exception on line 176, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "9A51D4CAF48BD3F8D3960159C5A77305"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/DeleteProfile.java"
          },
          "region" : {
            "startLine" : 176,
            "endLine" : 176,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "591",
      "message" : {
        "text" : "The function getEmployeeProfile() in EditProfile.java might reveal system data or debugging information by calling printStackTrace() on line 125.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D17F85CED9B5B55047EDD0446A9B17D7"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/EditProfile.java"
          },
          "region" : {
            "startLine" : 125,
            "endLine" : 125,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1600",
      "message" : {
        "text" : "The catch block at EditProfile.java line 128 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "3A68691E3A25CB0691DEE03515003B96"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/EditProfile.java"
          },
          "region" : {
            "startLine" : 128,
            "endLine" : 128,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "114",
      "message" : {
        "text" : "The function getEmployeeProfile() in EditProfile.java might reveal system data or debugging information by calling printStackTrace() on line 131.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "271C9A6472859F4F33CAACB572549F42"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/EditProfile.java"
          },
          "region" : {
            "startLine" : 131,
            "endLine" : 131,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "398",
      "message" : {
        "text" : "The function getEmployeeProfile_BACKUP() in EditProfile.java might reveal system data or debugging information by calling printStackTrace() on line 186.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "8BD6B7903C38236E8FA6C3B3480A6A40"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/EditProfile.java"
          },
          "region" : {
            "startLine" : 186,
            "endLine" : 186,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1818",
      "message" : {
        "text" : "The catch block at EditProfile.java line 189 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "ED38BB2EA4B2AB8E05B08409D36DDEC4"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/EditProfile.java"
          },
          "region" : {
            "startLine" : 189,
            "endLine" : 189,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "483",
      "message" : {
        "text" : "The function getEmployeeProfile_BACKUP() in EditProfile.java might reveal system data or debugging information by calling printStackTrace() on line 192.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "A74A9A8AC3B36246B6F2AAA5700D66AC"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/EditProfile.java"
          },
          "region" : {
            "startLine" : 192,
            "endLine" : 192,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1294",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D1EE3E3E679515ABBEC66C9A8682183B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/FindProfile.java"
          },
          "region" : {
            "startLine" : 83,
            "endLine" : 83,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1810",
      "message" : {
        "text" : "The function handleRequest() in FindProfile.java might reveal system data or debugging information by calling printStackTrace() on line 84.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "E8F7B8415D904326CE5A76C29F60DD94"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/FindProfile.java"
          },
          "region" : {
            "startLine" : 84,
            "endLine" : 84,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1295",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D1EE3E3E679515ABBEC66C9A8682183C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/FindProfile.java"
          },
          "region" : {
            "startLine" : 88,
            "endLine" : 88,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1793",
      "message" : {
        "text" : "The function handleRequest() in FindProfile.java might reveal system data or debugging information by calling printStackTrace() on line 89.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "DC355E945A033F5571B6641B8C9BE798"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/FindProfile.java"
          },
          "region" : {
            "startLine" : 89,
            "endLine" : 89,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1206",
      "message" : {
        "text" : "The method foundEmployee() in FindProfile.java ignores an exception on line 118, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "919D3DCDEEE1C50910AC7CE42DFA83A5"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/FindProfile.java"
          },
          "region" : {
            "startLine" : 118,
            "endLine" : 118,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "224",
      "message" : {
        "text" : "The function findEmployeeProfile() in FindProfile.java might reveal system data or debugging information by calling printStackTrace() on line 181.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "4808FFAF7D3634E85349E16A6E77465F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/FindProfile.java"
          },
          "region" : {
            "startLine" : 181,
            "endLine" : 181,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1639",
      "message" : {
        "text" : "The catch block at FindProfile.java line 184 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "68CCD41D75FDFDEB656F110D33C98BEB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/FindProfile.java"
          },
          "region" : {
            "startLine" : 184,
            "endLine" : 184,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "524",
      "message" : {
        "text" : "The function findEmployeeProfile() in FindProfile.java might reveal system data or debugging information by calling printStackTrace() on line 187.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B227CC5643407A75A63DAD656CCB9DC6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/FindProfile.java"
          },
          "region" : {
            "startLine" : 187,
            "endLine" : 187,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "318",
      "message" : {
        "text" : "On line 98 of ListStaff.java, the method getAllEmployees() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "6D819C0ADD8C403642DF5539DCD83183"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/ListStaff.java"
          },
          "region" : {
            "startLine" : 98,
            "endLine" : 98,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "20",
      "message" : {
        "text" : "The function getAllEmployees() in ListStaff.java might reveal system data or debugging information by calling printStackTrace() on line 115.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "0A84CFB7DBE148BCA531CBABA1A42650"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/ListStaff.java"
          },
          "region" : {
            "startLine" : 115,
            "endLine" : 115,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1312",
      "message" : {
        "text" : "The catch block at ListStaff.java line 118 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "DE07BA20F02DE0CC255E1AB94B0DBE18"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/ListStaff.java"
          },
          "region" : {
            "startLine" : 118,
            "endLine" : 118,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "401",
      "message" : {
        "text" : "The function getAllEmployees() in ListStaff.java might reveal system data or debugging information by calling printStackTrace() on line 121.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "8CFD6F3F11F1F76C099AC5ACA733778E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/ListStaff.java"
          },
          "region" : {
            "startLine" : 121,
            "endLine" : 121,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "568",
      "message" : {
        "text" : "On line 146 of ListStaff.java, the method getAllEmployees_BACKUP() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "C254DB2A8D71FBAEA8349DB39FFCF7B4"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/ListStaff.java"
          },
          "region" : {
            "startLine" : 146,
            "endLine" : 146,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "636",
      "message" : {
        "text" : "The function getAllEmployees_BACKUP() in ListStaff.java might reveal system data or debugging information by calling printStackTrace() on line 163.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "E39A9E190CF6A50B4EEB36F90B79EEEE"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/ListStaff.java"
          },
          "region" : {
            "startLine" : 163,
            "endLine" : 163,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1288",
      "message" : {
        "text" : "The catch block at ListStaff.java line 166 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "CF1706576AE627A199EABD745ADE9FFB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/ListStaff.java"
          },
          "region" : {
            "startLine" : 166,
            "endLine" : 166,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "358",
      "message" : {
        "text" : "The function getAllEmployees_BACKUP() in ListStaff.java might reveal system data or debugging information by calling printStackTrace() on line 169.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "7DEFC09894FCD4141B09E0898E429C4A"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/ListStaff.java"
          },
          "region" : {
            "startLine" : 169,
            "endLine" : 169,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1154",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "63AAE86AA63EFA0F04478DEC38636E37"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/Login.java"
          },
          "region" : {
            "startLine" : 90,
            "endLine" : 90,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1845",
      "message" : {
        "text" : "The function handleRequest() in Login.java might reveal system data or debugging information by calling printStackTrace() on line 91.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "FCD568019EB69AF39AA163B0918E3C7F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/Login.java"
          },
          "region" : {
            "startLine" : 91,
            "endLine" : 91,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1155",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "63AAE86AA63EFA0F04478DEC38636E38"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/Login.java"
          },
          "region" : {
            "startLine" : 95,
            "endLine" : 95,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1671",
      "message" : {
        "text" : "The function handleRequest() in Login.java might reveal system data or debugging information by calling printStackTrace() on line 96.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "7865EB7B5AC47B29248E8C5025A008B0"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/Login.java"
          },
          "region" : {
            "startLine" : 96,
            "endLine" : 96,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1673",
      "message" : {
        "text" : "On line 148 of Login.java, the method login() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "7BB8EDC73CB58A98C025349FD6634C4B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/Login.java"
          },
          "region" : {
            "startLine" : 148,
            "endLine" : 148,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "73",
      "message" : {
        "text" : "The function login() in Login.java might reveal system data or debugging information by calling printStackTrace() on line 163.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "1A29C2FBFDD046228D0B134428F51657"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/Login.java"
          },
          "region" : {
            "startLine" : 163,
            "endLine" : 163,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1145",
      "message" : {
        "text" : "The catch block at Login.java line 166 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5FAD05CA7E47A3D714C0E012ED7B41B0"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/Login.java"
          },
          "region" : {
            "startLine" : 166,
            "endLine" : 166,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "581",
      "message" : {
        "text" : "The function login() in Login.java might reveal system data or debugging information by calling printStackTrace() on line 169.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "CAF560698F78E62F29FC0CF1F6955816"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/Login.java"
          },
          "region" : {
            "startLine" : 169,
            "endLine" : 169,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "593",
      "message" : {
        "text" : "The function getAllEmployees() in Login.java might reveal system data or debugging information by calling printStackTrace() on line 210.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D2CBE98F96B851D86A2DBB88FA6101B5"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/Login.java"
          },
          "region" : {
            "startLine" : 210,
            "endLine" : 210,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1257",
      "message" : {
        "text" : "The catch block at Login.java line 213 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B6451DDB15F48A240F5C0CD2D1AF8E5B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/Login.java"
          },
          "region" : {
            "startLine" : 213,
            "endLine" : 213,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "253",
      "message" : {
        "text" : "The function getAllEmployees() in Login.java might reveal system data or debugging information by calling printStackTrace() on line 216.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "578089EE6998BD5FC900CA94A6F4B9F9"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/Login.java"
          },
          "region" : {
            "startLine" : 216,
            "endLine" : 216,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1223",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "A248F4EA4F9AE3C7A9F4065B29868BEA"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/Logout.java"
          },
          "region" : {
            "startLine" : 70,
            "endLine" : 70,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1628",
      "message" : {
        "text" : "The function handleRequest() in Logout.java might reveal system data or debugging information by calling printStackTrace() on line 71.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "542A1F6930BFCE61860BFF17756539E2"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/Logout.java"
          },
          "region" : {
            "startLine" : 71,
            "endLine" : 71,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1224",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "A248F4EA4F9AE3C7A9F4065B29868BEB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/Logout.java"
          },
          "region" : {
            "startLine" : 75,
            "endLine" : 75,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1691",
      "message" : {
        "text" : "The function handleRequest() in Logout.java might reveal system data or debugging information by calling printStackTrace() on line 76.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "8E895F72A0E053B9527EBDA1C3B8F849"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/Logout.java"
          },
          "region" : {
            "startLine" : 76,
            "endLine" : 76,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1108",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "42D2933A94AA297DFBE1ECB83906AB85"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/RoleBasedAccessControl.java"
          },
          "region" : {
            "startLine" : 337,
            "endLine" : 337,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1618",
      "message" : {
        "text" : "The function handleRequest() in RoleBasedAccessControl.java might reveal system data or debugging information by calling printStackTrace() on line 338.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "4C58672C07CE0B3888AD33A0CFF3D994"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/RoleBasedAccessControl.java"
          },
          "region" : {
            "startLine" : 338,
            "endLine" : 338,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1109",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "42D2933A94AA297DFBE1ECB83906AB86"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/RoleBasedAccessControl.java"
          },
          "region" : {
            "startLine" : 343,
            "endLine" : 343,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1095",
      "message" : {
        "text" : "The function handleRequest() in RoleBasedAccessControl.java might reveal system data or debugging information by calling printStackTrace() on line 344.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "390CC7C47C215AE245AA7F18DFBC4FEA"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/RoleBasedAccessControl.java"
          },
          "region" : {
            "startLine" : 344,
            "endLine" : 344,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1110",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "42D2933A94AA297DFBE1ECB83906AB87"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/RoleBasedAccessControl.java"
          },
          "region" : {
            "startLine" : 350,
            "endLine" : 350,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1790",
      "message" : {
        "text" : "The function handleRequest() in RoleBasedAccessControl.java might reveal system data or debugging information by calling printStackTrace() on line 351.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D9E6C19FF94A89C45637A61042D0DCF4"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/RoleBasedAccessControl.java"
          },
          "region" : {
            "startLine" : 351,
            "endLine" : 351,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1111",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "42D2933A94AA297DFBE1ECB83906AB88"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/RoleBasedAccessControl.java"
          },
          "region" : {
            "startLine" : 356,
            "endLine" : 356,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1694",
      "message" : {
        "text" : "The function handleRequest() in RoleBasedAccessControl.java might reveal system data or debugging information by calling printStackTrace() on line 358.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "92A45ABC6BEBD81AF05D783F150A01FD"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/RoleBasedAccessControl.java"
          },
          "region" : {
            "startLine" : 358,
            "endLine" : 358,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1080",
      "message" : {
        "text" : "The catch block at RoleBasedAccessControl.java line 360 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "2CE624894A609924F7D4811F5D835C9F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/RoleBasedAccessControl.java"
          },
          "region" : {
            "startLine" : 360,
            "endLine" : 360,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1112",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "42D2933A94AA297DFBE1ECB83906AB89"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/RoleBasedAccessControl.java"
          },
          "region" : {
            "startLine" : 363,
            "endLine" : 363,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "586",
      "message" : {
        "text" : "The function handleRequest() in RoleBasedAccessControl.java might reveal system data or debugging information by calling printStackTrace() on line 364.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "CD805D9C1A798A2C4DDC3D19F51A75BC"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/RoleBasedAccessControl.java"
          },
          "region" : {
            "startLine" : 364,
            "endLine" : 364,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1242",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "AF02319C982F88E8E439A4AF52D3A8A5"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/RoleBasedAccessControl.java"
          },
          "region" : {
            "startLine" : 431,
            "endLine" : 431,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1599",
      "message" : {
        "text" : "The function handleRequest_BACKUP() in RoleBasedAccessControl.java might reveal system data or debugging information by calling printStackTrace() on line 432.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "3A34FB4634245DAC8FB32F4AEBABD802"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/RoleBasedAccessControl.java"
          },
          "region" : {
            "startLine" : 432,
            "endLine" : 432,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1243",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "AF02319C982F88E8E439A4AF52D3A8A6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/RoleBasedAccessControl.java"
          },
          "region" : {
            "startLine" : 437,
            "endLine" : 437,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1323",
      "message" : {
        "text" : "The function handleRequest_BACKUP() in RoleBasedAccessControl.java might reveal system data or debugging information by calling printStackTrace() on line 438.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "EAE355985C5A5A425BE5693E5B2DBE14"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/RoleBasedAccessControl.java"
          },
          "region" : {
            "startLine" : 438,
            "endLine" : 438,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1244",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "AF02319C982F88E8E439A4AF52D3A8A7"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/RoleBasedAccessControl.java"
          },
          "region" : {
            "startLine" : 444,
            "endLine" : 444,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1670",
      "message" : {
        "text" : "The function handleRequest_BACKUP() in RoleBasedAccessControl.java might reveal system data or debugging information by calling printStackTrace() on line 445.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "784F6C1C531B36F70C18F0DABF1C7DCA"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/RoleBasedAccessControl.java"
          },
          "region" : {
            "startLine" : 445,
            "endLine" : 445,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1245",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "AF02319C982F88E8E439A4AF52D3A8A8"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/RoleBasedAccessControl.java"
          },
          "region" : {
            "startLine" : 450,
            "endLine" : 450,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1824",
      "message" : {
        "text" : "The function handleRequest_BACKUP() in RoleBasedAccessControl.java might reveal system data or debugging information by calling printStackTrace() on line 452.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F40DFD7D0A6A3177917B8D561E6CDCC9"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/RoleBasedAccessControl.java"
          },
          "region" : {
            "startLine" : 452,
            "endLine" : 452,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1077",
      "message" : {
        "text" : "The catch block at RoleBasedAccessControl.java line 454 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "2A5B93F3990FF7D7E3B485F4F920B493"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/RoleBasedAccessControl.java"
          },
          "region" : {
            "startLine" : 454,
            "endLine" : 454,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1246",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "AF02319C982F88E8E439A4AF52D3A8A9"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/RoleBasedAccessControl.java"
          },
          "region" : {
            "startLine" : 457,
            "endLine" : 457,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "350",
      "message" : {
        "text" : "The function handleRequest_BACKUP() in RoleBasedAccessControl.java might reveal system data or debugging information by calling printStackTrace() on line 458.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "7A60E2A9434AE4E21CEEE27DFBE160CF"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/RoleBasedAccessControl.java"
          },
          "region" : {
            "startLine" : 458,
            "endLine" : 458,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1045",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "15703B6CEB9E56DD9D02968AF88F30B3"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 124,
            "endLine" : 124,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1805",
      "message" : {
        "text" : "The function handleRequest() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 125.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "E4EB3C3CC86A124D05029C605EAFE89D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 125,
            "endLine" : 125,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1046",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "15703B6CEB9E56DD9D02968AF88F30B4"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 129,
            "endLine" : 129,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1698",
      "message" : {
        "text" : "The function handleRequest() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 130.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "9566BFFB8B5ACE187FB90DDCEEAC6C17"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 130,
            "endLine" : 130,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1718",
      "message" : {
        "text" : "On line 176 of UpdateProfile.java, the method changeEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "A763A01AFCFA6EA768C7045BFF271909"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 176,
            "endLine" : 176,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "4",
      "message" : {
        "text" : "The function changeEmployeeProfile() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 181.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "05B7CDDF96E7DFE39C750A2146B40FF2"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 181,
            "endLine" : 181,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1584",
      "message" : {
        "text" : "The catch block at UpdateProfile.java line 185 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "2D2BEE50E4F5B5AB5A6DF0D134FC0BE8"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 185,
            "endLine" : 185,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "412",
      "message" : {
        "text" : "The function changeEmployeeProfile() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 188.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "91E288900A767B8B3AC64CB500252086"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 188,
            "endLine" : 188,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "655",
      "message" : {
        "text" : "On line 225 of UpdateProfile.java, the method changeEmployeeProfile_BACKUP() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "EC5D2A161015138659834F595ABEC843"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 225,
            "endLine" : 225,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "672",
      "message" : {
        "text" : "The function changeEmployeeProfile_BACKUP() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 230.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F25983B958BB80B53993CD341D48CED5"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 230,
            "endLine" : 230,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1732",
      "message" : {
        "text" : "The catch block at UpdateProfile.java line 234 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B726383BB69E9D0173CA12650859233E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 234,
            "endLine" : 234,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "41",
      "message" : {
        "text" : "The function changeEmployeeProfile_BACKUP() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 237.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "12A7BB006A4A13923C074307011194B8"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 237,
            "endLine" : 237,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "428",
      "message" : {
        "text" : "The function getNextUID() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 257.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "96C276DAF9BB2936A2F0FEB3DA40763A"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 257,
            "endLine" : 257,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "98",
      "message" : {
        "text" : "The function getNextUID() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 263.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "21A8BD721CDE61C4EE753B32957EA7C8"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 263,
            "endLine" : 263,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1850",
      "message" : {
        "text" : "On line 295 of UpdateProfile.java, the method createEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "FF21E2912F55A44C41F11B4A151F2DA6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 295,
            "endLine" : 295,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "400",
      "message" : {
        "text" : "The function createEmployeeProfile() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 299.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "8C48CE78706C16033CB0373C60EBF66E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 299,
            "endLine" : 299,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "384",
      "message" : {
        "text" : "On line 311 of UpdateProfile.java, the method createEmployeeProfile() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "8670E2308E8A72DAAF573E8910CC3532"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 311,
            "endLine" : 311,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "399",
      "message" : {
        "text" : "The function createEmployeeProfile() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 315.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "8C48CE78706C16033CB0373C60EBF66D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 315,
            "endLine" : 315,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1597",
      "message" : {
        "text" : "The catch block at UpdateProfile.java line 319 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "35E7C34DDD91F7453241A6A5F469F467"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 319,
            "endLine" : 319,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "302",
      "message" : {
        "text" : "The function createEmployeeProfile() in UpdateProfile.java might reveal system data or debugging information by calling printStackTrace() on line 321.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "65081290A748CDED3B8C7556ECE0F677"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/UpdateProfile.java"
          },
          "region" : {
            "startLine" : 321,
            "endLine" : 321,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1047",
      "message" : {
        "text" : "The method updateLessonStatus() in ViewProfile.java ignores an exception on line 105, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "159167DE098A6340587F852302B47EE0"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/ViewProfile.java"
          },
          "region" : {
            "startLine" : 105,
            "endLine" : 105,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "615",
      "message" : {
        "text" : "The function getEmployeeProfile() in ViewProfile.java might reveal system data or debugging information by calling printStackTrace() on line 160.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "DA6AE311765259AD2C01E2BC5A36B04E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/ViewProfile.java"
          },
          "region" : {
            "startLine" : 160,
            "endLine" : 160,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1729",
      "message" : {
        "text" : "The catch block at ViewProfile.java line 163 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B46AC326DC1F30F6B03F47CD78124682"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/ViewProfile.java"
          },
          "region" : {
            "startLine" : 163,
            "endLine" : 163,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "590",
      "message" : {
        "text" : "The function getEmployeeProfile() in ViewProfile.java might reveal system data or debugging information by calling printStackTrace() on line 166.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D1157449ECBB492F0958DEFDB268BDCE"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/ViewProfile.java"
          },
          "region" : {
            "startLine" : 166,
            "endLine" : 166,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "705",
      "message" : {
        "text" : "On line 192 of ViewProfile.java, the method getEmployeeProfile_BACKUP() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F88C48ED63341D13C54050C71557B4B7"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/ViewProfile.java"
          },
          "region" : {
            "startLine" : 192,
            "endLine" : 192,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "299",
      "message" : {
        "text" : "The function getEmployeeProfile_BACKUP() in ViewProfile.java might reveal system data or debugging information by calling printStackTrace() on line 220.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "62FF1026DD549BC6C832899FFA125D79"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/ViewProfile.java"
          },
          "region" : {
            "startLine" : 220,
            "endLine" : 220,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1777",
      "message" : {
        "text" : "The catch block at ViewProfile.java line 223 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D046B32B2A81C19087C1C3A499D9C743"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/ViewProfile.java"
          },
          "region" : {
            "startLine" : 223,
            "endLine" : 223,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "140",
      "message" : {
        "text" : "The function getEmployeeProfile_BACKUP() in ViewProfile.java might reveal system data or debugging information by calling printStackTrace() on line 226.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "2CBD712DEF62123F610AA40637D8643F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/RoleBasedAccessControl/ViewProfile.java"
          },
          "region" : {
            "startLine" : 226,
            "endLine" : 226,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "618",
      "message" : {
        "text" : "On line 98 of ListStaff.java, the method getAllEmployees() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "DAF3388936B50051AC1AD8A12D19604C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/ListStaff.java"
          },
          "region" : {
            "startLine" : 98,
            "endLine" : 98,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "155",
      "message" : {
        "text" : "The function getAllEmployees() in ListStaff.java might reveal system data or debugging information by calling printStackTrace() on line 115.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "30BA3110C9C99222B1E03052176CC477"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/ListStaff.java"
          },
          "region" : {
            "startLine" : 115,
            "endLine" : 115,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1280",
      "message" : {
        "text" : "The catch block at ListStaff.java line 118 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "C9A7E69771B873400CAE5FA10ADEB634"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/ListStaff.java"
          },
          "region" : {
            "startLine" : 118,
            "endLine" : 118,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "696",
      "message" : {
        "text" : "The function getAllEmployees() in ListStaff.java might reveal system data or debugging information by calling printStackTrace() on line 121.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F816B701BF42B2D5F9B436A63C987F2E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/ListStaff.java"
          },
          "region" : {
            "startLine" : 121,
            "endLine" : 121,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "540",
      "message" : {
        "text" : "On line 146 of ListStaff.java, the method getAllEmployees_BACKUP() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B89C6E51C5549D303051AB4FFC873D4D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/ListStaff.java"
          },
          "region" : {
            "startLine" : 146,
            "endLine" : 146,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "419",
      "message" : {
        "text" : "The function getAllEmployees_BACKUP() in ListStaff.java might reveal system data or debugging information by calling printStackTrace() on line 163.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "9523285F3B0BA5E8E91C4E11492A65D6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/ListStaff.java"
          },
          "region" : {
            "startLine" : 163,
            "endLine" : 163,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1159",
      "message" : {
        "text" : "The catch block at ListStaff.java line 166 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "689F5C908F1B8DAE49A26F85304E6B42"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/ListStaff.java"
          },
          "region" : {
            "startLine" : 166,
            "endLine" : 166,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "625",
      "message" : {
        "text" : "The function getAllEmployees_BACKUP() in ListStaff.java might reveal system data or debugging information by calling printStackTrace() on line 169.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "DD063791D0680D5C9FF93F0599D7712B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/ListStaff.java"
          },
          "region" : {
            "startLine" : 169,
            "endLine" : 169,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1174",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "774AF09F9D9AF6B802DCB89E57DBCBA0"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/Login.java"
          },
          "region" : {
            "startLine" : 94,
            "endLine" : 94,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1541",
      "message" : {
        "text" : "The function handleRequest() in Login.java might reveal system data or debugging information by calling printStackTrace() on line 95.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "0399A1EC2D554723E3929010E2556E8C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/Login.java"
          },
          "region" : {
            "startLine" : 95,
            "endLine" : 95,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1175",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "774AF09F9D9AF6B802DCB89E57DBCBA1"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/Login.java"
          },
          "region" : {
            "startLine" : 99,
            "endLine" : 99,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1537",
      "message" : {
        "text" : "The function handleRequest() in Login.java might reveal system data or debugging information by calling printStackTrace() on line 100.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "0278C28651A419EA7D7D5DB87A1FB695"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/Login.java"
          },
          "region" : {
            "startLine" : 100,
            "endLine" : 100,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1580",
      "message" : {
        "text" : "On line 149 of Login.java, the method login() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "290AE35B54CA1238FC786348AEAD4C6D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/Login.java"
          },
          "region" : {
            "startLine" : 149,
            "endLine" : 149,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1674",
      "message" : {
        "text" : "On line 149 of Login.java, the method login() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "7BDD81B455000B4713391796B65D396B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/Login.java"
          },
          "region" : {
            "startLine" : 149,
            "endLine" : 149,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "407",
      "message" : {
        "text" : "The function login() in Login.java might reveal system data or debugging information by calling printStackTrace() on line 162.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "8F523C6484F562CF74E05CFD919CB035"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/Login.java"
          },
          "region" : {
            "startLine" : 162,
            "endLine" : 162,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1238",
      "message" : {
        "text" : "The catch block at Login.java line 165 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "AC78C0ECCCAC39C732C6CDEF74BB1DEF"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/Login.java"
          },
          "region" : {
            "startLine" : 165,
            "endLine" : 165,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "123",
      "message" : {
        "text" : "The function login() in Login.java might reveal system data or debugging information by calling printStackTrace() on line 168.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "2A0E5C8A8D2080682AAF42D79BC24679"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/Login.java"
          },
          "region" : {
            "startLine" : 168,
            "endLine" : 168,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1781",
      "message" : {
        "text" : "On line 191 of Login.java, the method login_BACKUP() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "D1EF88605230D7F736402E17D85C0DCE"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/Login.java"
          },
          "region" : {
            "startLine" : 191,
            "endLine" : 191,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1848",
      "message" : {
        "text" : "On line 191 of Login.java, the method login_BACKUP() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "FE929098BDBCED1E049EDA7D79C3BA13"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/Login.java"
          },
          "region" : {
            "startLine" : 191,
            "endLine" : 191,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "666",
      "message" : {
        "text" : "The function login_BACKUP() in Login.java might reveal system data or debugging information by calling printStackTrace() on line 205.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F0476D607FC7E88A788D476EA7DD55C0"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/Login.java"
          },
          "region" : {
            "startLine" : 205,
            "endLine" : 205,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1179",
      "message" : {
        "text" : "The catch block at Login.java line 208 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "7B4A94FE46C68B8E768B5669284DE4A0"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/Login.java"
          },
          "region" : {
            "startLine" : 208,
            "endLine" : 208,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "241",
      "message" : {
        "text" : "The function login_BACKUP() in Login.java might reveal system data or debugging information by calling printStackTrace() on line 211.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "51602EFB444788618FD1F4B49284D96E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/Login.java"
          },
          "region" : {
            "startLine" : 211,
            "endLine" : 211,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "339",
      "message" : {
        "text" : "The function getAllEmployees() in Login.java might reveal system data or debugging information by calling printStackTrace() on line 252.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "7506F4DA48F6F86385C9F1B201CA3849"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/Login.java"
          },
          "region" : {
            "startLine" : 252,
            "endLine" : 252,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1281",
      "message" : {
        "text" : "The catch block at Login.java line 255 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "CA272157D4AC84194B040102D6B38471"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/Login.java"
          },
          "region" : {
            "startLine" : 255,
            "endLine" : 255,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "64",
      "message" : {
        "text" : "The function getAllEmployees() in Login.java might reveal system data or debugging information by calling printStackTrace() on line 258.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "15A52F2B4AB4C9974369F7251DBFB23C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/Login.java"
          },
          "region" : {
            "startLine" : 258,
            "endLine" : 258,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1099",
      "message" : {
        "text" : "The method updateLessonStatus() in Login.java ignores an exception on line 297, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "3C981B07C32984A2B6FCC54FF7C3C879"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/Login.java"
          },
          "region" : {
            "startLine" : 297,
            "endLine" : 297,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1299",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D5A59CA2C8C13FB34B53721AE5C9B3D2"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/SQLInjection.java"
          },
          "region" : {
            "startLine" : 341,
            "endLine" : 341,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1780",
      "message" : {
        "text" : "The function handleRequest() in SQLInjection.java might reveal system data or debugging information by calling printStackTrace() on line 342.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D13CCAFA47C75F58C2F9560901CDDCA9"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/SQLInjection.java"
          },
          "region" : {
            "startLine" : 342,
            "endLine" : 342,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1300",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D5A59CA2C8C13FB34B53721AE5C9B3D3"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/SQLInjection.java"
          },
          "region" : {
            "startLine" : 347,
            "endLine" : 347,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1078",
      "message" : {
        "text" : "The function handleRequest() in SQLInjection.java might reveal system data or debugging information by calling printStackTrace() on line 348.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "2C6E09CD1E289637CD671775BC99CADE"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/SQLInjection.java"
          },
          "region" : {
            "startLine" : 348,
            "endLine" : 348,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1301",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D5A59CA2C8C13FB34B53721AE5C9B3D4"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/SQLInjection.java"
          },
          "region" : {
            "startLine" : 354,
            "endLine" : 354,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1735",
      "message" : {
        "text" : "The function handleRequest() in SQLInjection.java might reveal system data or debugging information by calling printStackTrace() on line 355.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B922D2C153F3FCD70F6920FBA8EF3AE2"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/SQLInjection.java"
          },
          "region" : {
            "startLine" : 355,
            "endLine" : 355,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1302",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D5A59CA2C8C13FB34B53721AE5C9B3D5"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/SQLInjection.java"
          },
          "region" : {
            "startLine" : 360,
            "endLine" : 360,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1750",
      "message" : {
        "text" : "The function handleRequest() in SQLInjection.java might reveal system data or debugging information by calling printStackTrace() on line 361.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "BF4701C7B0F1C825C65450C4897AB8B7"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/SQLInjection.java"
          },
          "region" : {
            "startLine" : 361,
            "endLine" : 361,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1241",
      "message" : {
        "text" : "The catch block at SQLInjection.java line 363 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "AE6FA423BE9EB9E79EE35D5495B7C7A5"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/SQLInjection.java"
          },
          "region" : {
            "startLine" : 363,
            "endLine" : 363,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1303",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D5A59CA2C8C13FB34B53721AE5C9B3D6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/SQLInjection.java"
          },
          "region" : {
            "startLine" : 366,
            "endLine" : 366,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "343",
      "message" : {
        "text" : "The function handleRequest() in SQLInjection.java might reveal system data or debugging information by calling printStackTrace() on line 367.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "7608F03C2C01ADB55C091F61822D3207"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/SQLInjection.java"
          },
          "region" : {
            "startLine" : 367,
            "endLine" : 367,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1614",
      "message" : {
        "text" : "On line 118 of ViewProfile.java, the method getEmployeeProfile() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "4B75C779AA009A701775FF47139B7184"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/ViewProfile.java"
          },
          "region" : {
            "startLine" : 118,
            "endLine" : 118,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "427",
      "message" : {
        "text" : "The function getEmployeeProfile() in ViewProfile.java might reveal system data or debugging information by calling printStackTrace() on line 146.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "96AF7220DB83AEDCBF2DD2A39C114AF0"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/ViewProfile.java"
          },
          "region" : {
            "startLine" : 146,
            "endLine" : 146,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1538",
      "message" : {
        "text" : "The catch block at ViewProfile.java line 149 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "0307B18A0460D1B5E9CBA4A6CB1641F1"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/ViewProfile.java"
          },
          "region" : {
            "startLine" : 149,
            "endLine" : 149,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "141",
      "message" : {
        "text" : "The function getEmployeeProfile() in ViewProfile.java might reveal system data or debugging information by calling printStackTrace() on line 152.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "2CDD488F9BB6E1BB829186146B4BA075"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/ViewProfile.java"
          },
          "region" : {
            "startLine" : 152,
            "endLine" : 152,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1802",
      "message" : {
        "text" : "On line 178 of ViewProfile.java, the method getEmployeeProfile_BACKUP() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "E38E0F334AA88DFD78863C64FC25B729"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/ViewProfile.java"
          },
          "region" : {
            "startLine" : 178,
            "endLine" : 178,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "712",
      "message" : {
        "text" : "The function getEmployeeProfile_BACKUP() in ViewProfile.java might reveal system data or debugging information by calling printStackTrace() on line 206.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "FC1E4C3D52D781762C0317B5BBFBAA8F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/ViewProfile.java"
          },
          "region" : {
            "startLine" : 206,
            "endLine" : 206,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1573",
      "message" : {
        "text" : "The catch block at ViewProfile.java line 209 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "2377CF1BE73B3B048AA0A81997710936"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/ViewProfile.java"
          },
          "region" : {
            "startLine" : 209,
            "endLine" : 209,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "91",
      "message" : {
        "text" : "The function getEmployeeProfile_BACKUP() in ViewProfile.java might reveal system data or debugging information by calling printStackTrace() on line 212.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "1DF65556F09BBF74F1A33163DDB09405"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/ViewProfile.java"
          },
          "region" : {
            "startLine" : 212,
            "endLine" : 212,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1730",
      "message" : {
        "text" : "The method updateLessonStatus() in ViewProfile.java ignores an exception on line 253, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B5AE766122FA68FC09EFB2ED6960705F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/ViewProfile.java"
          },
          "region" : {
            "startLine" : 253,
            "endLine" : 253,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1731",
      "message" : {
        "text" : "The method updateLessonStatus() in ViewProfile.java ignores an exception on line 268, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B5AE766122FA68FC09EFB2ED69607060"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SQLInjection/ViewProfile.java"
          },
          "region" : {
            "startLine" : 268,
            "endLine" : 268,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1130",
      "message" : {
        "text" : "The catch block at SilentTransactions.java line 115 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "4E00CFEBE4072CA999C97E68292B7D0E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SilentTransactions.java"
          },
          "region" : {
            "startLine" : 115,
            "endLine" : 115,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "7",
      "message" : {
        "text" : "The function handleRequest() in SilentTransactions.java might reveal system data or debugging information by calling printStackTrace() on line 117.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "067B838962D6B799229870C93909DAA7"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SilentTransactions.java"
          },
          "region" : {
            "startLine" : 117,
            "endLine" : 117,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "624",
      "message" : {
        "text" : "The class SoapRequest stores a database connection in a static field, which creates a race condition when the connection is shared between threads.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "DCFF36250D3F64C32E667FEFA44D89EB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SoapRequest.java"
          },
          "region" : {
            "startLine" : 74,
            "endLine" : 74,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "5",
      "message" : {
        "text" : "The method getHints() in SoapRequest.java ignores the value returned by replaceAll() on line 140, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "064C4C93451D67B8E1CE35240CA83095"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SoapRequest.java"
          },
          "region" : {
            "startLine" : 140,
            "endLine" : 140,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1319",
      "message" : {
        "text" : "The method viewWsdl() in SoapRequest.java ignores an exception on line 265, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "E634F9908A591794FB74A17FCF57E637"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SoapRequest.java"
          },
          "region" : {
            "startLine" : 265,
            "endLine" : 265,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1356",
      "message" : {
        "text" : "The catch block at SoapRequest.java line 270 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "FF9C422AE5C85400EE3E51EA7FEE2716"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SoapRequest.java"
          },
          "region" : {
            "startLine" : 270,
            "endLine" : 270,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "663",
      "message" : {
        "text" : "The function viewWsdl() in SoapRequest.java might reveal system data or debugging information by calling printStackTrace() on line 273.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "EE0D0F6E41CCBAFA3ACD09D5E3B4810A"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SoapRequest.java"
          },
          "region" : {
            "startLine" : 273,
            "endLine" : 273,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1277",
      "message" : {
        "text" : "The method determineType() in SoapRequest.java ignores an exception on line 322, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "C68EA40BEECE32111F72F73D44E84514"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SoapRequest.java"
          },
          "region" : {
            "startLine" : 322,
            "endLine" : 322,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1156",
      "message" : {
        "text" : "The catch block at SoapRequest.java line 327 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "654431F026EFD8AFD155E91265356C4F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SoapRequest.java"
          },
          "region" : {
            "startLine" : 327,
            "endLine" : 327,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "55",
      "message" : {
        "text" : "The function determineType() in SoapRequest.java might reveal system data or debugging information by calling printStackTrace() on line 330.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "1483B63B83BB6AA4D820DD9274638C54"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SoapRequest.java"
          },
          "region" : {
            "startLine" : 330,
            "endLine" : 330,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1221",
      "message" : {
        "text" : "The function getResults() in SoapRequest.java sometimes fails to release a system resource allocated by <a href=\"event:file=JavaSource/org/owasp/webgoat/session/DatabaseUtilities.java&amp;lineNo=82\" rel=\"nofollow\">makeConnection()</a> on line 412.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "9E04332C771DC6643C26B2FD61F35F93"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SoapRequest.java"
          },
          "region" : {
            "startLine" : 412,
            "endLine" : 412,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1028",
      "message" : {
        "text" : "The function getResults() in SoapRequest.java sometimes fails to release a system resource allocated by <a href=\"event:file=JavaSource/org/owasp/webgoat/session/DatabaseUtilities.java&amp;lineNo=82\" rel=\"nofollow\">makeConnection()</a> on line 412.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "04ED8DE06DF66F9C36907FBF82DEB835"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SoapRequest.java"
          },
          "region" : {
            "startLine" : 418,
            "endLine" : 418,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1096",
      "message" : {
        "text" : "The function getResults() in SoapRequest.java sometimes fails to release a system resource allocated by <a href=\"event:file=JavaSource/org/owasp/webgoat/session/DatabaseUtilities.java&amp;lineNo=82\" rel=\"nofollow\">makeConnection()</a> on line 412.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "3A61CC50D67E795CD5D9C72962426B3D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SoapRequest.java"
          },
          "region" : {
            "startLine" : 422,
            "endLine" : 422,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "126",
      "message" : {
        "text" : "The method getResults() in SoapRequest.java ignores an exception on line 428, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "2B0FBB29B2ED4A753A1DF572AB283458"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SoapRequest.java"
          },
          "region" : {
            "startLine" : 428,
            "endLine" : 428,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "127",
      "message" : {
        "text" : "The method getResults() in SoapRequest.java ignores an exception on line 431, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "2B0FBB29B2ED4A753A1DF572AB283459"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SoapRequest.java"
          },
          "region" : {
            "startLine" : 431,
            "endLine" : 431,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "595",
      "message" : {
        "text" : "The catch block at SoapRequest.java line 431 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D402C68F2F35B97004E831047079827B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SoapRequest.java"
          },
          "region" : {
            "startLine" : 431,
            "endLine" : 431,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1817",
      "message" : {
        "text" : "On line 130 of SqlNumericInjection.java, the method injectableQuery() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "ECD88BA59A13D27920D89B9150B55964"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SqlNumericInjection.java"
          },
          "region" : {
            "startLine" : 130,
            "endLine" : 130,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1066",
      "message" : {
        "text" : "The catch block at SqlNumericInjection.java line 159 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "20177ECB226CB47AB96ECB5624B41718"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SqlNumericInjection.java"
          },
          "region" : {
            "startLine" : 159,
            "endLine" : 159,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "424",
      "message" : {
        "text" : "The function injectableQuery() in SqlNumericInjection.java might reveal system data or debugging information by calling printStackTrace() on line 162.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "95DE204D0F2739B96963DADDC6173ABA"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SqlNumericInjection.java"
          },
          "region" : {
            "startLine" : 162,
            "endLine" : 162,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1040",
      "message" : {
        "text" : "The catch block at SqlNumericInjection.java line 239 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "0F0FF924977DE9C7C73A2AF3FDA77CA2"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SqlNumericInjection.java"
          },
          "region" : {
            "startLine" : 239,
            "endLine" : 239,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "247",
      "message" : {
        "text" : "The function parameterizedQuery() in SqlNumericInjection.java might reveal system data or debugging information by calling printStackTrace() on line 242.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "53B038E0AE5B68AA1F4A9E8507FB4AAC"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SqlNumericInjection.java"
          },
          "region" : {
            "startLine" : 242,
            "endLine" : 242,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "233",
      "message" : {
        "text" : "The function getStations() in SqlNumericInjection.java might reveal system data or debugging information by calling printStackTrace() on line 323.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "4C653A33A0D6848A352377AB4CBAB1AD"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SqlNumericInjection.java"
          },
          "region" : {
            "startLine" : 323,
            "endLine" : 323,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1103",
      "message" : {
        "text" : "The catch block at SqlNumericInjection.java line 398 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "3DFB1C5A8A92E662E77EA3A291DE2B4B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SqlNumericInjection.java"
          },
          "region" : {
            "startLine" : 398,
            "endLine" : 398,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1158",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "6794198C77BE950520AE92E98DDE52CE"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SqlNumericInjection.java"
          },
          "region" : {
            "startLine" : 400,
            "endLine" : 400,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1216",
      "message" : {
        "text" : "The function handleRequest() in SqlNumericInjection.java might reveal system data or debugging information by calling println() on line 400.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "99A79585931C6987EC2A75B20966728B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SqlNumericInjection.java"
          },
          "region" : {
            "startLine" : 400,
            "endLine" : 400,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "557",
      "message" : {
        "text" : "The function handleRequest() in SqlNumericInjection.java might reveal system data or debugging information by calling printStackTrace() on line 401.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "BCA2815261DDE9801EF85E500931CC3B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SqlNumericInjection.java"
          },
          "region" : {
            "startLine" : 401,
            "endLine" : 401,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1687",
      "message" : {
        "text" : "On line 112 of SqlStringInjection.java, the method injectableQuery() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "8A18E35BD3EFE32534AC9384A5BE6956"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SqlStringInjection.java"
          },
          "region" : {
            "startLine" : 112,
            "endLine" : 112,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1198",
      "message" : {
        "text" : "The catch block at SqlStringInjection.java line 149 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "86B323E8F3792762476EEE992CC99816"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SqlStringInjection.java"
          },
          "region" : {
            "startLine" : 149,
            "endLine" : 149,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "357",
      "message" : {
        "text" : "The function injectableQuery() in SqlStringInjection.java might reveal system data or debugging information by calling printStackTrace() on line 152.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "7D6003CBCB0DCF48E600ED712C83AABF"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SqlStringInjection.java"
          },
          "region" : {
            "startLine" : 152,
            "endLine" : 152,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1135",
      "message" : {
        "text" : "The catch block at SqlStringInjection.java line 219 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "534D5EF2946C55543E83552AB2236A87"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SqlStringInjection.java"
          },
          "region" : {
            "startLine" : 219,
            "endLine" : 219,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "332",
      "message" : {
        "text" : "The function parameterizedQuery() in SqlStringInjection.java might reveal system data or debugging information by calling printStackTrace() on line 222.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "72460759C5B6E978E5FE283EAEEC81F3"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SqlStringInjection.java"
          },
          "region" : {
            "startLine" : 222,
            "endLine" : 222,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1199",
      "message" : {
        "text" : "The catch block at SqlStringInjection.java line 314 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "882B6B78EAA59D4913A171F38EBEDFD7"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SqlStringInjection.java"
          },
          "region" : {
            "startLine" : 314,
            "endLine" : 314,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1322",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "E997F562F8DE6D557D70AEE555AAC79C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SqlStringInjection.java"
          },
          "region" : {
            "startLine" : 316,
            "endLine" : 316,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1325",
      "message" : {
        "text" : "The function handleRequest() in SqlStringInjection.java might reveal system data or debugging information by calling println() on line 316.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "ED66ED89B95DC2286E131198E0F14E9C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SqlStringInjection.java"
          },
          "region" : {
            "startLine" : 316,
            "endLine" : 316,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "579",
      "message" : {
        "text" : "The function handleRequest() in SqlStringInjection.java might reveal system data or debugging information by calling printStackTrace() on line 317.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "C96F82E5F189CA5A0B7AAB52DD930CAB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/SqlStringInjection.java"
          },
          "region" : {
            "startLine" : 317,
            "endLine" : 317,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1170",
      "message" : {
        "text" : "The catch block at StoredXss.java line 110 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "75A884C9E8D537F1E385E0A32F9CCF44"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/StoredXss.java"
          },
          "region" : {
            "startLine" : 110,
            "endLine" : 110,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1320",
      "message" : {
        "text" : "The catch block at StoredXss.java line 271 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "E655FCB6180BE4E1728D9E4C4269B663"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/StoredXss.java"
          },
          "region" : {
            "startLine" : 271,
            "endLine" : 271,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "194",
      "message" : {
        "text" : "The function makeCurrent() in StoredXss.java might reveal system data or debugging information by calling printStackTrace() on line 274.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "3BF075B4B198A249D1BAC3FEB3984E40"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/StoredXss.java"
          },
          "region" : {
            "startLine" : 274,
            "endLine" : 274,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1324",
      "message" : {
        "text" : "On line 343 of StoredXss.java, the method makeList() invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "EBF2B90A529B6D5F6E3A143881FF46FC"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/StoredXss.java"
          },
          "region" : {
            "startLine" : 343,
            "endLine" : 343,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1276",
      "message" : {
        "text" : "The catch block at StoredXss.java line 361 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "C5C5AC1CBC1408C22FA356532AB2E6E6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/StoredXss.java"
          },
          "region" : {
            "startLine" : 361,
            "endLine" : 361,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1577",
      "message" : {
        "text" : "On line 103 of ThreadSafetyProblem.java, the method createContent() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "2636332ACE18588AF8D2FAAD06436683"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/ThreadSafetyProblem.java"
          },
          "region" : {
            "startLine" : 103,
            "endLine" : 103,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1153",
      "message" : {
        "text" : "The catch block at ThreadSafetyProblem.java line 125 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "62C7FE330BAB70CA63BDA5F86313AAB4"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/ThreadSafetyProblem.java"
          },
          "region" : {
            "startLine" : 125,
            "endLine" : 125,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "543",
      "message" : {
        "text" : "The function createContent() in ThreadSafetyProblem.java might reveal system data or debugging information by calling printStackTrace() on line 128.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B9BF1DFE73632286CCBD9DB579BF1F6C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/ThreadSafetyProblem.java"
          },
          "region" : {
            "startLine" : 128,
            "endLine" : 128,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1143",
      "message" : {
        "text" : "The catch block at ThreadSafetyProblem.java line 214 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5D8297B8270664CD91F31526192B8A95"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/ThreadSafetyProblem.java"
          },
          "region" : {
            "startLine" : 214,
            "endLine" : 214,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1053",
      "message" : {
        "text" : "The function handleRequest() in ThreadSafetyProblem.java might reveal system data or debugging information by calling println() on line 216.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "19CF0F630868DEF6CFF0C696A02B48A3"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/ThreadSafetyProblem.java"
          },
          "region" : {
            "startLine" : 216,
            "endLine" : 216,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1176",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "777AE55746C2DC9DD86A75F09986D338"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/ThreadSafetyProblem.java"
          },
          "region" : {
            "startLine" : 216,
            "endLine" : 216,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "124",
      "message" : {
        "text" : "The function handleRequest() in ThreadSafetyProblem.java might reveal system data or debugging information by calling printStackTrace() on line 217.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "2AB41AE8E1843F47BA77436620AA16AB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/ThreadSafetyProblem.java"
          },
          "region" : {
            "startLine" : 217,
            "endLine" : 217,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1609",
      "message" : {
        "text" : "The method createContent() in TraceXSS.java sends unvalidated data to a web browser on line 137, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "44FDD9D3ECD8BB124A2D2AE3DB505BFB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/TraceXSS.java"
          },
          "region" : {
            "startLine" : 137,
            "endLine" : 137,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1804",
      "message" : {
        "text" : "The method createContent() in TraceXSS.java sends unvalidated data to a web browser on line 151, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "E4C288AABC832D50D5EAD02C06A5B684"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/TraceXSS.java"
          },
          "region" : {
            "startLine" : 151,
            "endLine" : 151,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1650",
      "message" : {
        "text" : "The method createContent() in TraceXSS.java sends unvalidated data to a web browser on line 166, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "6D839FD4FF3C7C9D318E33593549D73A"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/TraceXSS.java"
          },
          "region" : {
            "startLine" : 166,
            "endLine" : 166,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1825",
      "message" : {
        "text" : "The method createContent() in TraceXSS.java sends unvalidated data to a web browser on line 201, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "F4234FFE417E22CE535656E88D5CCA53"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/TraceXSS.java"
          },
          "region" : {
            "startLine" : 201,
            "endLine" : 201,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1676",
      "message" : {
        "text" : "The method createContent() in TraceXSS.java sends unvalidated data to a web browser on line 207, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "7DCA70B4BA1061E14FB34018488AD663"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/TraceXSS.java"
          },
          "region" : {
            "startLine" : 207,
            "endLine" : 207,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1196",
      "message" : {
        "text" : "The catch block at TraceXSS.java line 220 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "865AB8CA7625D46FD1BE10801C0E6F9B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/TraceXSS.java"
          },
          "region" : {
            "startLine" : 220,
            "endLine" : 220,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "499",
      "message" : {
        "text" : "The function createContent() in TraceXSS.java might reveal system data or debugging information by calling printStackTrace() on line 223.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "ABD8BC13CE60A8E57DCFA6DABD7C58FD"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/TraceXSS.java"
          },
          "region" : {
            "startLine" : 223,
            "endLine" : 223,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1030",
      "message" : {
        "text" : "The catch block at UncheckedEmail.java line 193 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "074F613B1C85894BEC463C4BC282021B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/UncheckedEmail.java"
          },
          "region" : {
            "startLine" : 193,
            "endLine" : 193,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "292",
      "message" : {
        "text" : "The function createContent() in UncheckedEmail.java might reveal system data or debugging information by calling printStackTrace() on line 196.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5FEF0BF8E504E8EEB64A4B64E33D7339"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/UncheckedEmail.java"
          },
          "region" : {
            "startLine" : 196,
            "endLine" : 196,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "690",
      "message" : {
        "text" : "The class WSDLScanning stores a database connection in a static field, which creates a race condition when the connection is shared between threads.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "F442CD3145F2B123E11DAE0F8EC32D15"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WSDLScanning.java"
          },
          "region" : {
            "startLine" : 82,
            "endLine" : 82,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "580",
      "message" : {
        "text" : "Hardcoded passwords can compromise system security in a way that cannot be easily remedied.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "C9F66C7212252423D2CBA090538D5087"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WSDLScanning.java"
          },
          "region" : {
            "startLine" : 147,
            "endLine" : 147,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "451",
      "message" : {
        "text" : "The function accessWGService() in WSDLScanning.java might reveal system data or debugging information by calling printStackTrace() on line 155.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "9BCB204A4306E1E6CB007BE7A2EE0469"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WSDLScanning.java"
          },
          "region" : {
            "startLine" : 155,
            "endLine" : 155,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "450",
      "message" : {
        "text" : "The function accessWGService() in WSDLScanning.java might reveal system data or debugging information by calling printStackTrace() on line 159.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "9BCB204A4306E1E6CB007BE7A2EE0468"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WSDLScanning.java"
          },
          "region" : {
            "startLine" : 159,
            "endLine" : 159,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "620",
      "message" : {
        "text" : "The catch block at WSDLScanning.java line 161 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "DB817FE1BE7E92EF836558E4363C204B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WSDLScanning.java"
          },
          "region" : {
            "startLine" : 161,
            "endLine" : 161,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "449",
      "message" : {
        "text" : "The function accessWGService() in WSDLScanning.java might reveal system data or debugging information by calling printStackTrace() on line 163.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "9BCB204A4306E1E6CB007BE7A2EE0467"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WSDLScanning.java"
          },
          "region" : {
            "startLine" : 163,
            "endLine" : 163,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1171",
      "message" : {
        "text" : "The method createContent() in WSDLScanning.java ignores an exception on line 232, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "764375566B11856609060FAE78DD1113"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WSDLScanning.java"
          },
          "region" : {
            "startLine" : 232,
            "endLine" : 232,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1235",
      "message" : {
        "text" : "The catch block at WSDLScanning.java line 232 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "AB64E4CAE731235ED984445C420778D4"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WSDLScanning.java"
          },
          "region" : {
            "startLine" : 232,
            "endLine" : 232,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1236",
      "message" : {
        "text" : "The catch block at WSDLScanning.java line 261 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "AB64E4CAE731235ED984445C420778D5"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WSDLScanning.java"
          },
          "region" : {
            "startLine" : 261,
            "endLine" : 261,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "22",
      "message" : {
        "text" : "The function createContent() in WSDLScanning.java might reveal system data or debugging information by calling printStackTrace() on line 264.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "0C519A9DA8C7ECBC38BFA1BFE8776F64"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WSDLScanning.java"
          },
          "region" : {
            "startLine" : 264,
            "endLine" : 264,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1049",
      "message" : {
        "text" : "The function getResults() in WSDLScanning.java sometimes fails to release a system resource allocated by <a href=\"event:file=JavaSource/org/owasp/webgoat/session/DatabaseUtilities.java&amp;lineNo=82\" rel=\"nofollow\">makeConnection()</a> on line 274.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "1633DEC41E18BD7F8A60AFD79EFA55AD"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WSDLScanning.java"
          },
          "region" : {
            "startLine" : 274,
            "endLine" : 274,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1352",
      "message" : {
        "text" : "The function getResults() in WSDLScanning.java sometimes fails to release a system resource allocated by <a href=\"event:file=JavaSource/org/owasp/webgoat/session/DatabaseUtilities.java&amp;lineNo=82\" rel=\"nofollow\">makeConnection()</a> on line 274.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "FEA45A3D84A912105A0DEA1F42093C48"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WSDLScanning.java"
          },
          "region" : {
            "startLine" : 280,
            "endLine" : 280,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1054",
      "message" : {
        "text" : "The function getResults() in WSDLScanning.java sometimes fails to release a system resource allocated by <a href=\"event:file=JavaSource/org/owasp/webgoat/session/DatabaseUtilities.java&amp;lineNo=82\" rel=\"nofollow\">makeConnection()</a> on line 274.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "1A190EDA4C62457810D8ED1385AAAC6C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WSDLScanning.java"
          },
          "region" : {
            "startLine" : 284,
            "endLine" : 284,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "327",
      "message" : {
        "text" : "The method getResults() in WSDLScanning.java ignores an exception on line 290, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "711C492D0F8D5CD85496BA28D71F1133"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WSDLScanning.java"
          },
          "region" : {
            "startLine" : 290,
            "endLine" : 290,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "328",
      "message" : {
        "text" : "The method getResults() in WSDLScanning.java ignores an exception on line 293, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "711C492D0F8D5CD85496BA28D71F1134"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WSDLScanning.java"
          },
          "region" : {
            "startLine" : 293,
            "endLine" : 293,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "706",
      "message" : {
        "text" : "The catch block at WSDLScanning.java line 293 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F8FCFA39D7E71A2FD62A3B00FBDC8C15"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WSDLScanning.java"
          },
          "region" : {
            "startLine" : 293,
            "endLine" : 293,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1137",
      "message" : {
        "text" : "The method checkCookie() in WeakAuthenticationCookie.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "543877893EBD02DFE17A9E604F23A9F3"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WeakAuthenticationCookie.java"
          },
          "region" : {
            "startLine" : 85,
            "endLine" : 85,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1178",
      "message" : {
        "text" : "The method checkParams() in WeakAuthenticationCookie.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "7A9D14739BA15F55897876721C44C389"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WeakAuthenticationCookie.java"
          },
          "region" : {
            "startLine" : 124,
            "endLine" : 124,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1102",
      "message" : {
        "text" : "The catch block at WeakAuthenticationCookie.java line 194 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "3D97B81482736027CF4EEF717491B02E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WeakAuthenticationCookie.java"
          },
          "region" : {
            "startLine" : 194,
            "endLine" : 194,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "674",
      "message" : {
        "text" : "The function createContent() in WeakAuthenticationCookie.java might reveal system data or debugging information by calling printStackTrace() on line 197.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F320CD0D64400B8E8CD55AB226B1808C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WeakAuthenticationCookie.java"
          },
          "region" : {
            "startLine" : 197,
            "endLine" : 197,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1314",
      "message" : {
        "text" : "The method makeUser() in WeakAuthenticationCookie.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "DFD20D8A60BD076F656B2B332AA1F9B2"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WeakAuthenticationCookie.java"
          },
          "region" : {
            "startLine" : 373,
            "endLine" : 373,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1042",
      "message" : {
        "text" : "The catch block at WeakSessionID.java line 135 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "125144A9692E181B4844EEA386485889"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WeakSessionID.java"
          },
          "region" : {
            "startLine" : 135,
            "endLine" : 135,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "487",
      "message" : {
        "text" : "The function createContent() in WeakSessionID.java might reveal system data or debugging information by calling printStackTrace() on line 138.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "A8A03FD3342B94A6241E845EEB5873DD"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WeakSessionID.java"
          },
          "region" : {
            "startLine" : 138,
            "endLine" : 138,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1209",
      "message" : {
        "text" : "The method makeLogin() in WeakSessionID.java ignores an exception on line 228, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "92C43F310A3F956352502EAD36C5B551"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WeakSessionID.java"
          },
          "region" : {
            "startLine" : 228,
            "endLine" : 228,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1210",
      "message" : {
        "text" : "The method makeLogin() in WeakSessionID.java ignores an exception on line 234, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "92C43F310A3F956352502EAD36C5B552"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WeakSessionID.java"
          },
          "region" : {
            "startLine" : 234,
            "endLine" : 234,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1181",
      "message" : {
        "text" : "The catch block at WsSAXInjection.java line 163 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "7CA6791DD58737AB497E5E78D71B71E6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WsSAXInjection.java"
          },
          "region" : {
            "startLine" : 163,
            "endLine" : 163,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "125",
      "message" : {
        "text" : "The function createContent() in WsSAXInjection.java might reveal system data or debugging information by calling printStackTrace() on line 166.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "2B04DD17B5D46FB70C0FD974CE08F0CD"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WsSAXInjection.java"
          },
          "region" : {
            "startLine" : 166,
            "endLine" : 166,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "670",
      "message" : {
        "text" : "Hardcoded passwords can compromise system security in a way that cannot be easily remedied.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F151F2AC57994650A3A31069D9353F5A"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WsSAXInjection.java"
          },
          "region" : {
            "startLine" : 208,
            "endLine" : 208,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1260",
      "message" : {
        "text" : "The catch block at WsSqlInjection.java line 216 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B80F7E5451D2354A70D8080A4A26F131"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WsSqlInjection.java"
          },
          "region" : {
            "startLine" : 216,
            "endLine" : 216,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "111",
      "message" : {
        "text" : "The function createContent() in WsSqlInjection.java might reveal system data or debugging information by calling printStackTrace() on line 219.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "25742E56A92040D260B30A6926B06A6C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WsSqlInjection.java"
          },
          "region" : {
            "startLine" : 219,
            "endLine" : 219,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1193",
      "message" : {
        "text" : "The function getResults() in WsSqlInjection.java sometimes fails to release a system resource allocated by <a href=\"event:file=JavaSource/org/owasp/webgoat/session/DatabaseUtilities.java&amp;lineNo=82\" rel=\"nofollow\">makeConnection()</a> on line 229.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "82D70BA5E84D0C9D4F5969FFB9E2BB82"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WsSqlInjection.java"
          },
          "region" : {
            "startLine" : 229,
            "endLine" : 229,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1115",
      "message" : {
        "text" : "The function getResults() in WsSqlInjection.java sometimes fails to release a system resource allocated by <a href=\"event:file=JavaSource/org/owasp/webgoat/session/DatabaseUtilities.java&amp;lineNo=82\" rel=\"nofollow\">makeConnection()</a> on line 229.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "451A17229ADFC2431B64826831C3B627"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WsSqlInjection.java"
          },
          "region" : {
            "startLine" : 237,
            "endLine" : 237,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "373",
      "message" : {
        "text" : "On line 240 of WsSqlInjection.java, the method getResults() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "80F2D5A5B05EF3E157B2A00601FAC160"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WsSqlInjection.java"
          },
          "region" : {
            "startLine" : 240,
            "endLine" : 240,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1287",
      "message" : {
        "text" : "The function getResults() in WsSqlInjection.java sometimes fails to release a system resource allocated by <a href=\"event:file=JavaSource/org/owasp/webgoat/session/DatabaseUtilities.java&amp;lineNo=82\" rel=\"nofollow\">makeConnection()</a> on line 229.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "CDAFF78604806F2C9413943C8A3A691B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WsSqlInjection.java"
          },
          "region" : {
            "startLine" : 240,
            "endLine" : 240,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1776",
      "message" : {
        "text" : "On line 240 of WsSqlInjection.java, the method getResults() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "CFA08E705B2FEB36B31081983682AFBA"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WsSqlInjection.java"
          },
          "region" : {
            "startLine" : 240,
            "endLine" : 240,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "310",
      "message" : {
        "text" : "The method getResults() in WsSqlInjection.java ignores an exception on line 243, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "6843E1A15E92F2D722831D80D2C09DE5"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WsSqlInjection.java"
          },
          "region" : {
            "startLine" : 243,
            "endLine" : 243,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "311",
      "message" : {
        "text" : "The method getResults() in WsSqlInjection.java ignores an exception on line 246, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "6843E1A15E92F2D722831D80D2C09DE6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WsSqlInjection.java"
          },
          "region" : {
            "startLine" : 246,
            "endLine" : 246,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "491",
      "message" : {
        "text" : "The catch block at WsSqlInjection.java line 246 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "AA803124133D98FE04A15C11A816D18D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WsSqlInjection.java"
          },
          "region" : {
            "startLine" : 246,
            "endLine" : 246,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "389",
      "message" : {
        "text" : "The method getCreditCard() in WsSqlInjection.java ignores an exception on line 273, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "88586BB1D4487A36D1054CED59AE80BD"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/WsSqlInjection.java"
          },
          "region" : {
            "startLine" : 273,
            "endLine" : 273,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1124",
      "message" : {
        "text" : "The catch block at XMLInjection.java line 126 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "494710AD032BFD3226C4503F00F32525"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/XMLInjection.java"
          },
          "region" : {
            "startLine" : 126,
            "endLine" : 126,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "226",
      "message" : {
        "text" : "The function handleRequest() in XMLInjection.java might reveal system data or debugging information by calling printStackTrace() on line 128.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "4955E5682DB1F23BC21B272890D9F5DD"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/XMLInjection.java"
          },
          "region" : {
            "startLine" : 128,
            "endLine" : 128,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1107",
      "message" : {
        "text" : "The function createContent() in XPATHInjection.java sometimes fails to release a system resource allocated by FileInputStream() on line 155.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "42AB68D270545768293D3D37571A4EFE"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/XPATHInjection.java"
          },
          "region" : {
            "startLine" : 155,
            "endLine" : 155,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1759",
      "message" : {
        "text" : "On line 158 of XPATHInjection.java, the method createContent() invokes an XPath query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary XPath queries.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "C60AE754EFD609218E5CAD052E66D479"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/XPATHInjection.java"
          },
          "region" : {
            "startLine" : 158,
            "endLine" : 158,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "338",
      "message" : {
        "text" : "The function createContent() in XPATHInjection.java might reveal system data or debugging information by calling printStackTrace() on line 202.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "74C884820E4739861A03F8B6D623275D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/XPATHInjection.java"
          },
          "region" : {
            "startLine" : 202,
            "endLine" : 202,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "337",
      "message" : {
        "text" : "The function createContent() in XPATHInjection.java might reveal system data or debugging information by calling printStackTrace() on line 207.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "74C884820E4739861A03F8B6D623275C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/XPATHInjection.java"
          },
          "region" : {
            "startLine" : 207,
            "endLine" : 207,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "651",
      "message" : {
        "text" : "The function createContent() in XPATHInjection.java might reveal system data or debugging information by calling printStackTrace() on line 212.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "EA9B69789F87214E21A83B60748AE677"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/XPATHInjection.java"
          },
          "region" : {
            "startLine" : 212,
            "endLine" : 212,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1251",
      "message" : {
        "text" : "The catch block at ProductsAdminScreen.java line 85 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B25556823A56BD9833EC97928C6BE3C8"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/admin/ProductsAdminScreen.java"
          },
          "region" : {
            "startLine" : 85,
            "endLine" : 85,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "673",
      "message" : {
        "text" : "The function createContent() in ProductsAdminScreen.java might reveal system data or debugging information by calling printStackTrace() on line 88.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F2A3B37C92D64B9A4D3A13851DF8D76E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/admin/ProductsAdminScreen.java"
          },
          "region" : {
            "startLine" : 88,
            "endLine" : 88,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1348",
      "message" : {
        "text" : "The catch block at RefreshDBScreen.java line 96 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "FC4F6942D7BC47D8FED62F11B3107EC4"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/admin/RefreshDBScreen.java"
          },
          "region" : {
            "startLine" : 96,
            "endLine" : 96,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "531",
      "message" : {
        "text" : "The function createContent() in RefreshDBScreen.java might reveal system data or debugging information by calling printStackTrace() on line 99.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B5DBB03F9B63EAF24FDBFAEEDA0E29E2"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/admin/RefreshDBScreen.java"
          },
          "region" : {
            "startLine" : 99,
            "endLine" : 99,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1350",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "FCE9252971FBC36A1EF9D0890878DBE6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/admin/RefreshDBScreen.java"
          },
          "region" : {
            "startLine" : 163,
            "endLine" : 163,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1118",
      "message" : {
        "text" : "The catch block at RefreshDBScreen.java line 165 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "47EE7B29EE0DDEE757C5385A1C716A5D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/admin/RefreshDBScreen.java"
          },
          "region" : {
            "startLine" : 165,
            "endLine" : 165,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "519",
      "message" : {
        "text" : "The function refreshDB() in RefreshDBScreen.java might reveal system data or debugging information by calling printStackTrace() on line 169.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "AFC4AB32F20D390E9F9D1EC215C5F28B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/admin/RefreshDBScreen.java"
          },
          "region" : {
            "startLine" : 169,
            "endLine" : 169,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1060",
      "message" : {
        "text" : "The method createContent() in ReportCardScreen.java ignores an exception on line 87, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "1C951988FCDAF1CF15CAF1830327E1B7"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/admin/ReportCardScreen.java"
          },
          "region" : {
            "startLine" : 87,
            "endLine" : 87,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1351",
      "message" : {
        "text" : "The catch block at ReportCardScreen.java line 87 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "FE6BAAC5859A30F6057733FE921F1499"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/admin/ReportCardScreen.java"
          },
          "region" : {
            "startLine" : 87,
            "endLine" : 87,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1205",
      "message" : {
        "text" : "The catch block at SummaryReportCardScreen.java line 99 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "8DF99DB0044A09539852F92D2ECEB075"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/admin/SummaryReportCardScreen.java"
          },
          "region" : {
            "startLine" : 99,
            "endLine" : 99,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "488",
      "message" : {
        "text" : "The function createContent() in SummaryReportCardScreen.java might reveal system data or debugging information by calling printStackTrace() on line 101.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "A94731E83EB1AF8526072EA57511AF95"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/admin/SummaryReportCardScreen.java"
          },
          "region" : {
            "startLine" : 101,
            "endLine" : 101,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1048",
      "message" : {
        "text" : "The catch block at UserAdminScreen.java line 85 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "15D987114F12FA24A0A82EA17D1EBC02"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/admin/UserAdminScreen.java"
          },
          "region" : {
            "startLine" : 85,
            "endLine" : 85,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "671",
      "message" : {
        "text" : "The function createContent() in UserAdminScreen.java might reveal system data or debugging information by calling printStackTrace() on line 88.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F1BE853B45C96F767817CE6D92D5FC4C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/admin/UserAdminScreen.java"
          },
          "region" : {
            "startLine" : 88,
            "endLine" : 88,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1654",
      "message" : {
        "text" : "On line 90 of ViewDatabase.java, the method createContent() invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "6F6AC2229DF8D02A530F051A6AD33967"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/admin/ViewDatabase.java"
          },
          "region" : {
            "startLine" : 90,
            "endLine" : 90,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1076",
      "message" : {
        "text" : "The catch block at ViewDatabase.java line 102 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "2A58CC1547323D1AFB16464A0341A35F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/admin/ViewDatabase.java"
          },
          "region" : {
            "startLine" : 102,
            "endLine" : 102,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "523",
      "message" : {
        "text" : "The function createContent() in ViewDatabase.java might reveal system data or debugging information by calling printStackTrace() on line 105.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B1D0DC02CF0F0466CA099B070DE0D4F7"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/lessons/admin/ViewDatabase.java"
          },
          "region" : {
            "startLine" : 105,
            "endLine" : 105,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1092",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "368BE56DC03554499D14E197D9C9F157"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/Course.java"
          },
          "region" : {
            "startLine" : 71,
            "endLine" : 71,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1308",
      "message" : {
        "text" : "The function Course() in Course.java might reveal system data or debugging information by calling printStackTrace() on line 72.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D9886F39472E4FB32B12FB9ED7A42A23"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/Course.java"
          },
          "region" : {
            "startLine" : 72,
            "endLine" : 72,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1169",
      "message" : {
        "text" : "The catch block at Course.java line 377 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "757165A83BF25887A323F656ED89A76B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/Course.java"
          },
          "region" : {
            "startLine" : 377,
            "endLine" : 377,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1253",
      "message" : {
        "text" : "The method loadLessons() in Course.java ignores an exception on line 377, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B4314B398110D1A245F120ACF94D95B2"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/Course.java"
          },
          "region" : {
            "startLine" : 377,
            "endLine" : 377,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1831",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F6EFAEDA0214169B96CB9979E5C03C98"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 62,
            "endLine" : 62,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1842",
      "message" : {
        "text" : "The function main() in CreateDB.java might reveal system data or debugging information by calling printStackTrace() on line 63.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F8A0BE43919B1CC24D313FC8505FB218"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 63,
            "endLine" : 63,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1704",
      "message" : {
        "text" : "The function main() in CreateDB.java sometimes fails to release a system resource allocated by getConnection() on line 70.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "9CC65560EA0A2E0B99A4F34F77582BCB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 70,
            "endLine" : 70,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1789",
      "message" : {
        "text" : "The function main() in CreateDB.java sometimes fails to release a system resource allocated by getConnection() on line 70.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "D91D9D2F568DE51F5261A463BB23A245"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 73,
            "endLine" : 73,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1832",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F6EFAEDA0214169B96CB9979E5C03C99"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 77,
            "endLine" : 77,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1841",
      "message" : {
        "text" : "The function main() in CreateDB.java might reveal system data or debugging information by calling printStackTrace() on line 78.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F8A0BE43919B1CC24D313FC8505FB217"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 78,
            "endLine" : 78,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1779",
      "message" : {
        "text" : "The function main() in CreateDB.java sometimes fails to release a system resource allocated by getConnection() on line 70.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "D087040CC5EC38F946C4D265C04CEC7F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 91,
            "endLine" : 91,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1833",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F6EFAEDA0214169B96CB9979E5C03C9A"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 96,
            "endLine" : 96,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1752",
      "message" : {
        "text" : "The function main() in CreateDB.java might reveal system data or debugging information by calling printStackTrace() on line 101.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "BF7CEA65EB8E52B7BA7F9689AD3E7319"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 101,
            "endLine" : 101,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1834",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F6EFAEDA0214169B96CB9979E5C03C9B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 120,
            "endLine" : 120,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1835",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F6EFAEDA0214169B96CB9979E5C03C9C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 122,
            "endLine" : 122,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1751",
      "message" : {
        "text" : "The function main() in CreateDB.java might reveal system data or debugging information by calling printStackTrace() on line 126.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "BF7CEA65EB8E52B7BA7F9689AD3E7318"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 126,
            "endLine" : 126,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1659",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "724E94D249DD72230BB4A189D83487D5"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 150,
            "endLine" : 150,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1660",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "724E94D249DD72230BB4A189D83487D6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 164,
            "endLine" : 164,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1581",
      "message" : {
        "text" : "The function createMessageTable() in CreateDB.java might reveal system data or debugging information by calling printStackTrace() on line 165.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "2A4E10165937706D57A241B308EAA8AE"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 165,
            "endLine" : 165,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1575",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "24C087A4806CB569AFD1A909CC8E8E16"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 189,
            "endLine" : 189,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1576",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "24C087A4806CB569AFD1A909CC8E8E17"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 202,
            "endLine" : 202,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1632",
      "message" : {
        "text" : "The function createProductTable() in CreateDB.java might reveal system data or debugging information by calling printStackTrace() on line 203.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5C590077BD415569074E3ADC37FB4548"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 203,
            "endLine" : 203,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1595",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "3542DDF0D10488FB2A1E72BBA01A617A"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 240,
            "endLine" : 240,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1596",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "3542DDF0D10488FB2A1E72BBA01A617B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 254,
            "endLine" : 254,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1829",
      "message" : {
        "text" : "The function createUserAdminTable() in CreateDB.java might reveal system data or debugging information by calling printStackTrace() on line 255.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F5CE104ADE787D309B188DA800E168D9"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 255,
            "endLine" : 255,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1706",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "9DA9A88EBD392A6A7FE7FAADC8ADF8CB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 291,
            "endLine" : 291,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1707",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "9DA9A88EBD392A6A7FE7FAADC8ADF8CC"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 306,
            "endLine" : 306,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1695",
      "message" : {
        "text" : "The function createUserDataTable() in CreateDB.java might reveal system data or debugging information by calling printStackTrace() on line 307.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "93CD6DEBF68343122976265824799022"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 307,
            "endLine" : 307,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1754",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "C16B16C098BEE5CE2B8634CD6CAFE7A8"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 352,
            "endLine" : 352,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1755",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "C16B16C098BEE5CE2B8634CD6CAFE7A9"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 364,
            "endLine" : 364,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1851",
      "message" : {
        "text" : "The function createLoginTable() in CreateDB.java might reveal system data or debugging information by calling printStackTrace() on line 365.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "FF76220E74EDAE7E4486A521D44AFB49"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 365,
            "endLine" : 365,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1768",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "CBBCD347E74E1C3A0DC1F646A88AC8DF"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 391,
            "endLine" : 391,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1769",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "CBBCD347E74E1C3A0DC1F646A88AC8E0"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 405,
            "endLine" : 405,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1602",
      "message" : {
        "text" : "The function createWeatherDataTable() in CreateDB.java might reveal system data or debugging information by calling printStackTrace() on line 406.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "3D85ED8EA02BD2FB40285F67BE1CDE88"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 406,
            "endLine" : 406,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1655",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "6FF27C0075EC88B18F1BC5DF6A388EC7"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 447,
            "endLine" : 447,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1656",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "6FF27C0075EC88B18F1BC5DF6A388EC8"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 472,
            "endLine" : 472,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1554",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "127C2D515D6915803C85A5BFF9CD96DE"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 549,
            "endLine" : 549,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1555",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "127C2D515D6915803C85A5BFF9CD96DF"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 562,
            "endLine" : 562,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1640",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "68E135A1A0A5F990F2281AD652A575AB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 604,
            "endLine" : 604,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1641",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "68E135A1A0A5F990F2281AD652A575AC"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 618,
            "endLine" : 618,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1723",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "AAEBC31612A7257DD3CB71C4D9922BA7"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 714,
            "endLine" : 714,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1724",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "AAEBC31612A7257DD3CB71C4D9922BA8"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 727,
            "endLine" : 727,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1545",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "0CB45A2FA542F2ADD850FC11D2A0D93D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 856,
            "endLine" : 856,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1546",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "0CB45A2FA542F2ADD850FC11D2A0D93E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/CreateDB.java"
          },
          "region" : {
            "startLine" : 867,
            "endLine" : 867,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1289",
      "message" : {
        "text" : "Attackers can control an argument to the reflection method forName() at DatabaseUtilities.java line 66, which could allow them to create unexpected control flow paths through the application, potentially bypassing security checks.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "CF6350F88FA69DDBB6F671F1EE6C01D7"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/DatabaseUtilities.java"
          },
          "region" : {
            "startLine" : 66,
            "endLine" : 66,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1034",
      "message" : {
        "text" : "The function makeConnection() in DatabaseUtilities.java might reveal system data or debugging information by calling println() on line 95.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "0B38BCEEE7F2B81F7433FA988C11E625"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/DatabaseUtilities.java"
          },
          "region" : {
            "startLine" : 95,
            "endLine" : 95,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1285",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "CCD4B143682A4683F6EC630E93BFB3DA"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/DatabaseUtilities.java"
          },
          "region" : {
            "startLine" : 95,
            "endLine" : 95,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1164",
      "message" : {
        "text" : "The catch block at DatabaseUtilities.java line 108 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "6CA7FAD40A38050006A40F1929490FEC"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/DatabaseUtilities.java"
          },
          "region" : {
            "startLine" : 108,
            "endLine" : 108,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1211",
      "message" : {
        "text" : "The function makeConnection() in DatabaseUtilities.java might reveal system data or debugging information by calling printStackTrace() on line 110.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "94544F7344343065945982F8E21BCE4E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/DatabaseUtilities.java"
          },
          "region" : {
            "startLine" : 110,
            "endLine" : 110,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1806",
      "message" : {
        "text" : "The catch block at ErrorScreen.java line 107 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "E4F576AD9B9099E7648A661FD3E026DC"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ErrorScreen.java"
          },
          "region" : {
            "startLine" : 107,
            "endLine" : 107,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1590",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "31DEE6B21465265B07E2F227B82A1848"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ErrorScreen.java"
          },
          "region" : {
            "startLine" : 159,
            "endLine" : 159,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1811",
      "message" : {
        "text" : "The function createContent() in ErrorScreen.java might reveal system data or debugging information by calling println() on line 159.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "E8F9645A31D168CF4EB9D6B8CEF41756"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ErrorScreen.java"
          },
          "region" : {
            "startLine" : 159,
            "endLine" : 159,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1828",
      "message" : {
        "text" : "The function createContent() in ErrorScreen.java might reveal system data or debugging information by calling println() on line 159.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F54BAA218F40DA45D1D12747610709EA"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ErrorScreen.java"
          },
          "region" : {
            "startLine" : 159,
            "endLine" : 159,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1692",
      "message" : {
        "text" : "The function getStackTrace() in ErrorScreen.java might reveal system data or debugging information by calling printStackTrace() on line 258.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "9173282D79F380158CB220AE42554726"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ErrorScreen.java"
          },
          "region" : {
            "startLine" : 258,
            "endLine" : 258,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1274",
      "message" : {
        "text" : "The method load() in LessonTracker.java ignores an exception on line 247, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "C5BD52D4D9034951347E8AE8481F11BC"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/LessonTracker.java"
          },
          "region" : {
            "startLine" : 247,
            "endLine" : 247,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1090",
      "message" : {
        "text" : "The catch block at LessonTracker.java line 251 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "3541B59CCC3B82B15BA004D41B6A464C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/LessonTracker.java"
          },
          "region" : {
            "startLine" : 251,
            "endLine" : 251,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1094",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "379104AF7B371A11C95744BFF851EF1E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/LessonTracker.java"
          },
          "region" : {
            "startLine" : 253,
            "endLine" : 253,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1355",
      "message" : {
        "text" : "The function load() in LessonTracker.java might reveal system data or debugging information by calling printStackTrace() on line 254.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "FF10EE5C1C632AD667838979FD8C253C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/LessonTracker.java"
          },
          "region" : {
            "startLine" : 254,
            "endLine" : 254,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1091",
      "message" : {
        "text" : "The catch block at LessonTracker.java line 262 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "3541B59CCC3B82B15BA004D41B6A464D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/LessonTracker.java"
          },
          "region" : {
            "startLine" : 262,
            "endLine" : 262,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1275",
      "message" : {
        "text" : "The method load() in LessonTracker.java ignores an exception on line 262, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "C5BD52D4D9034951347E8AE8481F11BD"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/LessonTracker.java"
          },
          "region" : {
            "startLine" : 262,
            "endLine" : 262,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1146",
      "message" : {
        "text" : "The catch block at LessonTracker.java line 391 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5FE5E75EFAB278E8A87ABDB6DFA6EB57"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/LessonTracker.java"
          },
          "region" : {
            "startLine" : 391,
            "endLine" : 391,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1126",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "49BA822B92A28A157097157E71E8D54F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/LessonTracker.java"
          },
          "region" : {
            "startLine" : 394,
            "endLine" : 394,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1147",
      "message" : {
        "text" : "The catch block at LessonTracker.java line 403 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5FE5E75EFAB278E8A87ABDB6DFA6EB58"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/LessonTracker.java"
          },
          "region" : {
            "startLine" : 403,
            "endLine" : 403,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1327",
      "message" : {
        "text" : "The method store() in LessonTracker.java ignores an exception on line 403, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "EE6D0BB18FEBEFDBFB1DB27798A63FBA"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/LessonTracker.java"
          },
          "region" : {
            "startLine" : 403,
            "endLine" : 403,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1557",
      "message" : {
        "text" : "The method ParameterNotFoundException() in ParameterNotFoundException.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "13AE22C88661F95BF75681BE4BF98F12"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterNotFoundException.java"
          },
          "region" : {
            "startLine" : 54,
            "endLine" : 54,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1579",
      "message" : {
        "text" : "The method ParameterNotFoundException() in ParameterNotFoundException.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "287000CB289F94A2D000C2135A46B8E1"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterNotFoundException.java"
          },
          "region" : {
            "startLine" : 54,
            "endLine" : 54,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1589",
      "message" : {
        "text" : "The method ParameterNotFoundException() in ParameterNotFoundException.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "31BE6343A0D2F95463E6967907F465AE"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterNotFoundException.java"
          },
          "region" : {
            "startLine" : 54,
            "endLine" : 54,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1620",
      "message" : {
        "text" : "The method ParameterNotFoundException() in ParameterNotFoundException.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "4D6F5C54F83CEC6C7689E5E34BA02A74"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterNotFoundException.java"
          },
          "region" : {
            "startLine" : 54,
            "endLine" : 54,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1635",
      "message" : {
        "text" : "The method ParameterNotFoundException() in ParameterNotFoundException.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "653BC22E0B18298FA822AEA15C8DD8A6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterNotFoundException.java"
          },
          "region" : {
            "startLine" : 54,
            "endLine" : 54,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1648",
      "message" : {
        "text" : "The method ParameterNotFoundException() in ParameterNotFoundException.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "6C721EF2E9704C4C94BFC11574CF04AD"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterNotFoundException.java"
          },
          "region" : {
            "startLine" : 54,
            "endLine" : 54,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1669",
      "message" : {
        "text" : "The method ParameterNotFoundException() in ParameterNotFoundException.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "767FC201B2B8CC97B04C92814C3D8820"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterNotFoundException.java"
          },
          "region" : {
            "startLine" : 54,
            "endLine" : 54,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1679",
      "message" : {
        "text" : "The method ParameterNotFoundException() in ParameterNotFoundException.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "7EDA4AB335E028B1A7620351353D9541"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterNotFoundException.java"
          },
          "region" : {
            "startLine" : 54,
            "endLine" : 54,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1739",
      "message" : {
        "text" : "The method ParameterNotFoundException() in ParameterNotFoundException.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "BBDD7E47BFA6F4D3D884A16F93DACDCE"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterNotFoundException.java"
          },
          "region" : {
            "startLine" : 54,
            "endLine" : 54,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1767",
      "message" : {
        "text" : "The method ParameterNotFoundException() in ParameterNotFoundException.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "CB4C984A1BA521A2604E9BBCEF6995F0"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterNotFoundException.java"
          },
          "region" : {
            "startLine" : 54,
            "endLine" : 54,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1785",
      "message" : {
        "text" : "The method ParameterNotFoundException() in ParameterNotFoundException.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "D5C76C17C5FE92CA3F31722313D1D577"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterNotFoundException.java"
          },
          "region" : {
            "startLine" : 54,
            "endLine" : 54,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1846",
      "message" : {
        "text" : "The method ParameterNotFoundException() in ParameterNotFoundException.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "FD067016C70D5FB1997E5E11D4D30D7D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterNotFoundException.java"
          },
          "region" : {
            "startLine" : 54,
            "endLine" : 54,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1631",
      "message" : {
        "text" : "The catch block at ParameterParser.java line 120 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5A1F1426EE75EE3FBA9FFDAE1D0E00C5"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 120,
            "endLine" : 120,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1570",
      "message" : {
        "text" : "The catch block at ParameterParser.java line 141 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "22D5DCF1F61F33777ABC35D715FFD8FC"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 141,
            "endLine" : 141,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1745",
      "message" : {
        "text" : "The catch block at ParameterParser.java line 179 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "BE61BA7E4DC82B0854B087781BE03EAF"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 179,
            "endLine" : 179,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1792",
      "message" : {
        "text" : "The catch block at ParameterParser.java line 223 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "DA6FAC864D9770BC794738AD32E422AD"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 223,
            "endLine" : 223,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1787",
      "message" : {
        "text" : "The catch block at ParameterParser.java line 261 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D6E0432232121ACB0F40714D5AB71B02"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 261,
            "endLine" : 261,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1625",
      "message" : {
        "text" : "The catch block at ParameterParser.java line 298 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "52DDE6243FB32F58A3B0D46D4BEAC5BA"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 298,
            "endLine" : 298,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1803",
      "message" : {
        "text" : "The catch block at ParameterParser.java line 335 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "E3F7FA445FC73DF499C6AFEC68297B99"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 335,
            "endLine" : 335,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1683",
      "message" : {
        "text" : "The catch block at ParameterParser.java line 356 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "80A724A9D020652B8760D4E8E231BE77"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 356,
            "endLine" : 356,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1796",
      "message" : {
        "text" : "The catch block at ParameterParser.java line 428 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "E01A48FB4FD50C871F401912AB854C59"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 428,
            "endLine" : 428,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1666",
      "message" : {
        "text" : "The catch block at ParameterParser.java line 484 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "740A8235F59F66F7C610FBA1BF3186F7"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 484,
            "endLine" : 484,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1711",
      "message" : {
        "text" : "The catch block at ParameterParser.java line 521 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "A12C31E20DFB8C2A5A81F7FE3F5B1DF8"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 521,
            "endLine" : 521,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1563",
      "message" : {
        "text" : "The catch block at ParameterParser.java line 610 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "1CDC68976671DD5108A6F06DA34767BF"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 610,
            "endLine" : 610,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1540",
      "message" : {
        "text" : "The method getRawParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "0377CACDE1F4A610BEF25E9911551213"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 631,
            "endLine" : 631,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1615",
      "message" : {
        "text" : "The method getRawParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "4C152E7D555F91D3A6EAFEC6063DFA6B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 631,
            "endLine" : 631,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1623",
      "message" : {
        "text" : "The method getRawParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "50934B47CAF8C39533054827417ABCDA"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 631,
            "endLine" : 631,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1630",
      "message" : {
        "text" : "The method getRawParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "57FA7046BC7D07B612A460B6E68E9B03"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 631,
            "endLine" : 631,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1642",
      "message" : {
        "text" : "The method getRawParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "69836F0C6868D3255303F4FBDCA94B26"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 631,
            "endLine" : 631,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1753",
      "message" : {
        "text" : "The method getRawParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "C1244A13CA3BF8F9BA502170CED62589"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 631,
            "endLine" : 631,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1771",
      "message" : {
        "text" : "The method getRawParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "CCF6FB905F08BCDAE1AD9CC2C1DAD709"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 631,
            "endLine" : 631,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1544",
      "message" : {
        "text" : "The method getRawParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "0C0D100B70B3A2BC5ABEB4C9B50E9312"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 635,
            "endLine" : 635,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1558",
      "message" : {
        "text" : "The method getRawParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "14A1B567247BF568D0D344ACA37916A4"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 635,
            "endLine" : 635,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1564",
      "message" : {
        "text" : "The method getRawParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "1D17CC1C85766D6D159A75DB22247288"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 635,
            "endLine" : 635,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1598",
      "message" : {
        "text" : "The method getRawParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "39BD5B82BDC59C2B5279E38B322D35F6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 635,
            "endLine" : 635,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1665",
      "message" : {
        "text" : "The method getRawParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "74041EDF8320D2D6B8B66462C981A066"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 635,
            "endLine" : 635,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1748",
      "message" : {
        "text" : "The method getRawParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "BED13FB389450D63713AE49D474E2840"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 635,
            "endLine" : 635,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1770",
      "message" : {
        "text" : "The method getRawParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "CCCF2E26645D21ACE4F17192CB10D1D6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 635,
            "endLine" : 635,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1746",
      "message" : {
        "text" : "The catch block at ParameterParser.java line 672 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "BE70E7463930BF26AAF4E27EC47E9F79"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 672,
            "endLine" : 672,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1571",
      "message" : {
        "text" : "The method getStringParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "234F492B9FA93BEC5CB835B914E130C3"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 695,
            "endLine" : 695,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1603",
      "message" : {
        "text" : "The method getStringParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "3E0608F1FDEE4BB9F5EBA611961CA367"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 695,
            "endLine" : 695,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1604",
      "message" : {
        "text" : "The method getStringParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "3E10B89B5E2952BF0112AAF5A6B60C5C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 695,
            "endLine" : 695,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1610",
      "message" : {
        "text" : "The method getStringParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "4663FD29543DC990B07C1AD5A92A1AD5"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 695,
            "endLine" : 695,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1766",
      "message" : {
        "text" : "The method getStringParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "CB29631933C8B9549C2F18F0A8BA7440"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 695,
            "endLine" : 695,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1549",
      "message" : {
        "text" : "The method getStringParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "0F9075FB829A58EDC38EE064182D0933"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 699,
            "endLine" : 699,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1613",
      "message" : {
        "text" : "The method getStringParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "486B21E65ED03BDE62D69C141662A3CD"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 699,
            "endLine" : 699,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1644",
      "message" : {
        "text" : "The method getStringParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "6A53F0B8A0211B3999F8E0DFAA5FA0C2"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 699,
            "endLine" : 699,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1675",
      "message" : {
        "text" : "The method getStringParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "7BE7D98946A7E8421C7A0322CF9FA691"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 699,
            "endLine" : 699,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1737",
      "message" : {
        "text" : "The method getStringParameter() in ParameterParser.java mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "BA702E0AA648996AE8C3D20995234418"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 699,
            "endLine" : 699,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1565",
      "message" : {
        "text" : "The catch block at ParameterParser.java line 731 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "1DF8D64FED6C5F59B7CFACAB117EFFBB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 731,
            "endLine" : 731,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1552",
      "message" : {
        "text" : "The catch block at ParameterParser.java line 752 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "107D5D46B5327212671D1CDE8DD190E7"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 752,
            "endLine" : 752,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1761",
      "message" : {
        "text" : "The catch block at ParameterParser.java line 859 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "C6C902626308763F1CFA82F399CDD3E9"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 859,
            "endLine" : 859,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1682",
      "message" : {
        "text" : "The catch block at ParameterParser.java line 882 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "7FB1865C3542152C05F76E139A80A4DB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/ParameterParser.java"
          },
          "region" : {
            "startLine" : 882,
            "endLine" : 882,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1601",
      "message" : {
        "text" : "The catch block at UserTracker.java line 133 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "3B2CBFD932D36A92199DC47C13DA9CD0"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/UserTracker.java"
          },
          "region" : {
            "startLine" : 133,
            "endLine" : 133,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1843",
      "message" : {
        "text" : "The method getAllUsers() in UserTracker.java ignores an exception on line 133, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F9F54F32E40D2263C480BFDACBC06D4E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/UserTracker.java"
          },
          "region" : {
            "startLine" : 133,
            "endLine" : 133,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1624",
      "message" : {
        "text" : "The catch block at UserTracker.java line 161 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5271617895250A2E580F5ECA4DB66EBA"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/UserTracker.java"
          },
          "region" : {
            "startLine" : 161,
            "endLine" : 161,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1733",
      "message" : {
        "text" : "The method deleteUser() in UserTracker.java ignores an exception on line 161, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B7D5283FEEA8EDDE4F293D1ABEEFE6B1"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/UserTracker.java"
          },
          "region" : {
            "startLine" : 161,
            "endLine" : 161,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1105",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "401FDDB8941EABC2D0C09279338A72DB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/WebSession.java"
          },
          "region" : {
            "startLine" : 283,
            "endLine" : 283,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1278",
      "message" : {
        "text" : "The function WebSession() in WebSession.java might reveal system data or debugging information by calling println() on line 283.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "C7904A5B11FD09A0ECD5EAF045A3EA81"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/WebSession.java"
          },
          "region" : {
            "startLine" : 283,
            "endLine" : 283,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1064",
      "message" : {
        "text" : "The function getDatabaseConnectionString() in WebSession.java might reveal system data or debugging information by calling println() on line 439.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "1FB2CF819183512D88277250FA30C246"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/WebSession.java"
          },
          "region" : {
            "startLine" : 439,
            "endLine" : 439,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1212",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "969986E45D1FEA078E32B58E5E84595D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/WebSession.java"
          },
          "region" : {
            "startLine" : 439,
            "endLine" : 439,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1213",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "969986E45D1FEA078E32B58E5E84595E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/WebSession.java"
          },
          "region" : {
            "startLine" : 441,
            "endLine" : 441,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1293",
      "message" : {
        "text" : "The function getDatabaseConnectionString() in WebSession.java might reveal system data or debugging information by calling println() on line 441.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D1BF871BD67B399815A6110FA943DC60"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/WebSession.java"
          },
          "region" : {
            "startLine" : 441,
            "endLine" : 441,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1180",
      "message" : {
        "text" : "The catch block at WebSession.java line 445 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "7BFDA23213F13C4DFA0DCDE812F9DF47"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/WebSession.java"
          },
          "region" : {
            "startLine" : 445,
            "endLine" : 445,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1214",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "969986E45D1FEA078E32B58E5E84595F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/WebSession.java"
          },
          "region" : {
            "startLine" : 447,
            "endLine" : 447,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1144",
      "message" : {
        "text" : "The function getDatabaseConnectionString() in WebSession.java might reveal system data or debugging information by calling printStackTrace() on line 448.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "5F643FA678E744ABB5F223B467A50363"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/WebSession.java"
          },
          "region" : {
            "startLine" : 448,
            "endLine" : 448,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1262",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "BD7F96C92A07827F35E49DCFB8C9D8C5"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/WebSession.java"
          },
          "region" : {
            "startLine" : 801,
            "endLine" : 801,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1290",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D04EC036DB9FF599C02E3087AB9F1B07"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/WebSession.java"
          },
          "region" : {
            "startLine" : 988,
            "endLine" : 988,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1345",
      "message" : {
        "text" : "The method update() in WebSession.java ignores an exception on line 1027, which could cause the program to overlook unexpected states and conditions.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "FA8A0C3A1898EAD80E9E3514FADABD65"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/WebSession.java"
          },
          "region" : {
            "startLine" : 1027,
            "endLine" : 1027,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1349",
      "message" : {
        "text" : "The catch block at WebSession.java line 1027 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "FC983A936500FBD36F907D60CBDB3FA5"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/WebSession.java"
          },
          "region" : {
            "startLine" : 1027,
            "endLine" : 1027,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1291",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "D04EC036DB9FF599C02E3087AB9F1B08"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/WebSession.java"
          },
          "region" : {
            "startLine" : 1089,
            "endLine" : 1089,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1168",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "7298F4FD0956AB4D64B7E4F6ABDF77E8"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/WebSession.java"
          },
          "region" : {
            "startLine" : 1112,
            "endLine" : 1112,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1551",
      "message" : {
        "text" : "The function WebgoatProperties() in WebgoatProperties.java sometimes fails to release a system resource allocated by FileInputStream() on line 43.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "106C950FC6B8B677064B203028BDB065"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/WebgoatProperties.java"
          },
          "region" : {
            "startLine" : 43,
            "endLine" : 43,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1622",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "507FB7849EF51D8DB486A5FCAB42291A"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/WebgoatProperties.java"
          },
          "region" : {
            "startLine" : 49,
            "endLine" : 49,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1680",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "7F7F84EAD88E1BE410B4BA7DD7830C8C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/WebgoatProperties.java"
          },
          "region" : {
            "startLine" : 121,
            "endLine" : 121,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1649",
      "message" : {
        "text" : "The function main() in WebgoatProperties.java might reveal system data or debugging information by calling printStackTrace() on line 122.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "6C9B74DBF9AFC6C9F7143AA58F624D58"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/WebgoatProperties.java"
          },
          "region" : {
            "startLine" : 122,
            "endLine" : 122,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1681",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "7F7F84EAD88E1BE410B4BA7DD7830C8D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/session/WebgoatProperties.java"
          },
          "region" : {
            "startLine" : 124,
            "endLine" : 124,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1566",
      "message" : {
        "text" : "The method execOptions() in Exec.java calls exec() with a command built from untrusted data. This call can cause the program to execute malicious commands on behalf of an attacker.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "1EE43C8EBD079E2A1595DC2E202F0C99"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 103,
            "endLine" : 103,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "336",
      "message" : {
        "text" : "The catch block at Exec.java line 242 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "74B6FE7F53E88BA44158125257AF085B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 242,
            "endLine" : 242,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1567",
      "message" : {
        "text" : "The method execOptions() in Exec.java calls exec() with a command built from untrusted data. This call can cause the program to execute malicious commands on behalf of an attacker.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "1EE43C8EBD079E2A1595DC2E202F0C9A"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 292,
            "endLine" : 292,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "662",
      "message" : {
        "text" : "The catch block at Exec.java line 431 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "EDFA3F9BD1D1F3E8EDF285A937CF99B4"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 431,
            "endLine" : 431,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "675",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F3C745B5FF30BF594AB3FB9613BFE4B9"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 506,
            "endLine" : 506,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "10",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 509.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "07DC81F1724D3DD1F052EE4103383C30"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 509,
            "endLine" : 509,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "57",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 509.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "159D205600BB0BD92FC54008D21A504B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 509,
            "endLine" : 509,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "99",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 509.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "22527F24D3F8FE925A856B7C8B72C8B2"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 509,
            "endLine" : 509,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "512",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 509.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "AFC420B674CFEFCF5942C21091567532"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 509,
            "endLine" : 509,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "676",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F3C745B5FF30BF594AB3FB9613BFE4BA"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 509,
            "endLine" : 509,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "697",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 509.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F82BAB3CD0F3C4174E4E45AD5A4AC744"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 509,
            "endLine" : 509,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "677",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F3C745B5FF30BF594AB3FB9613BFE4BB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 510,
            "endLine" : 510,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "11",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 513.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "07DC81F1724D3DD1F052EE4103383C31"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 513,
            "endLine" : 513,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "58",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 513.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "159D205600BB0BD92FC54008D21A504C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 513,
            "endLine" : 513,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "100",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 513.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "22527F24D3F8FE925A856B7C8B72C8B3"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 513,
            "endLine" : 513,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "513",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 513.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "AFC420B674CFEFCF5942C21091567533"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 513,
            "endLine" : 513,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "678",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F3C745B5FF30BF594AB3FB9613BFE4BC"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 513,
            "endLine" : 513,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "698",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 513.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F82BAB3CD0F3C4174E4E45AD5A4AC745"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 513,
            "endLine" : 513,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "679",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F3C745B5FF30BF594AB3FB9613BFE4BD"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 517,
            "endLine" : 517,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "680",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F3C745B5FF30BF594AB3FB9613BFE4BE"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 520,
            "endLine" : 520,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "12",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 524.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "07DC81F1724D3DD1F052EE4103383C32"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 524,
            "endLine" : 524,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "59",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 524.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "159D205600BB0BD92FC54008D21A504D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 524,
            "endLine" : 524,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "101",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 524.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "22527F24D3F8FE925A856B7C8B72C8B4"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 524,
            "endLine" : 524,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "514",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 524.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "AFC420B674CFEFCF5942C21091567534"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 524,
            "endLine" : 524,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "681",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F3C745B5FF30BF594AB3FB9613BFE4BF"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 524,
            "endLine" : 524,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "699",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 524.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F82BAB3CD0F3C4174E4E45AD5A4AC746"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 524,
            "endLine" : 524,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "682",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F3C745B5FF30BF594AB3FB9613BFE4C0"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 525,
            "endLine" : 525,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "13",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 528.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "07DC81F1724D3DD1F052EE4103383C33"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 528,
            "endLine" : 528,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "60",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 528.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "159D205600BB0BD92FC54008D21A504E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 528,
            "endLine" : 528,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "102",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 528.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "22527F24D3F8FE925A856B7C8B72C8B5"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 528,
            "endLine" : 528,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "515",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 528.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "AFC420B674CFEFCF5942C21091567535"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 528,
            "endLine" : 528,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "683",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F3C745B5FF30BF594AB3FB9613BFE4C1"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 528,
            "endLine" : 528,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "700",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 528.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F82BAB3CD0F3C4174E4E45AD5A4AC747"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 528,
            "endLine" : 528,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "684",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F3C745B5FF30BF594AB3FB9613BFE4C2"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 529,
            "endLine" : 529,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "14",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 532.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "07DC81F1724D3DD1F052EE4103383C34"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 532,
            "endLine" : 532,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "61",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 532.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "159D205600BB0BD92FC54008D21A504F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 532,
            "endLine" : 532,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "103",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 532.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "22527F24D3F8FE925A856B7C8B72C8B6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 532,
            "endLine" : 532,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "516",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 532.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "AFC420B674CFEFCF5942C21091567536"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 532,
            "endLine" : 532,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "685",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F3C745B5FF30BF594AB3FB9613BFE4C3"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 532,
            "endLine" : 532,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "701",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 532.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F82BAB3CD0F3C4174E4E45AD5A4AC748"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 532,
            "endLine" : 532,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "686",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F3C745B5FF30BF594AB3FB9613BFE4C4"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 533,
            "endLine" : 533,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "15",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 536.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "07DC81F1724D3DD1F052EE4103383C35"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 536,
            "endLine" : 536,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "62",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 536.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "159D205600BB0BD92FC54008D21A5050"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 536,
            "endLine" : 536,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "104",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 536.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "22527F24D3F8FE925A856B7C8B72C8B7"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 536,
            "endLine" : 536,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "517",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 536.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "AFC420B674CFEFCF5942C21091567537"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 536,
            "endLine" : 536,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "687",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F3C745B5FF30BF594AB3FB9613BFE4C5"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 536,
            "endLine" : 536,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "702",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 536.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F82BAB3CD0F3C4174E4E45AD5A4AC749"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 536,
            "endLine" : 536,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "688",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F3C745B5FF30BF594AB3FB9613BFE4C6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 537,
            "endLine" : 537,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "16",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 540.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "07DC81F1724D3DD1F052EE4103383C36"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 540,
            "endLine" : 540,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "63",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 540.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "159D205600BB0BD92FC54008D21A5051"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 540,
            "endLine" : 540,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "105",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 540.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "22527F24D3F8FE925A856B7C8B72C8B8"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 540,
            "endLine" : 540,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "518",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 540.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "AFC420B674CFEFCF5942C21091567538"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 540,
            "endLine" : 540,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "689",
      "message" : {
        "text" : "Using <code>System.out</code> or <code>System.err</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F3C745B5FF30BF594AB3FB9613BFE4C7"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 540,
            "endLine" : 540,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "703",
      "message" : {
        "text" : "The function main() in Exec.java might reveal system data or debugging information by calling println() on line 540.  The information revealed by println() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "F82BAB3CD0F3C4174E4E45AD5A4AC74A"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Exec.java"
          },
          "region" : {
            "startLine" : 540,
            "endLine" : 540,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "572",
      "message" : {
        "text" : "Attackers can control the resource identifier argument to Socket() at Interceptor.java line 93, which could enable them to access or modify otherwise protected system resources.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "C41ED2B38B12CC87733F9860635B3D57"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Interceptor.java"
          },
          "region" : {
            "startLine" : 93,
            "endLine" : 93,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "94",
      "message" : {
        "text" : "Attackers can control the resource identifier argument to Socket() at Interceptor.java line 94, which could enable them to access or modify otherwise protected system resources.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "1EC821B90272EDDCE494AE29582A4CF2"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Interceptor.java"
          },
          "region" : {
            "startLine" : 94,
            "endLine" : 94,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "235",
      "message" : {
        "text" : "The function doFilter() in Interceptor.java might reveal system data or debugging information by calling printStackTrace() on line 110.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "4D29817A94B639966ABCDE67289F0FAB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Interceptor.java"
          },
          "region" : {
            "startLine" : 110,
            "endLine" : 110,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "234",
      "message" : {
        "text" : "The function doFilter() in Interceptor.java might reveal system data or debugging information by calling printStackTrace() on line 115.  The information revealed by printStackTrace() could help an adversary form a plan of attack.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "4D29817A94B639966ABCDE67289F0FAA"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Interceptor.java"
          },
          "region" : {
            "startLine" : 115,
            "endLine" : 115,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "69",
      "message" : {
        "text" : "Using a <code>throw</code> statement inside a <code>finally</code> block breaks the logical progression through the <code>try-catch-finally</code>.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "17E77BB9D3B68EEDFB3FFF3FE10B4377"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "JavaSource/org/owasp/webgoat/util/Interceptor.java"
          },
          "region" : {
            "startLine" : 118,
            "endLine" : 118,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "290",
      "message" : {
        "text" : "Storing a plaintext password in a configuration file could result in a system compromise.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "5E0FC7EC055048EF51BDE8974450F9CA"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "WebContent/WEB-INF/server-config.wsdd"
          },
          "region" : {
            "startLine" : 6,
            "endLine" : 6,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "390",
      "message" : {
        "text" : "A web application must define default error pages in order to prevent attackers from mining information from the application container's built-in error response.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "88F4D7D5D6180F7BCFE26DFEB49ADCA4"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "WebContent/WEB-INF/web-unix.xml"
          },
          "region" : {
            "startLine" : 6,
            "endLine" : 6,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "478",
      "message" : {
        "text" : "A web application must define default error pages in order to prevent attackers from mining information from the application container's built-in error response.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "A4F1C9B64A6151C8466143432EBAA61B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "WebContent/WEB-INF/web-windows.xml"
          },
          "region" : {
            "startLine" : 6,
            "endLine" : 6,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "178",
      "message" : {
        "text" : "A web application must define default error pages in order to prevent attackers from mining information from the application container's built-in error response.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "399A248E35AE0FBB04255DE45FA9754C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "WebContent/WEB-INF/web.xml"
          },
          "region" : {
            "startLine" : 6,
            "endLine" : 6,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "570",
      "message" : {
        "text" : "An overly long session timeout gives attackers more time to potentially compromise user accounts.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "C2F39B963AB1AFACD8D57325EEAF747F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "WebContent/WEB-INF/web.xml"
          },
          "region" : {
            "startLine" : 248,
            "endLine" : 248,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "220",
      "message" : {
        "text" : "A security constraint that does not specify a user data constraint cannot guarantee that restricted resources will be protected at the transport layer.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "4745492F4C56918DB027E1B7D27069F8"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "WebContent/WEB-INF/web.xml"
          },
          "region" : {
            "startLine" : 274,
            "endLine" : 274,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "221",
      "message" : {
        "text" : "A security constraint that does not specify a user data constraint cannot guarantee that restricted resources will be protected at the transport layer.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "4745492F4C56918DB027E1B7D27069F9"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "WebContent/WEB-INF/web.xml"
          },
          "region" : {
            "startLine" : 286,
            "endLine" : 286,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "157",
      "message" : {
        "text" : "The method _jspService() in config.jsp includes unvalidated data in an HTTP response header on line 12.  This enables attacks such as cache-poisoning, cross-site scripting, cross-user defacement, page hijacking, cookie manipulation or open redirect.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "321240CF763825D3F0C44AF194CBEB47"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "WebContent/lessons/ConfManagement/config.jsp"
          },
          "region" : {
            "startLine" : 12,
            "endLine" : 12,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "652",
      "message" : {
        "text" : "The method _jspService() in config.jsp includes unvalidated data in an HTTP response header on line 12.  This enables attacks such as cache-poisoning, cross-site scripting, cross-user defacement, page hijacking, cookie manipulation or open redirect.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "EB45BE23BC667630C8D71F49CF38686F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "WebContent/lessons/ConfManagement/config.jsp"
          },
          "region" : {
            "startLine" : 12,
            "endLine" : 12,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1542",
      "message" : {
        "text" : "The method _jspService() in EditProfile.jsp mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "051D7BA95A2D42257D911A40F0E94C51"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "WebContent/lessons/CrossSiteScripting/EditProfile.jsp"
          },
          "region" : {
            "startLine" : 54,
            "endLine" : 54,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "455",
      "message" : {
        "text" : "The method _jspService() in SearchStaff.jsp sends unvalidated data to a web browser on line 11, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "9DCDB59233971BE82AB2FD810501FC1F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "WebContent/lessons/CrossSiteScripting/SearchStaff.jsp"
          },
          "region" : {
            "startLine" : 11,
            "endLine" : 11,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1708",
      "message" : {
        "text" : "The method _jspService() in ViewProfile.jsp mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "9E05E5300B01063AF49BBCD16B41A873"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "WebContent/lessons/CrossSiteScripting/ViewProfile.jsp"
          },
          "region" : {
            "startLine" : 58,
            "endLine" : 58,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "231",
      "message" : {
        "text" : "The method _jspService() in EditProfile.jsp mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "4BFE6B2E3F7D26204AA3796D3F83DA94"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "WebContent/lessons/RoleBasedAccessControl/EditProfile.jsp"
          },
          "region" : {
            "startLine" : 53,
            "endLine" : 53,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1585",
      "message" : {
        "text" : "The method _jspService() in EditProfile.jsp mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "2E406966112D6EA14467FF26B134C3D2"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "WebContent/lessons/RoleBasedAccessControl/EditProfile.jsp"
          },
          "region" : {
            "startLine" : 53,
            "endLine" : 53,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "204",
      "message" : {
        "text" : "The method _jspService() in SearchStaff.jsp sends unvalidated data to a web browser on line 11, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "40889BA9E6868AC4207C03E0903DDE85"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "WebContent/lessons/RoleBasedAccessControl/SearchStaff.jsp"
          },
          "region" : {
            "startLine" : 11,
            "endLine" : 11,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1667",
      "message" : {
        "text" : "The method _jspService() in ViewProfile.jsp mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "756376895FB2B27F7B72E30C4E55F9C6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "WebContent/lessons/RoleBasedAccessControl/ViewProfile.jsp"
          },
          "region" : {
            "startLine" : 54,
            "endLine" : 54,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "110",
      "message" : {
        "text" : "The method _jspService() in EditProfile.jsp mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "253A24B2ACDB895D685D2C495F6FDCBF"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "WebContent/lessons/SQLInjection/EditProfile.jsp"
          },
          "region" : {
            "startLine" : 54,
            "endLine" : 54,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1782",
      "message" : {
        "text" : "The method _jspService() in EditProfile.jsp mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "D1FD83E074351358B66985F188CF4E9D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "WebContent/lessons/SQLInjection/EditProfile.jsp"
          },
          "region" : {
            "startLine" : 54,
            "endLine" : 54,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "144",
      "message" : {
        "text" : "The method _jspService() in SearchStaff.jsp sends unvalidated data to a web browser on line 11, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "2DF475BDE7FB507FB1C0BF848C0063EF"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "WebContent/lessons/SQLInjection/SearchStaff.jsp"
          },
          "region" : {
            "startLine" : 11,
            "endLine" : 11,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "1647",
      "message" : {
        "text" : "The method _jspService() in ViewProfile.jsp mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "6C1C6D3E16F2B1CFFBEAE37D1C717BC9"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "WebContent/lessons/SQLInjection/ViewProfile.jsp"
          },
          "region" : {
            "startLine" : 54,
            "endLine" : 54,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "461",
      "message" : {
        "text" : "The method _jspService() in main.jsp sends unvalidated data to a web browser on line 114, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "A02F8DBE56F5F4CDBAFBD7733B07B7B0"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "WebContent/main.jsp"
          },
          "region" : {
            "startLine" : 114,
            "endLine" : 114,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "462",
      "message" : {
        "text" : "The method _jspService() in main.jsp sends unvalidated data to a web browser on line 119, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "A02F8DBE56F5F4CDBAFBD7733B07B7B1"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "WebContent/main.jsp"
          },
          "region" : {
            "startLine" : 119,
            "endLine" : 119,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "463",
      "message" : {
        "text" : "The method _jspService() in main.jsp sends unvalidated data to a web browser on line 124, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "A02F8DBE56F5F4CDBAFBD7733B07B7B2"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "WebContent/main.jsp"
          },
          "region" : {
            "startLine" : 124,
            "endLine" : 124,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "464",
      "message" : {
        "text" : "The method _jspService() in main.jsp sends unvalidated data to a web browser on line 130, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "A02F8DBE56F5F4CDBAFBD7733B07B7B3"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "WebContent/main.jsp"
          },
          "region" : {
            "startLine" : 130,
            "endLine" : 130,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "465",
      "message" : {
        "text" : "The method _jspService() in main.jsp sends unvalidated data to a web browser on line 135, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "A02F8DBE56F5F4CDBAFBD7733B07B7B4"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "WebContent/main.jsp"
          },
          "region" : {
            "startLine" : 135,
            "endLine" : 135,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    } ]
  } ]
}