{
  "$schema" : "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
  "version" : "2.1.0",
  "runs" : [ {
    "tool" : {
      "driver" : {
        "name" : "Fortify on Demand",
        "version" : "SCA 22.1.0.0166; Rulepack 2022.1.0.0007",
        "rules" : [ {
          "id" : "22300900",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method serveFile() in UserController.java sends unvalidated data to a web browser on line 519, which can result in the browser executing malicious code.Sending unvalidated data to a web browser can result in the browser executing malicious code."
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of reflected XSS, the untrusted source is typically a web request, while in the case of persisted (also known as stored) XSS it is typically a database or other back-end data store.\n\n\nIn this case, the data enters at serveFile() in UserController.java on line 515.\n\n2. The data is included in dynamic content that is sent to a web user without validation.\n\nIn this case, the data is sent at body() in UserController.java on line 519.\n\nThe malicious content sent to the web browser often takes the form of a JavaScript segment, but can also include HTML, Flash or any other type of code that the browser executes. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data such as cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\n\n\n\nThe code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes metacharacters or source code, then the code is executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use email or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\n\n\n\nAs in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker may execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it difficult to identify the threat and increases the possibility that the attack might affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nSome think that in the mobile environment, classic web application vulnerabilities, such as cross-site scripting, do not make sense -- why would the user attack themself? However, keep in mind that the essence of mobile platforms is applications that are downloaded from various sources and run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which necessitates expanding the attack surface of mobile applications to include inter-process communication.\n\nExample 3: The following code enables JavaScript in Android's WebView (by default, JavaScript is disabled) and loads a page based on the value received from an Android intent.\n\n\n...\nWebView webview = (WebView) findViewById(R.id.webview);\nwebview.getSettings().setJavaScriptEnabled(true);\nString url = this.getIntent().getExtras().getString(\"url\");\nwebview.loadUrl(url);\n...\n\n\nIf the value of url starts with javascript:, JavaScript code that follows executes within the context of the web page inside WebView.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or emailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that might include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- As in Example 3, a source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\n\n\n\nThe solution to prevent XSS is to ensure that validation occurs in the required places and that relevant properties are set to prevent vulnerabilities.\n\nBecause XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate all input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application might accept input through a shared data store or other trusted source, and that data store might accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means that the best way to prevent XSS vulnerabilities is to validate everything that enters the application and leaves the application destined for the user.\n\nThe most secure approach to validation for XSS is to create an allow list of safe characters that can appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alphanumeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser must be considered valid input after they are encoded, such as a web design bulletin board that must accept HTML fragments from its users.\n\nA more flexible, but less secure approach is to implement a deny list, which selectively rejects or escapes potentially dangerous characters before using the input. To form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines which characters have special meaning, many web browsers try to correct common mistakes in HTML and might treat other characters as special in certain contexts. This is why we do not recommend the use of deny lists as a means to prevent XSS. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed in double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed in single quotes, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity.\n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything greater than 127 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page.\n\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- Semicolons, parentheses, curly braces, and new line characters must be filtered out in situations where text could be inserted directly into a pre-existing script tag.\n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering.\n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and might bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nAfter you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and might be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. For any developed application, there are no guarantees about which application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will continue to stay in sync.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/b461ce4d-7c86-4d95-83de-71192cdbfa8a"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "22300895",
          "shortDescription" : {
            "text" : "Header Manipulation"
          },
          "fullDescription" : {
            "text" : "The method serveFile() in UserController.java includes unvalidated data in an HTTP response header on line 519. This enables attacks such as cache-poisoning, cross-site scripting, cross-user defacement, page hijacking, cookie manipulation or open redirect.Including unvalidated data in an HTTP response header can enable cache-poisoning, cross-site scripting, cross-user defacement, page hijacking, cookie manipulation or open redirect."
          },
          "help" : {
            "text" : "Header Manipulation vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source, most frequently an HTTP request.\n\nIn this case, the data enters at serveFile() in UserController.java on line 515.\n\n\n\n2. The data is included in an HTTP response header sent to a web user without being validated.\n\nIn this case, the data is sent at header() in UserController.java on line 519.\n\nAs with many software security vulnerabilities, Header Manipulation is a means to an end, not an end in itself. At its root, the vulnerability is straightforward: an attacker passes malicious data to a vulnerable application, and the application includes the data in an HTTP response header.\n\nOne of the most common Header Manipulation attacks is HTTP Response Splitting. To mount a successful HTTP Response Splitting exploit, the application must allow input that contains CR (carriage return, also given by %0d or \\r) and LF (line feed, also given by %0a or \n)characters into the header. These characters not only give attackers control of the remaining headers and body of the response the application intends to send, but also allows them to create additional responses entirely under their control.\n\nMany of today's modern application servers will prevent the injection of malicious characters into HTTP headers. For example, recent versions of Apache Tomcat will throw an IllegalArgumentException if you attempt to set a header with prohibited characters. If your application server prevents setting headers with new line characters, then your application is not vulnerable to HTTP Response Splitting. However, solely filtering for new line characters can leave an application vulnerable to Cookie Manipulation or Open Redirects, so care must still be taken when setting HTTP headers with user input.\n\nExample: The following code segment reads the name of the author of a weblog entry, author, from an HTTP request and sets it in a cookie header of an HTTP response.\n\n\nString author = request.getParameter(AUTHOR_PARAM);\n...\nCookie cookie = new Cookie(\"author\", author);\ncookie.setMaxAge(cookieExpiration);\nresponse.addCookie(cookie);\n\n\nAssuming a string consisting of standard alphanumeric characters, such as \"Jane Smith\", is submitted in the request the HTTP response including this cookie might take the following form:\n\n\nHTTP/1.1 200 OK\n...\nSet-Cookie: author=Jane Smith\n...\n\n\nHowever, because the value of the cookie is formed of unvalidated user input the response will only maintain this form if the value submitted for AUTHOR_PARAM does not contain any CR and LF characters. If an attacker submits a malicious string, such as \"Wiley Hacker\\r\nHTTP/1.1 200 OK\\r\n...\", then the HTTP response would be split into two responses of the following form:\n\n\nHTTP/1.1 200 OK\n...\nSet-Cookie: author=Wiley Hacker\n\nHTTP/1.1 200 OK\n...\n\n\nClearly, the second response is completely controlled by the attacker and can be constructed with any header and body content desired. The ability of attacker to construct arbitrary HTTP responses permits a variety of resulting attacks, including: cross-user defacement, web and browser cache poisoning, cross-site scripting, and page hijacking.\n\nCross-User Defacement: An attacker will be able to make a single request to a vulnerable server that will cause the server to create two responses, the second of which may be misinterpreted as a response to a different request, possibly one made by another user sharing the same TCP connection with the server. This can be accomplished by convincing the user to submit the malicious request themselves, or remotely in situations where the attacker and the user share a common TCP connection to the server, such as a shared proxy server. In the best case, an attacker may leverage this ability to convince users that the application has been hacked, causing users to lose confidence in the security of the application. In the worst case, an attacker may provide specially crafted content designed to mimic the behavior of the application but redirect private information, such as account numbers and passwords, back to the attacker.\n\nCache Poisoning: The impact of a maliciously constructed response can be magnified if it is cached either by a web cache used by multiple users or even the browser cache of a single user. If a response is cached in a shared web cache, such as those commonly found in proxy servers, then all users of that cache will continue receive the malicious content until the cache entry is purged. Similarly, if the response is cached in the browser of an individual user, then that user will continue to receive the malicious content until the cache entry is purged, although only the user of the local browser instance will be affected.\n\nCross-Site Scripting: Once attackers have control of the responses sent by an application, they have a choice of a variety of malicious content to provide users. Cross-site scripting is common form of attack where malicious JavaScript or other code included in a response is executed in the user's browser. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data such as cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site. The most common and dangerous attack vector against users of a vulnerable application uses JavaScript to transmit session and authentication information back to the attacker who can then take complete control of the victim's account.\n\nPage Hijacking: In addition to using a vulnerable application to send malicious content to a user, the same root vulnerability can also be leveraged to redirect sensitive content generated by the server and intended for the user to the attacker instead. By submitting a request that results in two responses, the intended response from the server and the response generated by the attacker, an attacker may cause an intermediate node, such as a shared proxy server, to misdirect a response generated by the server for the user to the attacker. Because the request made by the attacker generates two responses, the first is interpreted as a response to the attacker's request, while the second remains in limbo. When the user makes a legitimate request through the same TCP connection, the attacker's request is already waiting and is interpreted as a response to the victim's request. The attacker then sends a second request to the server, to which the proxy server responds with the server generated request intended for the victim, thereby compromising any sensitive information in the headers or body of the response intended for the victim.\n\nCookie Manipulation: When combined with attacks like Cross-Site Request Forgery, attackers may change, add to, or even overwrite a legitimate user's cookies.\n\nOpen Redirect: Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.\n\nThe solution to prevent Header Manipulation is to ensure that input validation occurs in the required places and checks for the correct properties.\n\nSince Header Manipulation vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating responses dynamically, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for Header Manipulation.\n\nWeb applications must validate all input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for Header Manipulation is generally relatively easy. Despite its value, input validation for Header Manipulation does not take the place of rigorous output validation. An application might accept input through a shared data store or other trusted source, and that data store might accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means that the best way to prevent Header Manipulation vulnerabilities is to validate everything that enters the application or leaves the application destined for the user.\n\nThe most secure approach to validation for Header Manipulation is to create an allow list of safe characters that can appear in HTTP response headers and accept input composed exclusively of characters in the approved set. For example, a valid name might only include alphanumeric characters or an account number might only include digits 0-9.\n\nA more flexible, but less secure approach is to implement a deny list, which selectively rejects or escapes potentially dangerous characters before using the input. To form such a list, you first need to understand the set of characters that hold special meaning in HTTP response headers. Although the CR and LF characters are at the heart of an HTTP response splitting attack, other characters, such as ':' (colon) and '=' (equal), have special meaning in response headers as well.\n\nAfter you identify the correct points in an application to perform validation for Header Manipulation attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. The application should reject any input destined to be included in HTTP response headers that contains special characters, particularly CR and LF, as invalid.\n\nMany application servers attempt to limit an application's exposure to HTTP response splitting vulnerabilities by providing implementations for the functions responsible for setting HTTP headers and cookies that perform validation for the characters essential to an HTTP response splitting attack. Do not rely on the server running your application to make it secure. For any developed application, there are no guarantees about which application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will continue to stay in sync.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/7ec7d3ef-5a2a-40c3-ac98-5eab5f3e84a9"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "24780821",
          "shortDescription" : {
            "text" : "Header Manipulation"
          },
          "fullDescription" : {
            "text" : "The method downloadFile() in ProductController.java includes unvalidated data in an HTTP response header on line 147. This enables attacks such as cache-poisoning, cross-site scripting, cross-user defacement, page hijacking, cookie manipulation or open redirect.Including unvalidated data in an HTTP response header can enable cache-poisoning, cross-site scripting, cross-user defacement, page hijacking, cookie manipulation or open redirect."
          },
          "help" : {
            "text" : "Header Manipulation vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source, most frequently an HTTP request.\n\nIn this case, the data enters at downloadFile() in ProductController.java on line 113.\n\n\n\n2. The data is included in an HTTP response header sent to a web user without being validated.\n\nIn this case, the data is sent at header() in ProductController.java on line 147.\n\nAs with many software security vulnerabilities, Header Manipulation is a means to an end, not an end in itself. At its root, the vulnerability is straightforward: an attacker passes malicious data to a vulnerable application, and the application includes the data in an HTTP response header.\n\nOne of the most common Header Manipulation attacks is HTTP Response Splitting. To mount a successful HTTP Response Splitting exploit, the application must allow input that contains CR (carriage return, also given by %0d or \\r) and LF (line feed, also given by %0a or \n)characters into the header. These characters not only give attackers control of the remaining headers and body of the response the application intends to send, but also allows them to create additional responses entirely under their control.\n\nMany of today's modern application servers will prevent the injection of malicious characters into HTTP headers. For example, recent versions of Apache Tomcat will throw an IllegalArgumentException if you attempt to set a header with prohibited characters. If your application server prevents setting headers with new line characters, then your application is not vulnerable to HTTP Response Splitting. However, solely filtering for new line characters can leave an application vulnerable to Cookie Manipulation or Open Redirects, so care must still be taken when setting HTTP headers with user input.\n\nExample: The following code segment reads the name of the author of a weblog entry, author, from an HTTP request and sets it in a cookie header of an HTTP response.\n\n\nString author = request.getParameter(AUTHOR_PARAM);\n...\nCookie cookie = new Cookie(\"author\", author);\ncookie.setMaxAge(cookieExpiration);\nresponse.addCookie(cookie);\n\n\nAssuming a string consisting of standard alphanumeric characters, such as \"Jane Smith\", is submitted in the request the HTTP response including this cookie might take the following form:\n\n\nHTTP/1.1 200 OK\n...\nSet-Cookie: author=Jane Smith\n...\n\n\nHowever, because the value of the cookie is formed of unvalidated user input the response will only maintain this form if the value submitted for AUTHOR_PARAM does not contain any CR and LF characters. If an attacker submits a malicious string, such as \"Wiley Hacker\\r\nHTTP/1.1 200 OK\\r\n...\", then the HTTP response would be split into two responses of the following form:\n\n\nHTTP/1.1 200 OK\n...\nSet-Cookie: author=Wiley Hacker\n\nHTTP/1.1 200 OK\n...\n\n\nClearly, the second response is completely controlled by the attacker and can be constructed with any header and body content desired. The ability of attacker to construct arbitrary HTTP responses permits a variety of resulting attacks, including: cross-user defacement, web and browser cache poisoning, cross-site scripting, and page hijacking.\n\nCross-User Defacement: An attacker will be able to make a single request to a vulnerable server that will cause the server to create two responses, the second of which may be misinterpreted as a response to a different request, possibly one made by another user sharing the same TCP connection with the server. This can be accomplished by convincing the user to submit the malicious request themselves, or remotely in situations where the attacker and the user share a common TCP connection to the server, such as a shared proxy server. In the best case, an attacker may leverage this ability to convince users that the application has been hacked, causing users to lose confidence in the security of the application. In the worst case, an attacker may provide specially crafted content designed to mimic the behavior of the application but redirect private information, such as account numbers and passwords, back to the attacker.\n\nCache Poisoning: The impact of a maliciously constructed response can be magnified if it is cached either by a web cache used by multiple users or even the browser cache of a single user. If a response is cached in a shared web cache, such as those commonly found in proxy servers, then all users of that cache will continue receive the malicious content until the cache entry is purged. Similarly, if the response is cached in the browser of an individual user, then that user will continue to receive the malicious content until the cache entry is purged, although only the user of the local browser instance will be affected.\n\nCross-Site Scripting: Once attackers have control of the responses sent by an application, they have a choice of a variety of malicious content to provide users. Cross-site scripting is common form of attack where malicious JavaScript or other code included in a response is executed in the user's browser. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data such as cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site. The most common and dangerous attack vector against users of a vulnerable application uses JavaScript to transmit session and authentication information back to the attacker who can then take complete control of the victim's account.\n\nPage Hijacking: In addition to using a vulnerable application to send malicious content to a user, the same root vulnerability can also be leveraged to redirect sensitive content generated by the server and intended for the user to the attacker instead. By submitting a request that results in two responses, the intended response from the server and the response generated by the attacker, an attacker may cause an intermediate node, such as a shared proxy server, to misdirect a response generated by the server for the user to the attacker. Because the request made by the attacker generates two responses, the first is interpreted as a response to the attacker's request, while the second remains in limbo. When the user makes a legitimate request through the same TCP connection, the attacker's request is already waiting and is interpreted as a response to the victim's request. The attacker then sends a second request to the server, to which the proxy server responds with the server generated request intended for the victim, thereby compromising any sensitive information in the headers or body of the response intended for the victim.\n\nCookie Manipulation: When combined with attacks like Cross-Site Request Forgery, attackers may change, add to, or even overwrite a legitimate user's cookies.\n\nOpen Redirect: Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.\n\nThe solution to prevent Header Manipulation is to ensure that input validation occurs in the required places and checks for the correct properties.\n\nSince Header Manipulation vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating responses dynamically, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for Header Manipulation.\n\nWeb applications must validate all input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for Header Manipulation is generally relatively easy. Despite its value, input validation for Header Manipulation does not take the place of rigorous output validation. An application might accept input through a shared data store or other trusted source, and that data store might accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means that the best way to prevent Header Manipulation vulnerabilities is to validate everything that enters the application or leaves the application destined for the user.\n\nThe most secure approach to validation for Header Manipulation is to create an allow list of safe characters that can appear in HTTP response headers and accept input composed exclusively of characters in the approved set. For example, a valid name might only include alphanumeric characters or an account number might only include digits 0-9.\n\nA more flexible, but less secure approach is to implement a deny list, which selectively rejects or escapes potentially dangerous characters before using the input. To form such a list, you first need to understand the set of characters that hold special meaning in HTTP response headers. Although the CR and LF characters are at the heart of an HTTP response splitting attack, other characters, such as ':' (colon) and '=' (equal), have special meaning in response headers as well.\n\nAfter you identify the correct points in an application to perform validation for Header Manipulation attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. The application should reject any input destined to be included in HTTP response headers that contains special characters, particularly CR and LF, as invalid.\n\nMany application servers attempt to limit an application's exposure to HTTP response splitting vulnerabilities by providing implementations for the functions responsible for setting HTTP headers and cookies that perform validation for the characters essential to an HTTP response splitting attack. Do not rely on the server running your application to make it secure. For any developed application, there are no guarantees about which application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will continue to stay in sync.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/a9fcc9f1-7ec8-42cb-b5e3-8b7fd968205e"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "12336035",
          "shortDescription" : {
            "text" : "HTML5: Missing Content Security Policy"
          },
          "fullDescription" : {
            "text" : "Content Security Policy (CSP) is not configured."
          },
          "help" : {
            "text" : "Content Security Policy (CSP) is a declarative security header that enables developers to dictate which domains the site is allowed to load content from or initiate connections to when rendered in the web browser. It provides an additional layer of security from critical vulnerabilities such as cross-site scripting, clickjacking, cross-origin access and the like, on top of input validation and checking an allow list in code.\n\nSpring Security and other frameworks do not add Content Security Policy headers by default. The web application author must declare the security policy/policies to enforce or monitor for the protected resources to benefit from this additional layer of security.\n\n\nConfigure a Content Security Policy to mitigate possible injection vulnerabilities.\n\nExample: The following code sets a Content Security Policy in a Spring Security protected application:\n\n@Override\nprotected void configure(HttpSecurity http) throws Exception {\n...\nString policy = getCSPolicy();\nhttp.headers().contentSecurityPolicy(policy);\n...\n}\n\n\nContent Security Policy is not intended to solve all content injection vulnerabilities. Instead, you can leverage CSP to help reduce the harm caused by content injection attacks. Use regular defensive coding,above, current such as input validation and output encoding.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/ba7a37ce-00bd-43f9-b634-3069fbfaa35a"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "12336036",
          "shortDescription" : {
            "text" : "HTML5: Missing Content Security Policy"
          },
          "fullDescription" : {
            "text" : "Content Security Policy (CSP) is not configured."
          },
          "help" : {
            "text" : "Content Security Policy (CSP) is a declarative security header that enables developers to dictate which domains the site is allowed to load content from or initiate connections to when rendered in the web browser. It provides an additional layer of security from critical vulnerabilities such as cross-site scripting, clickjacking, cross-origin access and the like, on top of input validation and checking an allow list in code.\n\nSpring Security and other frameworks do not add Content Security Policy headers by default. The web application author must declare the security policy/policies to enforce or monitor for the protected resources to benefit from this additional layer of security.\n\n\nConfigure a Content Security Policy to mitigate possible injection vulnerabilities.\n\nExample: The following code sets a Content Security Policy in a Spring Security protected application:\n\n@Override\nprotected void configure(HttpSecurity http) throws Exception {\n...\nString policy = getCSPolicy();\nhttp.headers().contentSecurityPolicy(policy);\n...\n}\n\n\nContent Security Policy is not intended to solve all content injection vulnerabilities. Instead, you can leverage CSP to help reduce the harm caused by content injection attacks. Use regular defensive coding,above, current such as input validation and output encoding.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/0d9fcbb9-8a71-41a9-a1ed-405df63ef868"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "12336034",
          "shortDescription" : {
            "text" : "HTML5: Missing Framing Protection"
          },
          "fullDescription" : {
            "text" : "The application does not restrict browsers from letting third-party sites render its content."
          },
          "help" : {
            "text" : "Allowing your website to be added to a frame can be a security issue. For example, it may lead to clickjacking vulnerabilities or allow undesired cross-frame communications.\n\nBy default, frameworks such as Spring Security include the X-Frame-Options header to instruct the browser whether the application should be framed. Disabling or not setting this header can lead to cross-frame related vulnerabilities.\n\nExample 1: The following code configures a Spring Security protected application to disable the X-Frame-Options header:\n\n@Override\nprotected void configure(HttpSecurity http) throws Exception {\n...\nhttp.headers().frameOptions().disable();\n...\n}\n\n\nSet the X-Frame-Options header as an additional layer of protection. If your application never needs to be framed, set its value to DENY, otherwise if it needs to be framed by a different application or page from the same origin, set its value to SAMEORIGIN.\n\nBy default, Spring Security disables rendering within an iframe. You can customize X-Frame-Options header to fit your application's requirements.\n\nExample 2: The following code configures a Spring Security protected application to use a SAMEORIGIN policy:\n\n@Override\nprotected void configure(HttpSecurity http) throws Exception {\n...\nhttp.headers().frameOptions().sameOrigin();\n...\n}\n\n\nFor more information, see https://emea.fortify.com//redirect/Issues/f181bb9a-beb0-4d6d-b861-bad4df9d4a44"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "25337208",
          "shortDescription" : {
            "text" : "Insecure SSL: Server Identity Verification Disabled"
          },
          "fullDescription" : {
            "text" : "The connection established via send() in EmailUtils.java does not verify the server certificate when making an SSL connection. This leaves the application vulnerable to a man-in-the-middle attack.Server identity verification is disabled when making SSL connections."
          },
          "help" : {
            "text" : "In some libraries that use SSL connections, the server certificate is not verified by default. This is equivalent to trusting all certificates.\n\nExample 1: This application does not explicitly verify the server certificate.\n\n\n...\nEmail email = new SimpleEmail();\nemail.setHostName(\"smtp.servermail.com\");\nemail.setSmtpPort(465);\nemail.setAuthenticator(new DefaultAuthenticator(username, password));\nemail.setSSLOnConnect(true);\nemail.setFrom(\"user@gmail.com\");\nemail.setSubject(\"TestMail\");\nemail.setMsg(\"This is a test mail ... :-)\");\nemail.addTo(\"foo@bar.com\");\nemail.send();\n...\n\n\nWhen trying to connect to smtp.mailserver.com:465, this application would readily accept a certificate issued to \"hackedserver.com\". The application would now potentially leak sensitive user information on a broken SSL connection to the hacked server.\n\nDo not forget server verification checks when making SSL connections. Depending on the library used, make sure to verify server identity and establish a secure SSL connection.\n\nExample 2: This application does explicitly verify the server certificate.\n\n\n...\nEmail email = new SimpleEmail();\nemail.setHostName(\"smtp.servermail.com\");\nemail.setSmtpPort(465);\nemail.setAuthenticator(new DefaultAuthenticator(username, password));\nemail.setSSLCheckServerIdentity(true);\nemail.setSSLOnConnect(true);\nemail.setFrom(\"user@gmail.com\");\nemail.setSubject(\"TestMail\");\nemail.setMsg(\"This is a test mail ... :-)\");\nemail.addTo(\"foo@bar.com\");\nemail.send();\n...\n\n\n\nFor more information, see https://emea.fortify.com//redirect/Issues/0c53a9e4-e984-4164-9004-7290b6632a9b"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "11445528",
          "shortDescription" : {
            "text" : "J2EE Bad Practices: Non-Serializable Object Stored in Session"
          },
          "fullDescription" : {
            "text" : "The method onAuthenticationSuccess() in UrlAuthenticationSuccessHandler.java stores a non-serializable object as an HttpSession attribute, which can damage application reliability.Storing a non-serializable object as an HttpSession attribute can damage application reliability."
          },
          "help" : {
            "text" : "A J2EE application can make use of multiple JVMs in order to improve application reliability and performance. In order to make the multiple JVMs appear as a single application to the end user, the J2EE container can replicate an HttpSession object across multiple JVMs so that if one JVM becomes unavailable another can step in and take its place without disrupting the flow of the application.\n\nIn order for session replication to work, the values the application stores as attributes in the session must implement the Serializable interface.\n\nExample 1: The following class adds itself to the session, but because it is not serializable, the session can no longer be replicated.\n\n\npublic class DataGlob {\nString globName;\nString globValue;\n\npublic void addToSession(HttpSession session) {\nsession.setAttribute(\"glob\", this);\n}\n}\n\n\nIn many cases, the easiest way to fix this problem is simply to have the offending object implement the Serializable interface.\n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\npublic class DataGlob implements java.io.Serializable {\nString globName;\nString globValue;\n\npublic void addToSession(HttpSession session) {\nsession.setAttribute(\"glob\", this);\n}\n}\n\n\nNote that for complex objects, the transitive closure of the objects stored in the session must be serializable. If object A references object B and object A is stored in the session, then both A and B must implement Serializable.\n\nWhile implementing the Serializable interface is often easy (since the interface does not force the class to define any methods), some types of objects will cause complications. Watch out for objects that hold references to external resources. For example, both streams and JNI are likely to cause complications.\n\nExample 3: Use type checking to require serializable objects. Instead of this:\n\n\npublic static void addToSession(HttpServletRequest req,\nString attrib, Object obj)\n{\nHttpSession sess = req.getSession(true);\nsess.setAttribute(attrib, obj);\n}\n\n\nwrite this:\n\n\npublic static void addToSession(HttpServletRequest req,\nString attrib, Serializable ser) {\nHttpSession sess = req.getSession(true);\nsess.setAttribute(attrib, ser);\n}\n\n\nFor more information, see https://emea.fortify.com//redirect/Issues/5b76a950-f650-4838-a72c-9112f04198cd"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "24851297",
          "shortDescription" : {
            "text" : "J2EE Bad Practices: Non-Serializable Object Stored in Session"
          },
          "fullDescription" : {
            "text" : "The method generateAndSetSession() in JwtUtils.java stores a non-serializable object as an HttpSession attribute, which can damage application reliability.Storing a non-serializable object as an HttpSession attribute can damage application reliability."
          },
          "help" : {
            "text" : "A J2EE application can make use of multiple JVMs in order to improve application reliability and performance. In order to make the multiple JVMs appear as a single application to the end user, the J2EE container can replicate an HttpSession object across multiple JVMs so that if one JVM becomes unavailable another can step in and take its place without disrupting the flow of the application.\n\nIn order for session replication to work, the values the application stores as attributes in the session must implement the Serializable interface.\n\nExample 1: The following class adds itself to the session, but because it is not serializable, the session can no longer be replicated.\n\n\npublic class DataGlob {\nString globName;\nString globValue;\n\npublic void addToSession(HttpSession session) {\nsession.setAttribute(\"glob\", this);\n}\n}\n\n\nIn many cases, the easiest way to fix this problem is simply to have the offending object implement the Serializable interface.\n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\npublic class DataGlob implements java.io.Serializable {\nString globName;\nString globValue;\n\npublic void addToSession(HttpSession session) {\nsession.setAttribute(\"glob\", this);\n}\n}\n\n\nNote that for complex objects, the transitive closure of the objects stored in the session must be serializable. If object A references object B and object A is stored in the session, then both A and B must implement Serializable.\n\nWhile implementing the Serializable interface is often easy (since the interface does not force the class to define any methods), some types of objects will cause complications. Watch out for objects that hold references to external resources. For example, both streams and JNI are likely to cause complications.\n\nExample 3: Use type checking to require serializable objects. Instead of this:\n\n\npublic static void addToSession(HttpServletRequest req,\nString attrib, Object obj)\n{\nHttpSession sess = req.getSession(true);\nsess.setAttribute(attrib, obj);\n}\n\n\nwrite this:\n\n\npublic static void addToSession(HttpServletRequest req,\nString attrib, Serializable ser) {\nHttpSession sess = req.getSession(true);\nsess.setAttribute(attrib, ser);\n}\n\n\nFor more information, see https://emea.fortify.com//redirect/Issues/fc55c5ce-e073-4c79-855e-455c7c36b4f2"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "14220168",
          "shortDescription" : {
            "text" : "JSON Injection"
          },
          "fullDescription" : {
            "text" : "On line 115 of UserUtils.java, the method registerUser() writes unvalidated input into JSON. This call could allow an attacker to inject arbitrary elements or attributes into the JSON entity.The method writes unvalidated input into JSON. This call could allow an attacker to inject arbitrary elements or attributes into the JSON entity."
          },
          "help" : {
            "text" : "JSON injection occurs when:\n\n1. Data enters a program from an untrusted source.\n\nIn this case, the data enters at subscribeUser() in ApiSiteController.java on line 194.\n\n\n2. The data is written to a JSON stream.\n\nIn this case, the JSON is written by writeRawValue() in UserUtils.java on line 115.\n\nApplications typically use JSON to store data or send messages. When used to store data, JSON is often treated like cached data and may potentially contain sensitive information. When used to send messages, JSON is often used in conjunction with a RESTful service and can be used to transmit sensitive information such as authentication credentials.\n\nThe semantics of JSON documents and messages can be altered if an application constructs JSON from unvalidated input. In a relatively benign case, an attacker may be able to insert extraneous elements that cause an application to throw an exception while parsing a JSON document or request. In a more serious case, such as ones that involves JSON injection, an attacker may be able to insert extraneous elements that allow for the predictable manipulation of business critical values within a JSON document or request. In some cases, JSON injection can lead to cross-site scripting or dynamic code evaluation.\n\nExample 1: The following Java code uses Jackson to serialize user account authentication information for non-privileged users (those with a role of \"default\" as opposed to privileged users with a role of \"admin\") from user-controlled input variables username and password to the JSON file located at ~/user_info.json:\n\n\n...\n\nJsonFactory jfactory = new JsonFactory();\n\nJsonGenerator jGenerator = jfactory.createJsonGenerator(new File(\"~/user_info.json\"), JsonEncoding.UTF8);\n\njGenerator.writeStartObject();\n\njGenerator.writeFieldName(\"username\");\njGenerator.writeRawValue(\"\\\"\" + username + \"\\\"\");\n\njGenerator.writeFieldName(\"password\");\njGenerator.writeRawValue(\"\\\"\" + password + \"\\\"\");\n\njGenerator.writeFieldName(\"role\");\njGenerator.writeRawValue(\"\\\"default\\\"\");\n\njGenerator.writeEndObject();\n\njGenerator.close();\n\n\nYet, because the JSON serialization is performed using JsonGenerator.writeRawValue(), the untrusted data in username and password will not be validated to escape JSON-related special characters. This allows a user to arbitrarily insert JSON keys, possibly changing the structure of the serialized JSON. In this example, if the non-privileged user mallory with password Evil123! were to append \",\"role\":\"admin to her username when entering it at the prompt that sets the value of the username variable, the resulting JSON saved to ~/user_info.json would be:\n\n\n{\n\"username\":\"mallory\",\n\"role\":\"admin\",\n\"password\":\"Evil123!\",\n\"role\":\"default\"\n}\n\n\nIf this serialized JSON file were then deserialized to an HashMap object with Jackson's JsonParser as so:\n\n\nJsonParser jParser = jfactory.createJsonParser(new File(\"~/user_info.json\"));\n\nwhile (jParser.nextToken() != JsonToken.END_OBJECT) {\n\nString fieldname = jParser.getCurrentName();\n\nif (\"username\".equals(fieldname)) {\njParser.nextToken();\nuserInfo.put(fieldname, jParser.getText());\n}\n\nif (\"password\".equals(fieldname)) {\njParser.nextToken();\nuserInfo.put(fieldname, jParser.getText());\n}\n\nif (\"role\".equals(fieldname)) {\njParser.nextToken();\nuserInfo.put(fieldname, jParser.getText());\n}\n\nif (userInfo.size() == 3)\nbreak;\n}\n\njParser.close();\n\n\nThe resulting values for the username, password, and role keys in the HashMap object would be mallory, Evil123!, and admin respectively. Without further verification that the deserialized JSON values are valid, the application will incorrectly assign user mallory \"admin\" privileges.\n\nWhen writing user supplied data to JSON, follow these guidelines:\n\n1. Do not create JSON attributes with names that are derived from user input.\n\n2. Ensure that all serialization to JSON is performed using a safe serialization function that delimits untrusted data within single or double quotes and escapes any special characters.\n\nExample 2: The following Java code implements the same functionality as that in Example 1, but instead uses JsonGenerator.writeString() rather than JsonGenerator.writeRawValue() to serialize the data, therefore ensuring that any untrusted data is properly delimited and escaped:\n\n\n...\n\nJsonFactory jfactory = new JsonFactory();\n\nJsonGenerator jGenerator = jfactory.createJsonGenerator(new File(\"~/user_info.json\"), JsonEncoding.UTF8);\n\njGenerator.writeStartObject();\n\njGenerator.writeFieldName(\"username\");\njGenerator.writeString(username);\n\njGenerator.writeFieldName(\"password\");\njGenerator.writeString(password);\n\njGenerator.writeFieldName(\"role\");\njGenerator.writeString(\"default\");\n\njGenerator.writeEndObject();\n\njGenerator.close();\n\n\nFor more information, see https://emea.fortify.com//redirect/Issues/89e81d4c-6cec-4874-8d1d-96d636bd90b7"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "11445520",
          "shortDescription" : {
            "text" : "Log Forging"
          },
          "fullDescription" : {
            "text" : "The method startDbBackup() in AdminUtils.java writes unvalidated user input to the log on line 67. An attacker could take advantage of this behavior to forge log entries or inject malicious content into the log.Writing unvalidated user input to log files can allow an attacker to forge log entries or inject malicious content into the logs."
          },
          "help" : {
            "text" : "Log forging vulnerabilities occur when:\n\n1. Data enters an application from an untrusted source.\n\nIn this case, the data enters at runDbBackup() in AdminDefaultController.java on line 81.\n\n2. The data is written to an application or system log file.\n\nIn this case, the data is logged by info() in AdminUtils.java on line 67.\n\nApplications typically use log files to store a history of events or transactions for later review, statistics gathering, or debugging. Depending on the nature of the application, the task of reviewing log files may be performed manually on an as-needed basis or automated with a tool that automatically culls logs for important events or trending information.\n\nInterpretation of the log files may be hindered or misdirected if an attacker can supply data to the application that is subsequently logged verbatim. In the most benign case, an attacker may be able to insert false entries into the log file by providing the application with input that includes appropriate characters. If the log file is processed automatically, the attacker may be able to render the file unusable by corrupting the format of the file or injecting unexpected characters. A more subtle attack might involve skewing the log file statistics. Forged or otherwise, corrupted log files can be used to cover an attacker's tracks or even to implicate another party in the commission of a malicious act [1]. In the worst case, an attacker may inject code or other commands into the log file and take advantage of a vulnerability in the log processing utility [2].\n\nExample 1: The following web application code attempts to read an integer value from a request object. If the value fails to parse as an integer, then the input is logged with an error message indicating what happened.\n\n\n...\nString val = request.getParameter(\"val\");\ntry {\nint value = Integer.parseInt(val);\n}\ncatch (NumberFormatException nfe) {\nlog.info(\"Failed to parse val = \" + val);\n}\n...\n\n\nIf a user submits the string \"twenty-one\" for val, the following entry is logged:\n\n\nINFO: Failed to parse val=twenty-one\n\n\nHowever, if an attacker submits the string \"twenty-one%0a%0aINFO:+User+logged+out%3dbadguy\", the following entry is logged:\n\n\nINFO: Failed to parse val=twenty-one\n\nINFO: User logged out=badguy\n\n\nClearly, attackers may use this same mechanism to insert arbitrary log entries.\n\nSome think that in the mobile world, classic web application vulnerabilities, such as log forging, do not make sense -- why would the user attack themself? However, keep in mind that the essence of mobile platforms is applications that are downloaded from various sources and run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which necessitates expanding the attack surface of mobile applications to include inter-process communication.\n\nExample 2: The following code adapts Example 1 to the Android platform.\n\n\n...\nString val = this.getIntent().getExtras().getString(\"val\");\ntry {\nint value = Integer.parseInt();\n}\ncatch (NumberFormatException nfe) {\nLog.e(TAG, \"Failed to parse val = \" + val);\n}\n...\n\n\nPrevent log forging attacks with indirection: create a set of legitimate log entries that correspond to different events that must be logged and only log entries from this set. To capture dynamic content, such as users logging out of the system, always use server-controlled values rather than user-supplied data. This ensures that the input provided by the user is never used directly in a log entry.\n\nExample 1 can be rewritten to use a pre-defined log entry that corresponds to a NumberFormatException as follows:\n\n\n...\npublic static final String NFE = \"Failed to parse val. The input is required to be an integer value.\"\n...\nString val = request.getParameter(\"val\");\ntry {\nint value = Integer.parseInt(val);\n}\ncatch (NumberFormatException nfe) {\nlog.info(NFE);\n}\n..\n\n\nAnd here is an Android equivalent:\n\n\n...\npublic static final String NFE = \"Failed to parse val. The input is required to be an integer value.\"\n...\nString val = this.getIntent().getExtras().getString(\"val\");\ntry {\nint value = Integer.parseInt();\n}\ncatch (NumberFormatException nfe) {\nLog.e(TAG, NFE);\n}\n...\n\n\nIn some situations this approach is impractical because the set of legitimate log entries is too large or complicated. In these situations, developers often fall back on implementing a deny list. A deny list is used to selectively reject or escape potentially dangerous characters before using the input. However, a list of unsafe characters can quickly become incomplete or outdated. A better approach is to create a list of characters that are permitted to appear in log entries and accept input composed exclusively of characters in the approved set. The most critical character in most log forging attacks is the '\n' (newline) character, which should never appear on a log entry allow list.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/3aa55336-c51a-4ad2-9ec6-846bbbf9e38f"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "25337209",
          "shortDescription" : {
            "text" : "Log Forging"
          },
          "fullDescription" : {
            "text" : "The method verifyUser() in UserController.java writes unvalidated user input to the log on line 485. An attacker could take advantage of this behavior to forge log entries or inject malicious content into the log.Writing unvalidated user input to log files can allow an attacker to forge log entries or inject malicious content into the logs."
          },
          "help" : {
            "text" : "Log forging vulnerabilities occur when:\n\n1. Data enters an application from an untrusted source.\n\nIn this case, the data enters at verifyUser() in UserController.java on line 446.\n\n2. The data is written to an application or system log file.\n\nIn this case, the data is logged by error() in UserController.java on line 485.\n\nApplications typically use log files to store a history of events or transactions for later review, statistics gathering, or debugging. Depending on the nature of the application, the task of reviewing log files may be performed manually on an as-needed basis or automated with a tool that automatically culls logs for important events or trending information.\n\nInterpretation of the log files may be hindered or misdirected if an attacker can supply data to the application that is subsequently logged verbatim. In the most benign case, an attacker may be able to insert false entries into the log file by providing the application with input that includes appropriate characters. If the log file is processed automatically, the attacker may be able to render the file unusable by corrupting the format of the file or injecting unexpected characters. A more subtle attack might involve skewing the log file statistics. Forged or otherwise, corrupted log files can be used to cover an attacker's tracks or even to implicate another party in the commission of a malicious act [1]. In the worst case, an attacker may inject code or other commands into the log file and take advantage of a vulnerability in the log processing utility [2].\n\nExample 1: The following web application code attempts to read an integer value from a request object. If the value fails to parse as an integer, then the input is logged with an error message indicating what happened.\n\n\n...\nString val = request.getParameter(\"val\");\ntry {\nint value = Integer.parseInt(val);\n}\ncatch (NumberFormatException nfe) {\nlog.info(\"Failed to parse val = \" + val);\n}\n...\n\n\nIf a user submits the string \"twenty-one\" for val, the following entry is logged:\n\n\nINFO: Failed to parse val=twenty-one\n\n\nHowever, if an attacker submits the string \"twenty-one%0a%0aINFO:+User+logged+out%3dbadguy\", the following entry is logged:\n\n\nINFO: Failed to parse val=twenty-one\n\nINFO: User logged out=badguy\n\n\nClearly, attackers may use this same mechanism to insert arbitrary log entries.\n\nSome think that in the mobile world, classic web application vulnerabilities, such as log forging, do not make sense -- why would the user attack themself? However, keep in mind that the essence of mobile platforms is applications that are downloaded from various sources and run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which necessitates expanding the attack surface of mobile applications to include inter-process communication.\n\nExample 2: The following code adapts Example 1 to the Android platform.\n\n\n...\nString val = this.getIntent().getExtras().getString(\"val\");\ntry {\nint value = Integer.parseInt();\n}\ncatch (NumberFormatException nfe) {\nLog.e(TAG, \"Failed to parse val = \" + val);\n}\n...\n\n\nPrevent log forging attacks with indirection: create a set of legitimate log entries that correspond to different events that must be logged and only log entries from this set. To capture dynamic content, such as users logging out of the system, always use server-controlled values rather than user-supplied data. This ensures that the input provided by the user is never used directly in a log entry.\n\nExample 1 can be rewritten to use a pre-defined log entry that corresponds to a NumberFormatException as follows:\n\n\n...\npublic static final String NFE = \"Failed to parse val. The input is required to be an integer value.\"\n...\nString val = request.getParameter(\"val\");\ntry {\nint value = Integer.parseInt(val);\n}\ncatch (NumberFormatException nfe) {\nlog.info(NFE);\n}\n..\n\n\nAnd here is an Android equivalent:\n\n\n...\npublic static final String NFE = \"Failed to parse val. The input is required to be an integer value.\"\n...\nString val = this.getIntent().getExtras().getString(\"val\");\ntry {\nint value = Integer.parseInt();\n}\ncatch (NumberFormatException nfe) {\nLog.e(TAG, NFE);\n}\n...\n\n\nIn some situations this approach is impractical because the set of legitimate log entries is too large or complicated. In these situations, developers often fall back on implementing a deny list. A deny list is used to selectively reject or escape potentially dangerous characters before using the input. However, a list of unsafe characters can quickly become incomplete or outdated. A better approach is to create a list of characters that are permitted to appear in log entries and accept input composed exclusively of characters in the approved set. The most critical character in most log forging attacks is the '\n' (newline) character, which should never appear on a log entry allow list.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/52b07e53-fcd4-4607-a11c-31e6d3e9429c"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "14220158",
          "shortDescription" : {
            "text" : "Mass Assignment: Insecure Binder Configuration"
          },
          "fullDescription" : {
            "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 193 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
          },
          "help" : {
            "text" : "To ease development and increase productivity, most modern frameworks allow an object to be automatically instantiated and populated with the HTTP request parameters whose names match an attribute of the class to be bound. Automatic instantiation and population of objects speeds up development, but can lead to serious problems if implemented without caution. Any attribute in the bound classes, or nested classes, will be automatically bound to the HTTP request parameters. Therefore, malicious users will be able to assign a value to any attribute in bound or nested classes, even if they are not exposed to the client through web forms or API contracts.\n\nExample 1: Using Spring MVC with no additional configuration, the following controller method will bind the HTTP request parameters to any attribute in the User or Details classes:\n\n\n@RequestMapping(method = RequestMethod.POST)\npublic String registerUser(@ModelAttribute(\"user\") User user, BindingResult result, SessionStatus status) {\nif (db.save(user).hasErrors()) {\nreturn \"CustomerForm\";\n} else {\nstatus.setComplete();\nreturn \"CustomerSuccess\";\n}\n}\n\n\nWhere User class is defined as:\n\n\npublic class User {\nprivate String name;\nprivate String lastname;\nprivate int age;\nprivate Details details;\n\n// Public Getters and Setters\n...\n}\n\n\nand Details class is defined as:\n\n\npublic class Details {\nprivate boolean is_admin;\nprivate int id;\nprivate Date login_date;\n\n// Public Getters and Setters\n...\n}\n\n\n\nWhen using frameworks that provide automatic model binding capabilities, it is a best practice to control which attributes will be bound to the model object so that even if attackers figure out other non-exposed attributes of the model or nested classes, they will not be able to bind arbitrary values from HTTP request parameters.\n\nDepending on the framework used there will be different ways to control the model binding process:\n\nSpring MVC: \n\nIt is possible to control which HTTP request parameters will be used in the binding process and which ones will be ignored.\n\nIn Spring MVC applications using @ModelAttribute annotated parameters, the binder can be configured to control which attributes should be bound. In order to do so, a method can be annotated with @InitBinder so that the framework will inject a reference to the Spring Model Binder. The Spring Model Binder can be configured to control the attribute binding process with the setAllowedFields and setDisallowedFields methods. Spring MVC applications extending BaseCommandController can override the initBinder(HttpServletRequest request, ServletRequestDataBinder binder) method in order to get a reference to the Spring Model Binder.\n\nExample 2: The Spring Model Binder (3.x) is configured to disallow the binding of sensitive attributes:\n\n\nfinal String[] DISALLOWED_FIELDS = new String[]{\"details.role\", \"details.age\", \"is_admin\"};\n\n@InitBinder\npublic void initBinder(WebDataBinder binder) {\nbinder.setDisallowedFields(DISALLOWED_FIELDS);\n}\n\n\nExample 3: The Spring Model Binder (2.x) is configured to disallow the binding of sensitive attributes:\n\n\n@Override\nprotected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {\nbinder.setDisallowedFields(new String[]{\"details.role\", \"details.age\", \"is_admin\"});\n}\n\n\nIn Spring MVC Applications using @RequestBody annotated parameters, the binding process is handled by HttpMessageConverter instances which will use libraries such as Jackson and JAXB to convert the HTTP request body into Java Objects. These libraries offer annotations to control which fields should be allowed or disallowed. For example, for the Jackson JSON library, the @JsonIgnore annotation can be used to prevent a field from being bound to the request.\n\nExample 4: A controller method binds an HTTP request to an instance of the Employee class using the @RequestBody annotation.\n\n\n@RequestMapping(value=\"/add/employee\", method=RequestMethod.POST, consumes=\"text/html\")\npublic void addEmployee(@RequestBody Employee employee){\n// Do something with the employee object.\n}\n\n\nThe application uses the default Jackson HttpMessageConverter to bind JSON HTTP requests to the Employee class. In order to prevent the binding of the is_admin sensitive field, use the @JsonIgnore annotation:\n\n\npublic class Employee {\n\n@JsonIgnore\nprivate boolean is_admin;\n...\n\n// Public Getters and Setters\n...\n}\n\n\nNote: Check the following REST frameworks information for more details on how to configure Jackson and JAXB annotations.\n\nApache Struts: \n\nStruts 1 and 2 will only bind HTTP request parameters to those Actions or ActionForms attributes which have an associated public setter accessor. If an attribute should not be bound to the request, its setter should be made private.\n\nExample 5: Configure a private setter so that Struts framework will not automatically bind any HTTP request parameter:\n\n\nprivate String role;\nprivate void setRole(String role)  {\nthis.role = role;\n}\n\n\nREST frameworks: \n\nMost REST frameworks will automatically bind any HTTP request bodies with content type JSON or XML to a model object. Depending on the libraries used for JSON and XML processing, there will be different ways of controlling the binding process. The following are some examples for JAXB (XML) and Jackson (JSON):\n\nExample 6: Models bound from XML documents using Oracle's JAXB library can control the binding process using different annotations such as @XmlAccessorType, @XmlAttribute, @XmlElement and @XmlTransient. The binder can be told not to bind any attributes by default, by annotating the models using the @XmlAccessorType annotation with the value XmlAccessType.NONE and then selecting which fields should be bound using @XmlAttribute and @XmlElement annotations:\n\n\n@XmlRootElement\n@XmlAccessorType(XmlAccessType.NONE)\npublic class User {\nprivate String role;\nprivate String name;\n@XmlAttribute\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nExample 7: Models bound from JSON documents using the Jackson library can control the binding process using different annotations such as @JsonIgnore, @JsonIgnoreProperties, @JsonIgnoreType and @JsonInclude. The binder can be told to ignore certain attributes by annotating them with @JsonIgnore annotation:\n\n\npublic class User {\n\n@JsonIgnore\nprivate String role;\nprivate String name;\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nA different approach to protecting against mass assignment vulnerabilities is using a layered architecture where the HTTP request parameters are bound to DTO objects. The DTO objects are only used for that purpose, exposing only those attributes defined in the web forms or API contracts, and then mapping these DTO objects to Domain Objects where the rest of the private attributes can be defined.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/1bce1b1d-a964-4f45-86fa-63a290974bd5"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "14220162",
          "shortDescription" : {
            "text" : "Mass Assignment: Insecure Binder Configuration"
          },
          "fullDescription" : {
            "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 212 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
          },
          "help" : {
            "text" : "To ease development and increase productivity, most modern frameworks allow an object to be automatically instantiated and populated with the HTTP request parameters whose names match an attribute of the class to be bound. Automatic instantiation and population of objects speeds up development, but can lead to serious problems if implemented without caution. Any attribute in the bound classes, or nested classes, will be automatically bound to the HTTP request parameters. Therefore, malicious users will be able to assign a value to any attribute in bound or nested classes, even if they are not exposed to the client through web forms or API contracts.\n\nExample 1: Using Spring MVC with no additional configuration, the following controller method will bind the HTTP request parameters to any attribute in the User or Details classes:\n\n\n@RequestMapping(method = RequestMethod.POST)\npublic String registerUser(@ModelAttribute(\"user\") User user, BindingResult result, SessionStatus status) {\nif (db.save(user).hasErrors()) {\nreturn \"CustomerForm\";\n} else {\nstatus.setComplete();\nreturn \"CustomerSuccess\";\n}\n}\n\n\nWhere User class is defined as:\n\n\npublic class User {\nprivate String name;\nprivate String lastname;\nprivate int age;\nprivate Details details;\n\n// Public Getters and Setters\n...\n}\n\n\nand Details class is defined as:\n\n\npublic class Details {\nprivate boolean is_admin;\nprivate int id;\nprivate Date login_date;\n\n// Public Getters and Setters\n...\n}\n\n\n\nWhen using frameworks that provide automatic model binding capabilities, it is a best practice to control which attributes will be bound to the model object so that even if attackers figure out other non-exposed attributes of the model or nested classes, they will not be able to bind arbitrary values from HTTP request parameters.\n\nDepending on the framework used there will be different ways to control the model binding process:\n\nSpring MVC: \n\nIt is possible to control which HTTP request parameters will be used in the binding process and which ones will be ignored.\n\nIn Spring MVC applications using @ModelAttribute annotated parameters, the binder can be configured to control which attributes should be bound. In order to do so, a method can be annotated with @InitBinder so that the framework will inject a reference to the Spring Model Binder. The Spring Model Binder can be configured to control the attribute binding process with the setAllowedFields and setDisallowedFields methods. Spring MVC applications extending BaseCommandController can override the initBinder(HttpServletRequest request, ServletRequestDataBinder binder) method in order to get a reference to the Spring Model Binder.\n\nExample 2: The Spring Model Binder (3.x) is configured to disallow the binding of sensitive attributes:\n\n\nfinal String[] DISALLOWED_FIELDS = new String[]{\"details.role\", \"details.age\", \"is_admin\"};\n\n@InitBinder\npublic void initBinder(WebDataBinder binder) {\nbinder.setDisallowedFields(DISALLOWED_FIELDS);\n}\n\n\nExample 3: The Spring Model Binder (2.x) is configured to disallow the binding of sensitive attributes:\n\n\n@Override\nprotected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {\nbinder.setDisallowedFields(new String[]{\"details.role\", \"details.age\", \"is_admin\"});\n}\n\n\nIn Spring MVC Applications using @RequestBody annotated parameters, the binding process is handled by HttpMessageConverter instances which will use libraries such as Jackson and JAXB to convert the HTTP request body into Java Objects. These libraries offer annotations to control which fields should be allowed or disallowed. For example, for the Jackson JSON library, the @JsonIgnore annotation can be used to prevent a field from being bound to the request.\n\nExample 4: A controller method binds an HTTP request to an instance of the Employee class using the @RequestBody annotation.\n\n\n@RequestMapping(value=\"/add/employee\", method=RequestMethod.POST, consumes=\"text/html\")\npublic void addEmployee(@RequestBody Employee employee){\n// Do something with the employee object.\n}\n\n\nThe application uses the default Jackson HttpMessageConverter to bind JSON HTTP requests to the Employee class. In order to prevent the binding of the is_admin sensitive field, use the @JsonIgnore annotation:\n\n\npublic class Employee {\n\n@JsonIgnore\nprivate boolean is_admin;\n...\n\n// Public Getters and Setters\n...\n}\n\n\nNote: Check the following REST frameworks information for more details on how to configure Jackson and JAXB annotations.\n\nApache Struts: \n\nStruts 1 and 2 will only bind HTTP request parameters to those Actions or ActionForms attributes which have an associated public setter accessor. If an attribute should not be bound to the request, its setter should be made private.\n\nExample 5: Configure a private setter so that Struts framework will not automatically bind any HTTP request parameter:\n\n\nprivate String role;\nprivate void setRole(String role)  {\nthis.role = role;\n}\n\n\nREST frameworks: \n\nMost REST frameworks will automatically bind any HTTP request bodies with content type JSON or XML to a model object. Depending on the libraries used for JSON and XML processing, there will be different ways of controlling the binding process. The following are some examples for JAXB (XML) and Jackson (JSON):\n\nExample 6: Models bound from XML documents using Oracle's JAXB library can control the binding process using different annotations such as @XmlAccessorType, @XmlAttribute, @XmlElement and @XmlTransient. The binder can be told not to bind any attributes by default, by annotating the models using the @XmlAccessorType annotation with the value XmlAccessType.NONE and then selecting which fields should be bound using @XmlAttribute and @XmlElement annotations:\n\n\n@XmlRootElement\n@XmlAccessorType(XmlAccessType.NONE)\npublic class User {\nprivate String role;\nprivate String name;\n@XmlAttribute\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nExample 7: Models bound from JSON documents using the Jackson library can control the binding process using different annotations such as @JsonIgnore, @JsonIgnoreProperties, @JsonIgnoreType and @JsonInclude. The binder can be told to ignore certain attributes by annotating them with @JsonIgnore annotation:\n\n\npublic class User {\n\n@JsonIgnore\nprivate String role;\nprivate String name;\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nA different approach to protecting against mass assignment vulnerabilities is using a layered architecture where the HTTP request parameters are bound to DTO objects. The DTO objects are only used for that purpose, exposing only those attributes defined in the web forms or API contracts, and then mapping these DTO objects to Domain Objects where the rest of the private attributes can be defined.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/5330c289-7bb9-4ea1-8b42-21e76ccd46b4"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "11445516",
          "shortDescription" : {
            "text" : "Mass Assignment: Insecure Binder Configuration"
          },
          "fullDescription" : {
            "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 349 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
          },
          "help" : {
            "text" : "To ease development and increase productivity, most modern frameworks allow an object to be automatically instantiated and populated with the HTTP request parameters whose names match an attribute of the class to be bound. Automatic instantiation and population of objects speeds up development, but can lead to serious problems if implemented without caution. Any attribute in the bound classes, or nested classes, will be automatically bound to the HTTP request parameters. Therefore, malicious users will be able to assign a value to any attribute in bound or nested classes, even if they are not exposed to the client through web forms or API contracts.\n\nExample 1: Using Spring MVC with no additional configuration, the following controller method will bind the HTTP request parameters to any attribute in the User or Details classes:\n\n\n@RequestMapping(method = RequestMethod.POST)\npublic String registerUser(@ModelAttribute(\"user\") User user, BindingResult result, SessionStatus status) {\nif (db.save(user).hasErrors()) {\nreturn \"CustomerForm\";\n} else {\nstatus.setComplete();\nreturn \"CustomerSuccess\";\n}\n}\n\n\nWhere User class is defined as:\n\n\npublic class User {\nprivate String name;\nprivate String lastname;\nprivate int age;\nprivate Details details;\n\n// Public Getters and Setters\n...\n}\n\n\nand Details class is defined as:\n\n\npublic class Details {\nprivate boolean is_admin;\nprivate int id;\nprivate Date login_date;\n\n// Public Getters and Setters\n...\n}\n\n\n\nWhen using frameworks that provide automatic model binding capabilities, it is a best practice to control which attributes will be bound to the model object so that even if attackers figure out other non-exposed attributes of the model or nested classes, they will not be able to bind arbitrary values from HTTP request parameters.\n\nDepending on the framework used there will be different ways to control the model binding process:\n\nSpring MVC: \n\nIt is possible to control which HTTP request parameters will be used in the binding process and which ones will be ignored.\n\nIn Spring MVC applications using @ModelAttribute annotated parameters, the binder can be configured to control which attributes should be bound. In order to do so, a method can be annotated with @InitBinder so that the framework will inject a reference to the Spring Model Binder. The Spring Model Binder can be configured to control the attribute binding process with the setAllowedFields and setDisallowedFields methods. Spring MVC applications extending BaseCommandController can override the initBinder(HttpServletRequest request, ServletRequestDataBinder binder) method in order to get a reference to the Spring Model Binder.\n\nExample 2: The Spring Model Binder (3.x) is configured to disallow the binding of sensitive attributes:\n\n\nfinal String[] DISALLOWED_FIELDS = new String[]{\"details.role\", \"details.age\", \"is_admin\"};\n\n@InitBinder\npublic void initBinder(WebDataBinder binder) {\nbinder.setDisallowedFields(DISALLOWED_FIELDS);\n}\n\n\nExample 3: The Spring Model Binder (2.x) is configured to disallow the binding of sensitive attributes:\n\n\n@Override\nprotected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {\nbinder.setDisallowedFields(new String[]{\"details.role\", \"details.age\", \"is_admin\"});\n}\n\n\nIn Spring MVC Applications using @RequestBody annotated parameters, the binding process is handled by HttpMessageConverter instances which will use libraries such as Jackson and JAXB to convert the HTTP request body into Java Objects. These libraries offer annotations to control which fields should be allowed or disallowed. For example, for the Jackson JSON library, the @JsonIgnore annotation can be used to prevent a field from being bound to the request.\n\nExample 4: A controller method binds an HTTP request to an instance of the Employee class using the @RequestBody annotation.\n\n\n@RequestMapping(value=\"/add/employee\", method=RequestMethod.POST, consumes=\"text/html\")\npublic void addEmployee(@RequestBody Employee employee){\n// Do something with the employee object.\n}\n\n\nThe application uses the default Jackson HttpMessageConverter to bind JSON HTTP requests to the Employee class. In order to prevent the binding of the is_admin sensitive field, use the @JsonIgnore annotation:\n\n\npublic class Employee {\n\n@JsonIgnore\nprivate boolean is_admin;\n...\n\n// Public Getters and Setters\n...\n}\n\n\nNote: Check the following REST frameworks information for more details on how to configure Jackson and JAXB annotations.\n\nApache Struts: \n\nStruts 1 and 2 will only bind HTTP request parameters to those Actions or ActionForms attributes which have an associated public setter accessor. If an attribute should not be bound to the request, its setter should be made private.\n\nExample 5: Configure a private setter so that Struts framework will not automatically bind any HTTP request parameter:\n\n\nprivate String role;\nprivate void setRole(String role)  {\nthis.role = role;\n}\n\n\nREST frameworks: \n\nMost REST frameworks will automatically bind any HTTP request bodies with content type JSON or XML to a model object. Depending on the libraries used for JSON and XML processing, there will be different ways of controlling the binding process. The following are some examples for JAXB (XML) and Jackson (JSON):\n\nExample 6: Models bound from XML documents using Oracle's JAXB library can control the binding process using different annotations such as @XmlAccessorType, @XmlAttribute, @XmlElement and @XmlTransient. The binder can be told not to bind any attributes by default, by annotating the models using the @XmlAccessorType annotation with the value XmlAccessType.NONE and then selecting which fields should be bound using @XmlAttribute and @XmlElement annotations:\n\n\n@XmlRootElement\n@XmlAccessorType(XmlAccessType.NONE)\npublic class User {\nprivate String role;\nprivate String name;\n@XmlAttribute\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nExample 7: Models bound from JSON documents using the Jackson library can control the binding process using different annotations such as @JsonIgnore, @JsonIgnoreProperties, @JsonIgnoreType and @JsonInclude. The binder can be told to ignore certain attributes by annotating them with @JsonIgnore annotation:\n\n\npublic class User {\n\n@JsonIgnore\nprivate String role;\nprivate String name;\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nA different approach to protecting against mass assignment vulnerabilities is using a layered architecture where the HTTP request parameters are bound to DTO objects. The DTO objects are only used for that purpose, exposing only those attributes defined in the web forms or API contracts, and then mapping these DTO objects to Domain Objects where the rest of the private attributes can be defined.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/9aa5740c-1f56-46a9-a535-a7f58e309cb9"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "11445517",
          "shortDescription" : {
            "text" : "Mass Assignment: Insecure Binder Configuration"
          },
          "fullDescription" : {
            "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 107 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
          },
          "help" : {
            "text" : "To ease development and increase productivity, most modern frameworks allow an object to be automatically instantiated and populated with the HTTP request parameters whose names match an attribute of the class to be bound. Automatic instantiation and population of objects speeds up development, but can lead to serious problems if implemented without caution. Any attribute in the bound classes, or nested classes, will be automatically bound to the HTTP request parameters. Therefore, malicious users will be able to assign a value to any attribute in bound or nested classes, even if they are not exposed to the client through web forms or API contracts.\n\nExample 1: Using Spring MVC with no additional configuration, the following controller method will bind the HTTP request parameters to any attribute in the User or Details classes:\n\n\n@RequestMapping(method = RequestMethod.POST)\npublic String registerUser(@ModelAttribute(\"user\") User user, BindingResult result, SessionStatus status) {\nif (db.save(user).hasErrors()) {\nreturn \"CustomerForm\";\n} else {\nstatus.setComplete();\nreturn \"CustomerSuccess\";\n}\n}\n\n\nWhere User class is defined as:\n\n\npublic class User {\nprivate String name;\nprivate String lastname;\nprivate int age;\nprivate Details details;\n\n// Public Getters and Setters\n...\n}\n\n\nand Details class is defined as:\n\n\npublic class Details {\nprivate boolean is_admin;\nprivate int id;\nprivate Date login_date;\n\n// Public Getters and Setters\n...\n}\n\n\n\nWhen using frameworks that provide automatic model binding capabilities, it is a best practice to control which attributes will be bound to the model object so that even if attackers figure out other non-exposed attributes of the model or nested classes, they will not be able to bind arbitrary values from HTTP request parameters.\n\nDepending on the framework used there will be different ways to control the model binding process:\n\nSpring MVC: \n\nIt is possible to control which HTTP request parameters will be used in the binding process and which ones will be ignored.\n\nIn Spring MVC applications using @ModelAttribute annotated parameters, the binder can be configured to control which attributes should be bound. In order to do so, a method can be annotated with @InitBinder so that the framework will inject a reference to the Spring Model Binder. The Spring Model Binder can be configured to control the attribute binding process with the setAllowedFields and setDisallowedFields methods. Spring MVC applications extending BaseCommandController can override the initBinder(HttpServletRequest request, ServletRequestDataBinder binder) method in order to get a reference to the Spring Model Binder.\n\nExample 2: The Spring Model Binder (3.x) is configured to disallow the binding of sensitive attributes:\n\n\nfinal String[] DISALLOWED_FIELDS = new String[]{\"details.role\", \"details.age\", \"is_admin\"};\n\n@InitBinder\npublic void initBinder(WebDataBinder binder) {\nbinder.setDisallowedFields(DISALLOWED_FIELDS);\n}\n\n\nExample 3: The Spring Model Binder (2.x) is configured to disallow the binding of sensitive attributes:\n\n\n@Override\nprotected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {\nbinder.setDisallowedFields(new String[]{\"details.role\", \"details.age\", \"is_admin\"});\n}\n\n\nIn Spring MVC Applications using @RequestBody annotated parameters, the binding process is handled by HttpMessageConverter instances which will use libraries such as Jackson and JAXB to convert the HTTP request body into Java Objects. These libraries offer annotations to control which fields should be allowed or disallowed. For example, for the Jackson JSON library, the @JsonIgnore annotation can be used to prevent a field from being bound to the request.\n\nExample 4: A controller method binds an HTTP request to an instance of the Employee class using the @RequestBody annotation.\n\n\n@RequestMapping(value=\"/add/employee\", method=RequestMethod.POST, consumes=\"text/html\")\npublic void addEmployee(@RequestBody Employee employee){\n// Do something with the employee object.\n}\n\n\nThe application uses the default Jackson HttpMessageConverter to bind JSON HTTP requests to the Employee class. In order to prevent the binding of the is_admin sensitive field, use the @JsonIgnore annotation:\n\n\npublic class Employee {\n\n@JsonIgnore\nprivate boolean is_admin;\n...\n\n// Public Getters and Setters\n...\n}\n\n\nNote: Check the following REST frameworks information for more details on how to configure Jackson and JAXB annotations.\n\nApache Struts: \n\nStruts 1 and 2 will only bind HTTP request parameters to those Actions or ActionForms attributes which have an associated public setter accessor. If an attribute should not be bound to the request, its setter should be made private.\n\nExample 5: Configure a private setter so that Struts framework will not automatically bind any HTTP request parameter:\n\n\nprivate String role;\nprivate void setRole(String role)  {\nthis.role = role;\n}\n\n\nREST frameworks: \n\nMost REST frameworks will automatically bind any HTTP request bodies with content type JSON or XML to a model object. Depending on the libraries used for JSON and XML processing, there will be different ways of controlling the binding process. The following are some examples for JAXB (XML) and Jackson (JSON):\n\nExample 6: Models bound from XML documents using Oracle's JAXB library can control the binding process using different annotations such as @XmlAccessorType, @XmlAttribute, @XmlElement and @XmlTransient. The binder can be told not to bind any attributes by default, by annotating the models using the @XmlAccessorType annotation with the value XmlAccessType.NONE and then selecting which fields should be bound using @XmlAttribute and @XmlElement annotations:\n\n\n@XmlRootElement\n@XmlAccessorType(XmlAccessType.NONE)\npublic class User {\nprivate String role;\nprivate String name;\n@XmlAttribute\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nExample 7: Models bound from JSON documents using the Jackson library can control the binding process using different annotations such as @JsonIgnore, @JsonIgnoreProperties, @JsonIgnoreType and @JsonInclude. The binder can be told to ignore certain attributes by annotating them with @JsonIgnore annotation:\n\n\npublic class User {\n\n@JsonIgnore\nprivate String role;\nprivate String name;\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nA different approach to protecting against mass assignment vulnerabilities is using a layered architecture where the HTTP request parameters are bound to DTO objects. The DTO objects are only used for that purpose, exposing only those attributes defined in the web forms or API contracts, and then mapping these DTO objects to Domain Objects where the rest of the private attributes can be defined.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/275ecb32-7bfe-4fed-950f-a2d94b8b0231"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "13078268",
          "shortDescription" : {
            "text" : "Mass Assignment: Insecure Binder Configuration"
          },
          "fullDescription" : {
            "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 137 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
          },
          "help" : {
            "text" : "To ease development and increase productivity, most modern frameworks allow an object to be automatically instantiated and populated with the HTTP request parameters whose names match an attribute of the class to be bound. Automatic instantiation and population of objects speeds up development, but can lead to serious problems if implemented without caution. Any attribute in the bound classes, or nested classes, will be automatically bound to the HTTP request parameters. Therefore, malicious users will be able to assign a value to any attribute in bound or nested classes, even if they are not exposed to the client through web forms or API contracts.\n\nExample 1: Using Spring MVC with no additional configuration, the following controller method will bind the HTTP request parameters to any attribute in the User or Details classes:\n\n\n@RequestMapping(method = RequestMethod.POST)\npublic String registerUser(@ModelAttribute(\"user\") User user, BindingResult result, SessionStatus status) {\nif (db.save(user).hasErrors()) {\nreturn \"CustomerForm\";\n} else {\nstatus.setComplete();\nreturn \"CustomerSuccess\";\n}\n}\n\n\nWhere User class is defined as:\n\n\npublic class User {\nprivate String name;\nprivate String lastname;\nprivate int age;\nprivate Details details;\n\n// Public Getters and Setters\n...\n}\n\n\nand Details class is defined as:\n\n\npublic class Details {\nprivate boolean is_admin;\nprivate int id;\nprivate Date login_date;\n\n// Public Getters and Setters\n...\n}\n\n\n\nWhen using frameworks that provide automatic model binding capabilities, it is a best practice to control which attributes will be bound to the model object so that even if attackers figure out other non-exposed attributes of the model or nested classes, they will not be able to bind arbitrary values from HTTP request parameters.\n\nDepending on the framework used there will be different ways to control the model binding process:\n\nSpring MVC: \n\nIt is possible to control which HTTP request parameters will be used in the binding process and which ones will be ignored.\n\nIn Spring MVC applications using @ModelAttribute annotated parameters, the binder can be configured to control which attributes should be bound. In order to do so, a method can be annotated with @InitBinder so that the framework will inject a reference to the Spring Model Binder. The Spring Model Binder can be configured to control the attribute binding process with the setAllowedFields and setDisallowedFields methods. Spring MVC applications extending BaseCommandController can override the initBinder(HttpServletRequest request, ServletRequestDataBinder binder) method in order to get a reference to the Spring Model Binder.\n\nExample 2: The Spring Model Binder (3.x) is configured to disallow the binding of sensitive attributes:\n\n\nfinal String[] DISALLOWED_FIELDS = new String[]{\"details.role\", \"details.age\", \"is_admin\"};\n\n@InitBinder\npublic void initBinder(WebDataBinder binder) {\nbinder.setDisallowedFields(DISALLOWED_FIELDS);\n}\n\n\nExample 3: The Spring Model Binder (2.x) is configured to disallow the binding of sensitive attributes:\n\n\n@Override\nprotected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {\nbinder.setDisallowedFields(new String[]{\"details.role\", \"details.age\", \"is_admin\"});\n}\n\n\nIn Spring MVC Applications using @RequestBody annotated parameters, the binding process is handled by HttpMessageConverter instances which will use libraries such as Jackson and JAXB to convert the HTTP request body into Java Objects. These libraries offer annotations to control which fields should be allowed or disallowed. For example, for the Jackson JSON library, the @JsonIgnore annotation can be used to prevent a field from being bound to the request.\n\nExample 4: A controller method binds an HTTP request to an instance of the Employee class using the @RequestBody annotation.\n\n\n@RequestMapping(value=\"/add/employee\", method=RequestMethod.POST, consumes=\"text/html\")\npublic void addEmployee(@RequestBody Employee employee){\n// Do something with the employee object.\n}\n\n\nThe application uses the default Jackson HttpMessageConverter to bind JSON HTTP requests to the Employee class. In order to prevent the binding of the is_admin sensitive field, use the @JsonIgnore annotation:\n\n\npublic class Employee {\n\n@JsonIgnore\nprivate boolean is_admin;\n...\n\n// Public Getters and Setters\n...\n}\n\n\nNote: Check the following REST frameworks information for more details on how to configure Jackson and JAXB annotations.\n\nApache Struts: \n\nStruts 1 and 2 will only bind HTTP request parameters to those Actions or ActionForms attributes which have an associated public setter accessor. If an attribute should not be bound to the request, its setter should be made private.\n\nExample 5: Configure a private setter so that Struts framework will not automatically bind any HTTP request parameter:\n\n\nprivate String role;\nprivate void setRole(String role)  {\nthis.role = role;\n}\n\n\nREST frameworks: \n\nMost REST frameworks will automatically bind any HTTP request bodies with content type JSON or XML to a model object. Depending on the libraries used for JSON and XML processing, there will be different ways of controlling the binding process. The following are some examples for JAXB (XML) and Jackson (JSON):\n\nExample 6: Models bound from XML documents using Oracle's JAXB library can control the binding process using different annotations such as @XmlAccessorType, @XmlAttribute, @XmlElement and @XmlTransient. The binder can be told not to bind any attributes by default, by annotating the models using the @XmlAccessorType annotation with the value XmlAccessType.NONE and then selecting which fields should be bound using @XmlAttribute and @XmlElement annotations:\n\n\n@XmlRootElement\n@XmlAccessorType(XmlAccessType.NONE)\npublic class User {\nprivate String role;\nprivate String name;\n@XmlAttribute\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nExample 7: Models bound from JSON documents using the Jackson library can control the binding process using different annotations such as @JsonIgnore, @JsonIgnoreProperties, @JsonIgnoreType and @JsonInclude. The binder can be told to ignore certain attributes by annotating them with @JsonIgnore annotation:\n\n\npublic class User {\n\n@JsonIgnore\nprivate String role;\nprivate String name;\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nA different approach to protecting against mass assignment vulnerabilities is using a layered architecture where the HTTP request parameters are bound to DTO objects. The DTO objects are only used for that purpose, exposing only those attributes defined in the web forms or API contracts, and then mapping these DTO objects to Domain Objects where the rest of the private attributes can be defined.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/5dea0333-ff26-4ce5-a0a4-4b0c451dfc09"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "11445521",
          "shortDescription" : {
            "text" : "Mass Assignment: Insecure Binder Configuration"
          },
          "fullDescription" : {
            "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 131 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
          },
          "help" : {
            "text" : "To ease development and increase productivity, most modern frameworks allow an object to be automatically instantiated and populated with the HTTP request parameters whose names match an attribute of the class to be bound. Automatic instantiation and population of objects speeds up development, but can lead to serious problems if implemented without caution. Any attribute in the bound classes, or nested classes, will be automatically bound to the HTTP request parameters. Therefore, malicious users will be able to assign a value to any attribute in bound or nested classes, even if they are not exposed to the client through web forms or API contracts.\n\nExample 1: Using Spring MVC with no additional configuration, the following controller method will bind the HTTP request parameters to any attribute in the User or Details classes:\n\n\n@RequestMapping(method = RequestMethod.POST)\npublic String registerUser(@ModelAttribute(\"user\") User user, BindingResult result, SessionStatus status) {\nif (db.save(user).hasErrors()) {\nreturn \"CustomerForm\";\n} else {\nstatus.setComplete();\nreturn \"CustomerSuccess\";\n}\n}\n\n\nWhere User class is defined as:\n\n\npublic class User {\nprivate String name;\nprivate String lastname;\nprivate int age;\nprivate Details details;\n\n// Public Getters and Setters\n...\n}\n\n\nand Details class is defined as:\n\n\npublic class Details {\nprivate boolean is_admin;\nprivate int id;\nprivate Date login_date;\n\n// Public Getters and Setters\n...\n}\n\n\n\nWhen using frameworks that provide automatic model binding capabilities, it is a best practice to control which attributes will be bound to the model object so that even if attackers figure out other non-exposed attributes of the model or nested classes, they will not be able to bind arbitrary values from HTTP request parameters.\n\nDepending on the framework used there will be different ways to control the model binding process:\n\nSpring MVC: \n\nIt is possible to control which HTTP request parameters will be used in the binding process and which ones will be ignored.\n\nIn Spring MVC applications using @ModelAttribute annotated parameters, the binder can be configured to control which attributes should be bound. In order to do so, a method can be annotated with @InitBinder so that the framework will inject a reference to the Spring Model Binder. The Spring Model Binder can be configured to control the attribute binding process with the setAllowedFields and setDisallowedFields methods. Spring MVC applications extending BaseCommandController can override the initBinder(HttpServletRequest request, ServletRequestDataBinder binder) method in order to get a reference to the Spring Model Binder.\n\nExample 2: The Spring Model Binder (3.x) is configured to disallow the binding of sensitive attributes:\n\n\nfinal String[] DISALLOWED_FIELDS = new String[]{\"details.role\", \"details.age\", \"is_admin\"};\n\n@InitBinder\npublic void initBinder(WebDataBinder binder) {\nbinder.setDisallowedFields(DISALLOWED_FIELDS);\n}\n\n\nExample 3: The Spring Model Binder (2.x) is configured to disallow the binding of sensitive attributes:\n\n\n@Override\nprotected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {\nbinder.setDisallowedFields(new String[]{\"details.role\", \"details.age\", \"is_admin\"});\n}\n\n\nIn Spring MVC Applications using @RequestBody annotated parameters, the binding process is handled by HttpMessageConverter instances which will use libraries such as Jackson and JAXB to convert the HTTP request body into Java Objects. These libraries offer annotations to control which fields should be allowed or disallowed. For example, for the Jackson JSON library, the @JsonIgnore annotation can be used to prevent a field from being bound to the request.\n\nExample 4: A controller method binds an HTTP request to an instance of the Employee class using the @RequestBody annotation.\n\n\n@RequestMapping(value=\"/add/employee\", method=RequestMethod.POST, consumes=\"text/html\")\npublic void addEmployee(@RequestBody Employee employee){\n// Do something with the employee object.\n}\n\n\nThe application uses the default Jackson HttpMessageConverter to bind JSON HTTP requests to the Employee class. In order to prevent the binding of the is_admin sensitive field, use the @JsonIgnore annotation:\n\n\npublic class Employee {\n\n@JsonIgnore\nprivate boolean is_admin;\n...\n\n// Public Getters and Setters\n...\n}\n\n\nNote: Check the following REST frameworks information for more details on how to configure Jackson and JAXB annotations.\n\nApache Struts: \n\nStruts 1 and 2 will only bind HTTP request parameters to those Actions or ActionForms attributes which have an associated public setter accessor. If an attribute should not be bound to the request, its setter should be made private.\n\nExample 5: Configure a private setter so that Struts framework will not automatically bind any HTTP request parameter:\n\n\nprivate String role;\nprivate void setRole(String role)  {\nthis.role = role;\n}\n\n\nREST frameworks: \n\nMost REST frameworks will automatically bind any HTTP request bodies with content type JSON or XML to a model object. Depending on the libraries used for JSON and XML processing, there will be different ways of controlling the binding process. The following are some examples for JAXB (XML) and Jackson (JSON):\n\nExample 6: Models bound from XML documents using Oracle's JAXB library can control the binding process using different annotations such as @XmlAccessorType, @XmlAttribute, @XmlElement and @XmlTransient. The binder can be told not to bind any attributes by default, by annotating the models using the @XmlAccessorType annotation with the value XmlAccessType.NONE and then selecting which fields should be bound using @XmlAttribute and @XmlElement annotations:\n\n\n@XmlRootElement\n@XmlAccessorType(XmlAccessType.NONE)\npublic class User {\nprivate String role;\nprivate String name;\n@XmlAttribute\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nExample 7: Models bound from JSON documents using the Jackson library can control the binding process using different annotations such as @JsonIgnore, @JsonIgnoreProperties, @JsonIgnoreType and @JsonInclude. The binder can be told to ignore certain attributes by annotating them with @JsonIgnore annotation:\n\n\npublic class User {\n\n@JsonIgnore\nprivate String role;\nprivate String name;\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nA different approach to protecting against mass assignment vulnerabilities is using a layered architecture where the HTTP request parameters are bound to DTO objects. The DTO objects are only used for that purpose, exposing only those attributes defined in the web forms or API contracts, and then mapping these DTO objects to Domain Objects where the rest of the private attributes can be defined.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/8f9373fe-a72b-4282-920c-f5f5af76b0c3"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "11445524",
          "shortDescription" : {
            "text" : "Mass Assignment: Insecure Binder Configuration"
          },
          "fullDescription" : {
            "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 320 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
          },
          "help" : {
            "text" : "To ease development and increase productivity, most modern frameworks allow an object to be automatically instantiated and populated with the HTTP request parameters whose names match an attribute of the class to be bound. Automatic instantiation and population of objects speeds up development, but can lead to serious problems if implemented without caution. Any attribute in the bound classes, or nested classes, will be automatically bound to the HTTP request parameters. Therefore, malicious users will be able to assign a value to any attribute in bound or nested classes, even if they are not exposed to the client through web forms or API contracts.\n\nExample 1: Using Spring MVC with no additional configuration, the following controller method will bind the HTTP request parameters to any attribute in the User or Details classes:\n\n\n@RequestMapping(method = RequestMethod.POST)\npublic String registerUser(@ModelAttribute(\"user\") User user, BindingResult result, SessionStatus status) {\nif (db.save(user).hasErrors()) {\nreturn \"CustomerForm\";\n} else {\nstatus.setComplete();\nreturn \"CustomerSuccess\";\n}\n}\n\n\nWhere User class is defined as:\n\n\npublic class User {\nprivate String name;\nprivate String lastname;\nprivate int age;\nprivate Details details;\n\n// Public Getters and Setters\n...\n}\n\n\nand Details class is defined as:\n\n\npublic class Details {\nprivate boolean is_admin;\nprivate int id;\nprivate Date login_date;\n\n// Public Getters and Setters\n...\n}\n\n\n\nWhen using frameworks that provide automatic model binding capabilities, it is a best practice to control which attributes will be bound to the model object so that even if attackers figure out other non-exposed attributes of the model or nested classes, they will not be able to bind arbitrary values from HTTP request parameters.\n\nDepending on the framework used there will be different ways to control the model binding process:\n\nSpring MVC: \n\nIt is possible to control which HTTP request parameters will be used in the binding process and which ones will be ignored.\n\nIn Spring MVC applications using @ModelAttribute annotated parameters, the binder can be configured to control which attributes should be bound. In order to do so, a method can be annotated with @InitBinder so that the framework will inject a reference to the Spring Model Binder. The Spring Model Binder can be configured to control the attribute binding process with the setAllowedFields and setDisallowedFields methods. Spring MVC applications extending BaseCommandController can override the initBinder(HttpServletRequest request, ServletRequestDataBinder binder) method in order to get a reference to the Spring Model Binder.\n\nExample 2: The Spring Model Binder (3.x) is configured to disallow the binding of sensitive attributes:\n\n\nfinal String[] DISALLOWED_FIELDS = new String[]{\"details.role\", \"details.age\", \"is_admin\"};\n\n@InitBinder\npublic void initBinder(WebDataBinder binder) {\nbinder.setDisallowedFields(DISALLOWED_FIELDS);\n}\n\n\nExample 3: The Spring Model Binder (2.x) is configured to disallow the binding of sensitive attributes:\n\n\n@Override\nprotected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {\nbinder.setDisallowedFields(new String[]{\"details.role\", \"details.age\", \"is_admin\"});\n}\n\n\nIn Spring MVC Applications using @RequestBody annotated parameters, the binding process is handled by HttpMessageConverter instances which will use libraries such as Jackson and JAXB to convert the HTTP request body into Java Objects. These libraries offer annotations to control which fields should be allowed or disallowed. For example, for the Jackson JSON library, the @JsonIgnore annotation can be used to prevent a field from being bound to the request.\n\nExample 4: A controller method binds an HTTP request to an instance of the Employee class using the @RequestBody annotation.\n\n\n@RequestMapping(value=\"/add/employee\", method=RequestMethod.POST, consumes=\"text/html\")\npublic void addEmployee(@RequestBody Employee employee){\n// Do something with the employee object.\n}\n\n\nThe application uses the default Jackson HttpMessageConverter to bind JSON HTTP requests to the Employee class. In order to prevent the binding of the is_admin sensitive field, use the @JsonIgnore annotation:\n\n\npublic class Employee {\n\n@JsonIgnore\nprivate boolean is_admin;\n...\n\n// Public Getters and Setters\n...\n}\n\n\nNote: Check the following REST frameworks information for more details on how to configure Jackson and JAXB annotations.\n\nApache Struts: \n\nStruts 1 and 2 will only bind HTTP request parameters to those Actions or ActionForms attributes which have an associated public setter accessor. If an attribute should not be bound to the request, its setter should be made private.\n\nExample 5: Configure a private setter so that Struts framework will not automatically bind any HTTP request parameter:\n\n\nprivate String role;\nprivate void setRole(String role)  {\nthis.role = role;\n}\n\n\nREST frameworks: \n\nMost REST frameworks will automatically bind any HTTP request bodies with content type JSON or XML to a model object. Depending on the libraries used for JSON and XML processing, there will be different ways of controlling the binding process. The following are some examples for JAXB (XML) and Jackson (JSON):\n\nExample 6: Models bound from XML documents using Oracle's JAXB library can control the binding process using different annotations such as @XmlAccessorType, @XmlAttribute, @XmlElement and @XmlTransient. The binder can be told not to bind any attributes by default, by annotating the models using the @XmlAccessorType annotation with the value XmlAccessType.NONE and then selecting which fields should be bound using @XmlAttribute and @XmlElement annotations:\n\n\n@XmlRootElement\n@XmlAccessorType(XmlAccessType.NONE)\npublic class User {\nprivate String role;\nprivate String name;\n@XmlAttribute\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nExample 7: Models bound from JSON documents using the Jackson library can control the binding process using different annotations such as @JsonIgnore, @JsonIgnoreProperties, @JsonIgnoreType and @JsonInclude. The binder can be told to ignore certain attributes by annotating them with @JsonIgnore annotation:\n\n\npublic class User {\n\n@JsonIgnore\nprivate String role;\nprivate String name;\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nA different approach to protecting against mass assignment vulnerabilities is using a layered architecture where the HTTP request parameters are bound to DTO objects. The DTO objects are only used for that purpose, exposing only those attributes defined in the web forms or API contracts, and then mapping these DTO objects to Domain Objects where the rest of the private attributes can be defined.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/0552e313-b36d-497f-8d45-c986ba6b715c"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "11445525",
          "shortDescription" : {
            "text" : "Mass Assignment: Insecure Binder Configuration"
          },
          "fullDescription" : {
            "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 114 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
          },
          "help" : {
            "text" : "To ease development and increase productivity, most modern frameworks allow an object to be automatically instantiated and populated with the HTTP request parameters whose names match an attribute of the class to be bound. Automatic instantiation and population of objects speeds up development, but can lead to serious problems if implemented without caution. Any attribute in the bound classes, or nested classes, will be automatically bound to the HTTP request parameters. Therefore, malicious users will be able to assign a value to any attribute in bound or nested classes, even if they are not exposed to the client through web forms or API contracts.\n\nExample 1: Using Spring MVC with no additional configuration, the following controller method will bind the HTTP request parameters to any attribute in the User or Details classes:\n\n\n@RequestMapping(method = RequestMethod.POST)\npublic String registerUser(@ModelAttribute(\"user\") User user, BindingResult result, SessionStatus status) {\nif (db.save(user).hasErrors()) {\nreturn \"CustomerForm\";\n} else {\nstatus.setComplete();\nreturn \"CustomerSuccess\";\n}\n}\n\n\nWhere User class is defined as:\n\n\npublic class User {\nprivate String name;\nprivate String lastname;\nprivate int age;\nprivate Details details;\n\n// Public Getters and Setters\n...\n}\n\n\nand Details class is defined as:\n\n\npublic class Details {\nprivate boolean is_admin;\nprivate int id;\nprivate Date login_date;\n\n// Public Getters and Setters\n...\n}\n\n\n\nWhen using frameworks that provide automatic model binding capabilities, it is a best practice to control which attributes will be bound to the model object so that even if attackers figure out other non-exposed attributes of the model or nested classes, they will not be able to bind arbitrary values from HTTP request parameters.\n\nDepending on the framework used there will be different ways to control the model binding process:\n\nSpring MVC: \n\nIt is possible to control which HTTP request parameters will be used in the binding process and which ones will be ignored.\n\nIn Spring MVC applications using @ModelAttribute annotated parameters, the binder can be configured to control which attributes should be bound. In order to do so, a method can be annotated with @InitBinder so that the framework will inject a reference to the Spring Model Binder. The Spring Model Binder can be configured to control the attribute binding process with the setAllowedFields and setDisallowedFields methods. Spring MVC applications extending BaseCommandController can override the initBinder(HttpServletRequest request, ServletRequestDataBinder binder) method in order to get a reference to the Spring Model Binder.\n\nExample 2: The Spring Model Binder (3.x) is configured to disallow the binding of sensitive attributes:\n\n\nfinal String[] DISALLOWED_FIELDS = new String[]{\"details.role\", \"details.age\", \"is_admin\"};\n\n@InitBinder\npublic void initBinder(WebDataBinder binder) {\nbinder.setDisallowedFields(DISALLOWED_FIELDS);\n}\n\n\nExample 3: The Spring Model Binder (2.x) is configured to disallow the binding of sensitive attributes:\n\n\n@Override\nprotected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {\nbinder.setDisallowedFields(new String[]{\"details.role\", \"details.age\", \"is_admin\"});\n}\n\n\nIn Spring MVC Applications using @RequestBody annotated parameters, the binding process is handled by HttpMessageConverter instances which will use libraries such as Jackson and JAXB to convert the HTTP request body into Java Objects. These libraries offer annotations to control which fields should be allowed or disallowed. For example, for the Jackson JSON library, the @JsonIgnore annotation can be used to prevent a field from being bound to the request.\n\nExample 4: A controller method binds an HTTP request to an instance of the Employee class using the @RequestBody annotation.\n\n\n@RequestMapping(value=\"/add/employee\", method=RequestMethod.POST, consumes=\"text/html\")\npublic void addEmployee(@RequestBody Employee employee){\n// Do something with the employee object.\n}\n\n\nThe application uses the default Jackson HttpMessageConverter to bind JSON HTTP requests to the Employee class. In order to prevent the binding of the is_admin sensitive field, use the @JsonIgnore annotation:\n\n\npublic class Employee {\n\n@JsonIgnore\nprivate boolean is_admin;\n...\n\n// Public Getters and Setters\n...\n}\n\n\nNote: Check the following REST frameworks information for more details on how to configure Jackson and JAXB annotations.\n\nApache Struts: \n\nStruts 1 and 2 will only bind HTTP request parameters to those Actions or ActionForms attributes which have an associated public setter accessor. If an attribute should not be bound to the request, its setter should be made private.\n\nExample 5: Configure a private setter so that Struts framework will not automatically bind any HTTP request parameter:\n\n\nprivate String role;\nprivate void setRole(String role)  {\nthis.role = role;\n}\n\n\nREST frameworks: \n\nMost REST frameworks will automatically bind any HTTP request bodies with content type JSON or XML to a model object. Depending on the libraries used for JSON and XML processing, there will be different ways of controlling the binding process. The following are some examples for JAXB (XML) and Jackson (JSON):\n\nExample 6: Models bound from XML documents using Oracle's JAXB library can control the binding process using different annotations such as @XmlAccessorType, @XmlAttribute, @XmlElement and @XmlTransient. The binder can be told not to bind any attributes by default, by annotating the models using the @XmlAccessorType annotation with the value XmlAccessType.NONE and then selecting which fields should be bound using @XmlAttribute and @XmlElement annotations:\n\n\n@XmlRootElement\n@XmlAccessorType(XmlAccessType.NONE)\npublic class User {\nprivate String role;\nprivate String name;\n@XmlAttribute\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nExample 7: Models bound from JSON documents using the Jackson library can control the binding process using different annotations such as @JsonIgnore, @JsonIgnoreProperties, @JsonIgnoreType and @JsonInclude. The binder can be told to ignore certain attributes by annotating them with @JsonIgnore annotation:\n\n\npublic class User {\n\n@JsonIgnore\nprivate String role;\nprivate String name;\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nA different approach to protecting against mass assignment vulnerabilities is using a layered architecture where the HTTP request parameters are bound to DTO objects. The DTO objects are only used for that purpose, exposing only those attributes defined in the web forms or API contracts, and then mapping these DTO objects to Domain Objects where the rest of the private attributes can be defined.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/12eaeb75-4cf8-459e-937e-6cf540b81ceb"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "22300896",
          "shortDescription" : {
            "text" : "Mass Assignment: Insecure Binder Configuration"
          },
          "fullDescription" : {
            "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 500 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
          },
          "help" : {
            "text" : "To ease development and increase productivity, most modern frameworks allow an object to be automatically instantiated and populated with the HTTP request parameters whose names match an attribute of the class to be bound. Automatic instantiation and population of objects speeds up development, but can lead to serious problems if implemented without caution. Any attribute in the bound classes, or nested classes, will be automatically bound to the HTTP request parameters. Therefore, malicious users will be able to assign a value to any attribute in bound or nested classes, even if they are not exposed to the client through web forms or API contracts.\n\nExample 1: Using Spring MVC with no additional configuration, the following controller method will bind the HTTP request parameters to any attribute in the User or Details classes:\n\n\n@RequestMapping(method = RequestMethod.POST)\npublic String registerUser(@ModelAttribute(\"user\") User user, BindingResult result, SessionStatus status) {\nif (db.save(user).hasErrors()) {\nreturn \"CustomerForm\";\n} else {\nstatus.setComplete();\nreturn \"CustomerSuccess\";\n}\n}\n\n\nWhere User class is defined as:\n\n\npublic class User {\nprivate String name;\nprivate String lastname;\nprivate int age;\nprivate Details details;\n\n// Public Getters and Setters\n...\n}\n\n\nand Details class is defined as:\n\n\npublic class Details {\nprivate boolean is_admin;\nprivate int id;\nprivate Date login_date;\n\n// Public Getters and Setters\n...\n}\n\n\n\nWhen using frameworks that provide automatic model binding capabilities, it is a best practice to control which attributes will be bound to the model object so that even if attackers figure out other non-exposed attributes of the model or nested classes, they will not be able to bind arbitrary values from HTTP request parameters.\n\nDepending on the framework used there will be different ways to control the model binding process:\n\nSpring MVC: \n\nIt is possible to control which HTTP request parameters will be used in the binding process and which ones will be ignored.\n\nIn Spring MVC applications using @ModelAttribute annotated parameters, the binder can be configured to control which attributes should be bound. In order to do so, a method can be annotated with @InitBinder so that the framework will inject a reference to the Spring Model Binder. The Spring Model Binder can be configured to control the attribute binding process with the setAllowedFields and setDisallowedFields methods. Spring MVC applications extending BaseCommandController can override the initBinder(HttpServletRequest request, ServletRequestDataBinder binder) method in order to get a reference to the Spring Model Binder.\n\nExample 2: The Spring Model Binder (3.x) is configured to disallow the binding of sensitive attributes:\n\n\nfinal String[] DISALLOWED_FIELDS = new String[]{\"details.role\", \"details.age\", \"is_admin\"};\n\n@InitBinder\npublic void initBinder(WebDataBinder binder) {\nbinder.setDisallowedFields(DISALLOWED_FIELDS);\n}\n\n\nExample 3: The Spring Model Binder (2.x) is configured to disallow the binding of sensitive attributes:\n\n\n@Override\nprotected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {\nbinder.setDisallowedFields(new String[]{\"details.role\", \"details.age\", \"is_admin\"});\n}\n\n\nIn Spring MVC Applications using @RequestBody annotated parameters, the binding process is handled by HttpMessageConverter instances which will use libraries such as Jackson and JAXB to convert the HTTP request body into Java Objects. These libraries offer annotations to control which fields should be allowed or disallowed. For example, for the Jackson JSON library, the @JsonIgnore annotation can be used to prevent a field from being bound to the request.\n\nExample 4: A controller method binds an HTTP request to an instance of the Employee class using the @RequestBody annotation.\n\n\n@RequestMapping(value=\"/add/employee\", method=RequestMethod.POST, consumes=\"text/html\")\npublic void addEmployee(@RequestBody Employee employee){\n// Do something with the employee object.\n}\n\n\nThe application uses the default Jackson HttpMessageConverter to bind JSON HTTP requests to the Employee class. In order to prevent the binding of the is_admin sensitive field, use the @JsonIgnore annotation:\n\n\npublic class Employee {\n\n@JsonIgnore\nprivate boolean is_admin;\n...\n\n// Public Getters and Setters\n...\n}\n\n\nNote: Check the following REST frameworks information for more details on how to configure Jackson and JAXB annotations.\n\nApache Struts: \n\nStruts 1 and 2 will only bind HTTP request parameters to those Actions or ActionForms attributes which have an associated public setter accessor. If an attribute should not be bound to the request, its setter should be made private.\n\nExample 5: Configure a private setter so that Struts framework will not automatically bind any HTTP request parameter:\n\n\nprivate String role;\nprivate void setRole(String role)  {\nthis.role = role;\n}\n\n\nREST frameworks: \n\nMost REST frameworks will automatically bind any HTTP request bodies with content type JSON or XML to a model object. Depending on the libraries used for JSON and XML processing, there will be different ways of controlling the binding process. The following are some examples for JAXB (XML) and Jackson (JSON):\n\nExample 6: Models bound from XML documents using Oracle's JAXB library can control the binding process using different annotations such as @XmlAccessorType, @XmlAttribute, @XmlElement and @XmlTransient. The binder can be told not to bind any attributes by default, by annotating the models using the @XmlAccessorType annotation with the value XmlAccessType.NONE and then selecting which fields should be bound using @XmlAttribute and @XmlElement annotations:\n\n\n@XmlRootElement\n@XmlAccessorType(XmlAccessType.NONE)\npublic class User {\nprivate String role;\nprivate String name;\n@XmlAttribute\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nExample 7: Models bound from JSON documents using the Jackson library can control the binding process using different annotations such as @JsonIgnore, @JsonIgnoreProperties, @JsonIgnoreType and @JsonInclude. The binder can be told to ignore certain attributes by annotating them with @JsonIgnore annotation:\n\n\npublic class User {\n\n@JsonIgnore\nprivate String role;\nprivate String name;\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nA different approach to protecting against mass assignment vulnerabilities is using a layered architecture where the HTTP request parameters are bound to DTO objects. The DTO objects are only used for that purpose, exposing only those attributes defined in the web forms or API contracts, and then mapping these DTO objects to Domain Objects where the rest of the private attributes can be defined.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/a3523faf-62d1-474a-b06c-ef86420a7a94"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "11445530",
          "shortDescription" : {
            "text" : "Mass Assignment: Insecure Binder Configuration"
          },
          "fullDescription" : {
            "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 208 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
          },
          "help" : {
            "text" : "To ease development and increase productivity, most modern frameworks allow an object to be automatically instantiated and populated with the HTTP request parameters whose names match an attribute of the class to be bound. Automatic instantiation and population of objects speeds up development, but can lead to serious problems if implemented without caution. Any attribute in the bound classes, or nested classes, will be automatically bound to the HTTP request parameters. Therefore, malicious users will be able to assign a value to any attribute in bound or nested classes, even if they are not exposed to the client through web forms or API contracts.\n\nExample 1: Using Spring MVC with no additional configuration, the following controller method will bind the HTTP request parameters to any attribute in the User or Details classes:\n\n\n@RequestMapping(method = RequestMethod.POST)\npublic String registerUser(@ModelAttribute(\"user\") User user, BindingResult result, SessionStatus status) {\nif (db.save(user).hasErrors()) {\nreturn \"CustomerForm\";\n} else {\nstatus.setComplete();\nreturn \"CustomerSuccess\";\n}\n}\n\n\nWhere User class is defined as:\n\n\npublic class User {\nprivate String name;\nprivate String lastname;\nprivate int age;\nprivate Details details;\n\n// Public Getters and Setters\n...\n}\n\n\nand Details class is defined as:\n\n\npublic class Details {\nprivate boolean is_admin;\nprivate int id;\nprivate Date login_date;\n\n// Public Getters and Setters\n...\n}\n\n\n\nWhen using frameworks that provide automatic model binding capabilities, it is a best practice to control which attributes will be bound to the model object so that even if attackers figure out other non-exposed attributes of the model or nested classes, they will not be able to bind arbitrary values from HTTP request parameters.\n\nDepending on the framework used there will be different ways to control the model binding process:\n\nSpring MVC: \n\nIt is possible to control which HTTP request parameters will be used in the binding process and which ones will be ignored.\n\nIn Spring MVC applications using @ModelAttribute annotated parameters, the binder can be configured to control which attributes should be bound. In order to do so, a method can be annotated with @InitBinder so that the framework will inject a reference to the Spring Model Binder. The Spring Model Binder can be configured to control the attribute binding process with the setAllowedFields and setDisallowedFields methods. Spring MVC applications extending BaseCommandController can override the initBinder(HttpServletRequest request, ServletRequestDataBinder binder) method in order to get a reference to the Spring Model Binder.\n\nExample 2: The Spring Model Binder (3.x) is configured to disallow the binding of sensitive attributes:\n\n\nfinal String[] DISALLOWED_FIELDS = new String[]{\"details.role\", \"details.age\", \"is_admin\"};\n\n@InitBinder\npublic void initBinder(WebDataBinder binder) {\nbinder.setDisallowedFields(DISALLOWED_FIELDS);\n}\n\n\nExample 3: The Spring Model Binder (2.x) is configured to disallow the binding of sensitive attributes:\n\n\n@Override\nprotected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {\nbinder.setDisallowedFields(new String[]{\"details.role\", \"details.age\", \"is_admin\"});\n}\n\n\nIn Spring MVC Applications using @RequestBody annotated parameters, the binding process is handled by HttpMessageConverter instances which will use libraries such as Jackson and JAXB to convert the HTTP request body into Java Objects. These libraries offer annotations to control which fields should be allowed or disallowed. For example, for the Jackson JSON library, the @JsonIgnore annotation can be used to prevent a field from being bound to the request.\n\nExample 4: A controller method binds an HTTP request to an instance of the Employee class using the @RequestBody annotation.\n\n\n@RequestMapping(value=\"/add/employee\", method=RequestMethod.POST, consumes=\"text/html\")\npublic void addEmployee(@RequestBody Employee employee){\n// Do something with the employee object.\n}\n\n\nThe application uses the default Jackson HttpMessageConverter to bind JSON HTTP requests to the Employee class. In order to prevent the binding of the is_admin sensitive field, use the @JsonIgnore annotation:\n\n\npublic class Employee {\n\n@JsonIgnore\nprivate boolean is_admin;\n...\n\n// Public Getters and Setters\n...\n}\n\n\nNote: Check the following REST frameworks information for more details on how to configure Jackson and JAXB annotations.\n\nApache Struts: \n\nStruts 1 and 2 will only bind HTTP request parameters to those Actions or ActionForms attributes which have an associated public setter accessor. If an attribute should not be bound to the request, its setter should be made private.\n\nExample 5: Configure a private setter so that Struts framework will not automatically bind any HTTP request parameter:\n\n\nprivate String role;\nprivate void setRole(String role)  {\nthis.role = role;\n}\n\n\nREST frameworks: \n\nMost REST frameworks will automatically bind any HTTP request bodies with content type JSON or XML to a model object. Depending on the libraries used for JSON and XML processing, there will be different ways of controlling the binding process. The following are some examples for JAXB (XML) and Jackson (JSON):\n\nExample 6: Models bound from XML documents using Oracle's JAXB library can control the binding process using different annotations such as @XmlAccessorType, @XmlAttribute, @XmlElement and @XmlTransient. The binder can be told not to bind any attributes by default, by annotating the models using the @XmlAccessorType annotation with the value XmlAccessType.NONE and then selecting which fields should be bound using @XmlAttribute and @XmlElement annotations:\n\n\n@XmlRootElement\n@XmlAccessorType(XmlAccessType.NONE)\npublic class User {\nprivate String role;\nprivate String name;\n@XmlAttribute\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nExample 7: Models bound from JSON documents using the Jackson library can control the binding process using different annotations such as @JsonIgnore, @JsonIgnoreProperties, @JsonIgnoreType and @JsonInclude. The binder can be told to ignore certain attributes by annotating them with @JsonIgnore annotation:\n\n\npublic class User {\n\n@JsonIgnore\nprivate String role;\nprivate String name;\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nA different approach to protecting against mass assignment vulnerabilities is using a layered architecture where the HTTP request parameters are bound to DTO objects. The DTO objects are only used for that purpose, exposing only those attributes defined in the web forms or API contracts, and then mapping these DTO objects to Domain Objects where the rest of the private attributes can be defined.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/d5317d64-75fb-4e1b-9f0b-7f6030c75b69"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "11445532",
          "shortDescription" : {
            "text" : "Mass Assignment: Insecure Binder Configuration"
          },
          "fullDescription" : {
            "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 102 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
          },
          "help" : {
            "text" : "To ease development and increase productivity, most modern frameworks allow an object to be automatically instantiated and populated with the HTTP request parameters whose names match an attribute of the class to be bound. Automatic instantiation and population of objects speeds up development, but can lead to serious problems if implemented without caution. Any attribute in the bound classes, or nested classes, will be automatically bound to the HTTP request parameters. Therefore, malicious users will be able to assign a value to any attribute in bound or nested classes, even if they are not exposed to the client through web forms or API contracts.\n\nExample 1: Using Spring MVC with no additional configuration, the following controller method will bind the HTTP request parameters to any attribute in the User or Details classes:\n\n\n@RequestMapping(method = RequestMethod.POST)\npublic String registerUser(@ModelAttribute(\"user\") User user, BindingResult result, SessionStatus status) {\nif (db.save(user).hasErrors()) {\nreturn \"CustomerForm\";\n} else {\nstatus.setComplete();\nreturn \"CustomerSuccess\";\n}\n}\n\n\nWhere User class is defined as:\n\n\npublic class User {\nprivate String name;\nprivate String lastname;\nprivate int age;\nprivate Details details;\n\n// Public Getters and Setters\n...\n}\n\n\nand Details class is defined as:\n\n\npublic class Details {\nprivate boolean is_admin;\nprivate int id;\nprivate Date login_date;\n\n// Public Getters and Setters\n...\n}\n\n\n\nWhen using frameworks that provide automatic model binding capabilities, it is a best practice to control which attributes will be bound to the model object so that even if attackers figure out other non-exposed attributes of the model or nested classes, they will not be able to bind arbitrary values from HTTP request parameters.\n\nDepending on the framework used there will be different ways to control the model binding process:\n\nSpring MVC: \n\nIt is possible to control which HTTP request parameters will be used in the binding process and which ones will be ignored.\n\nIn Spring MVC applications using @ModelAttribute annotated parameters, the binder can be configured to control which attributes should be bound. In order to do so, a method can be annotated with @InitBinder so that the framework will inject a reference to the Spring Model Binder. The Spring Model Binder can be configured to control the attribute binding process with the setAllowedFields and setDisallowedFields methods. Spring MVC applications extending BaseCommandController can override the initBinder(HttpServletRequest request, ServletRequestDataBinder binder) method in order to get a reference to the Spring Model Binder.\n\nExample 2: The Spring Model Binder (3.x) is configured to disallow the binding of sensitive attributes:\n\n\nfinal String[] DISALLOWED_FIELDS = new String[]{\"details.role\", \"details.age\", \"is_admin\"};\n\n@InitBinder\npublic void initBinder(WebDataBinder binder) {\nbinder.setDisallowedFields(DISALLOWED_FIELDS);\n}\n\n\nExample 3: The Spring Model Binder (2.x) is configured to disallow the binding of sensitive attributes:\n\n\n@Override\nprotected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {\nbinder.setDisallowedFields(new String[]{\"details.role\", \"details.age\", \"is_admin\"});\n}\n\n\nIn Spring MVC Applications using @RequestBody annotated parameters, the binding process is handled by HttpMessageConverter instances which will use libraries such as Jackson and JAXB to convert the HTTP request body into Java Objects. These libraries offer annotations to control which fields should be allowed or disallowed. For example, for the Jackson JSON library, the @JsonIgnore annotation can be used to prevent a field from being bound to the request.\n\nExample 4: A controller method binds an HTTP request to an instance of the Employee class using the @RequestBody annotation.\n\n\n@RequestMapping(value=\"/add/employee\", method=RequestMethod.POST, consumes=\"text/html\")\npublic void addEmployee(@RequestBody Employee employee){\n// Do something with the employee object.\n}\n\n\nThe application uses the default Jackson HttpMessageConverter to bind JSON HTTP requests to the Employee class. In order to prevent the binding of the is_admin sensitive field, use the @JsonIgnore annotation:\n\n\npublic class Employee {\n\n@JsonIgnore\nprivate boolean is_admin;\n...\n\n// Public Getters and Setters\n...\n}\n\n\nNote: Check the following REST frameworks information for more details on how to configure Jackson and JAXB annotations.\n\nApache Struts: \n\nStruts 1 and 2 will only bind HTTP request parameters to those Actions or ActionForms attributes which have an associated public setter accessor. If an attribute should not be bound to the request, its setter should be made private.\n\nExample 5: Configure a private setter so that Struts framework will not automatically bind any HTTP request parameter:\n\n\nprivate String role;\nprivate void setRole(String role)  {\nthis.role = role;\n}\n\n\nREST frameworks: \n\nMost REST frameworks will automatically bind any HTTP request bodies with content type JSON or XML to a model object. Depending on the libraries used for JSON and XML processing, there will be different ways of controlling the binding process. The following are some examples for JAXB (XML) and Jackson (JSON):\n\nExample 6: Models bound from XML documents using Oracle's JAXB library can control the binding process using different annotations such as @XmlAccessorType, @XmlAttribute, @XmlElement and @XmlTransient. The binder can be told not to bind any attributes by default, by annotating the models using the @XmlAccessorType annotation with the value XmlAccessType.NONE and then selecting which fields should be bound using @XmlAttribute and @XmlElement annotations:\n\n\n@XmlRootElement\n@XmlAccessorType(XmlAccessType.NONE)\npublic class User {\nprivate String role;\nprivate String name;\n@XmlAttribute\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nExample 7: Models bound from JSON documents using the Jackson library can control the binding process using different annotations such as @JsonIgnore, @JsonIgnoreProperties, @JsonIgnoreType and @JsonInclude. The binder can be told to ignore certain attributes by annotating them with @JsonIgnore annotation:\n\n\npublic class User {\n\n@JsonIgnore\nprivate String role;\nprivate String name;\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nA different approach to protecting against mass assignment vulnerabilities is using a layered architecture where the HTTP request parameters are bound to DTO objects. The DTO objects are only used for that purpose, exposing only those attributes defined in the web forms or API contracts, and then mapping these DTO objects to Domain Objects where the rest of the private attributes can be defined.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/e76bfef4-6638-4364-b905-81a08dcf0677"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "14220179",
          "shortDescription" : {
            "text" : "Mass Assignment: Insecure Binder Configuration"
          },
          "fullDescription" : {
            "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 101 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
          },
          "help" : {
            "text" : "To ease development and increase productivity, most modern frameworks allow an object to be automatically instantiated and populated with the HTTP request parameters whose names match an attribute of the class to be bound. Automatic instantiation and population of objects speeds up development, but can lead to serious problems if implemented without caution. Any attribute in the bound classes, or nested classes, will be automatically bound to the HTTP request parameters. Therefore, malicious users will be able to assign a value to any attribute in bound or nested classes, even if they are not exposed to the client through web forms or API contracts.\n\nExample 1: Using Spring MVC with no additional configuration, the following controller method will bind the HTTP request parameters to any attribute in the User or Details classes:\n\n\n@RequestMapping(method = RequestMethod.POST)\npublic String registerUser(@ModelAttribute(\"user\") User user, BindingResult result, SessionStatus status) {\nif (db.save(user).hasErrors()) {\nreturn \"CustomerForm\";\n} else {\nstatus.setComplete();\nreturn \"CustomerSuccess\";\n}\n}\n\n\nWhere User class is defined as:\n\n\npublic class User {\nprivate String name;\nprivate String lastname;\nprivate int age;\nprivate Details details;\n\n// Public Getters and Setters\n...\n}\n\n\nand Details class is defined as:\n\n\npublic class Details {\nprivate boolean is_admin;\nprivate int id;\nprivate Date login_date;\n\n// Public Getters and Setters\n...\n}\n\n\n\nWhen using frameworks that provide automatic model binding capabilities, it is a best practice to control which attributes will be bound to the model object so that even if attackers figure out other non-exposed attributes of the model or nested classes, they will not be able to bind arbitrary values from HTTP request parameters.\n\nDepending on the framework used there will be different ways to control the model binding process:\n\nSpring MVC: \n\nIt is possible to control which HTTP request parameters will be used in the binding process and which ones will be ignored.\n\nIn Spring MVC applications using @ModelAttribute annotated parameters, the binder can be configured to control which attributes should be bound. In order to do so, a method can be annotated with @InitBinder so that the framework will inject a reference to the Spring Model Binder. The Spring Model Binder can be configured to control the attribute binding process with the setAllowedFields and setDisallowedFields methods. Spring MVC applications extending BaseCommandController can override the initBinder(HttpServletRequest request, ServletRequestDataBinder binder) method in order to get a reference to the Spring Model Binder.\n\nExample 2: The Spring Model Binder (3.x) is configured to disallow the binding of sensitive attributes:\n\n\nfinal String[] DISALLOWED_FIELDS = new String[]{\"details.role\", \"details.age\", \"is_admin\"};\n\n@InitBinder\npublic void initBinder(WebDataBinder binder) {\nbinder.setDisallowedFields(DISALLOWED_FIELDS);\n}\n\n\nExample 3: The Spring Model Binder (2.x) is configured to disallow the binding of sensitive attributes:\n\n\n@Override\nprotected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {\nbinder.setDisallowedFields(new String[]{\"details.role\", \"details.age\", \"is_admin\"});\n}\n\n\nIn Spring MVC Applications using @RequestBody annotated parameters, the binding process is handled by HttpMessageConverter instances which will use libraries such as Jackson and JAXB to convert the HTTP request body into Java Objects. These libraries offer annotations to control which fields should be allowed or disallowed. For example, for the Jackson JSON library, the @JsonIgnore annotation can be used to prevent a field from being bound to the request.\n\nExample 4: A controller method binds an HTTP request to an instance of the Employee class using the @RequestBody annotation.\n\n\n@RequestMapping(value=\"/add/employee\", method=RequestMethod.POST, consumes=\"text/html\")\npublic void addEmployee(@RequestBody Employee employee){\n// Do something with the employee object.\n}\n\n\nThe application uses the default Jackson HttpMessageConverter to bind JSON HTTP requests to the Employee class. In order to prevent the binding of the is_admin sensitive field, use the @JsonIgnore annotation:\n\n\npublic class Employee {\n\n@JsonIgnore\nprivate boolean is_admin;\n...\n\n// Public Getters and Setters\n...\n}\n\n\nNote: Check the following REST frameworks information for more details on how to configure Jackson and JAXB annotations.\n\nApache Struts: \n\nStruts 1 and 2 will only bind HTTP request parameters to those Actions or ActionForms attributes which have an associated public setter accessor. If an attribute should not be bound to the request, its setter should be made private.\n\nExample 5: Configure a private setter so that Struts framework will not automatically bind any HTTP request parameter:\n\n\nprivate String role;\nprivate void setRole(String role)  {\nthis.role = role;\n}\n\n\nREST frameworks: \n\nMost REST frameworks will automatically bind any HTTP request bodies with content type JSON or XML to a model object. Depending on the libraries used for JSON and XML processing, there will be different ways of controlling the binding process. The following are some examples for JAXB (XML) and Jackson (JSON):\n\nExample 6: Models bound from XML documents using Oracle's JAXB library can control the binding process using different annotations such as @XmlAccessorType, @XmlAttribute, @XmlElement and @XmlTransient. The binder can be told not to bind any attributes by default, by annotating the models using the @XmlAccessorType annotation with the value XmlAccessType.NONE and then selecting which fields should be bound using @XmlAttribute and @XmlElement annotations:\n\n\n@XmlRootElement\n@XmlAccessorType(XmlAccessType.NONE)\npublic class User {\nprivate String role;\nprivate String name;\n@XmlAttribute\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nExample 7: Models bound from JSON documents using the Jackson library can control the binding process using different annotations such as @JsonIgnore, @JsonIgnoreProperties, @JsonIgnoreType and @JsonInclude. The binder can be told to ignore certain attributes by annotating them with @JsonIgnore annotation:\n\n\npublic class User {\n\n@JsonIgnore\nprivate String role;\nprivate String name;\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nA different approach to protecting against mass assignment vulnerabilities is using a layered architecture where the HTTP request parameters are bound to DTO objects. The DTO objects are only used for that purpose, exposing only those attributes defined in the web forms or API contracts, and then mapping these DTO objects to Domain Objects where the rest of the private attributes can be defined.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/d1b17729-ad36-4efb-b74b-49dae1deb5a7"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "11445534",
          "shortDescription" : {
            "text" : "Mass Assignment: Insecure Binder Configuration"
          },
          "fullDescription" : {
            "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 120 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
          },
          "help" : {
            "text" : "To ease development and increase productivity, most modern frameworks allow an object to be automatically instantiated and populated with the HTTP request parameters whose names match an attribute of the class to be bound. Automatic instantiation and population of objects speeds up development, but can lead to serious problems if implemented without caution. Any attribute in the bound classes, or nested classes, will be automatically bound to the HTTP request parameters. Therefore, malicious users will be able to assign a value to any attribute in bound or nested classes, even if they are not exposed to the client through web forms or API contracts.\n\nExample 1: Using Spring MVC with no additional configuration, the following controller method will bind the HTTP request parameters to any attribute in the User or Details classes:\n\n\n@RequestMapping(method = RequestMethod.POST)\npublic String registerUser(@ModelAttribute(\"user\") User user, BindingResult result, SessionStatus status) {\nif (db.save(user).hasErrors()) {\nreturn \"CustomerForm\";\n} else {\nstatus.setComplete();\nreturn \"CustomerSuccess\";\n}\n}\n\n\nWhere User class is defined as:\n\n\npublic class User {\nprivate String name;\nprivate String lastname;\nprivate int age;\nprivate Details details;\n\n// Public Getters and Setters\n...\n}\n\n\nand Details class is defined as:\n\n\npublic class Details {\nprivate boolean is_admin;\nprivate int id;\nprivate Date login_date;\n\n// Public Getters and Setters\n...\n}\n\n\n\nWhen using frameworks that provide automatic model binding capabilities, it is a best practice to control which attributes will be bound to the model object so that even if attackers figure out other non-exposed attributes of the model or nested classes, they will not be able to bind arbitrary values from HTTP request parameters.\n\nDepending on the framework used there will be different ways to control the model binding process:\n\nSpring MVC: \n\nIt is possible to control which HTTP request parameters will be used in the binding process and which ones will be ignored.\n\nIn Spring MVC applications using @ModelAttribute annotated parameters, the binder can be configured to control which attributes should be bound. In order to do so, a method can be annotated with @InitBinder so that the framework will inject a reference to the Spring Model Binder. The Spring Model Binder can be configured to control the attribute binding process with the setAllowedFields and setDisallowedFields methods. Spring MVC applications extending BaseCommandController can override the initBinder(HttpServletRequest request, ServletRequestDataBinder binder) method in order to get a reference to the Spring Model Binder.\n\nExample 2: The Spring Model Binder (3.x) is configured to disallow the binding of sensitive attributes:\n\n\nfinal String[] DISALLOWED_FIELDS = new String[]{\"details.role\", \"details.age\", \"is_admin\"};\n\n@InitBinder\npublic void initBinder(WebDataBinder binder) {\nbinder.setDisallowedFields(DISALLOWED_FIELDS);\n}\n\n\nExample 3: The Spring Model Binder (2.x) is configured to disallow the binding of sensitive attributes:\n\n\n@Override\nprotected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {\nbinder.setDisallowedFields(new String[]{\"details.role\", \"details.age\", \"is_admin\"});\n}\n\n\nIn Spring MVC Applications using @RequestBody annotated parameters, the binding process is handled by HttpMessageConverter instances which will use libraries such as Jackson and JAXB to convert the HTTP request body into Java Objects. These libraries offer annotations to control which fields should be allowed or disallowed. For example, for the Jackson JSON library, the @JsonIgnore annotation can be used to prevent a field from being bound to the request.\n\nExample 4: A controller method binds an HTTP request to an instance of the Employee class using the @RequestBody annotation.\n\n\n@RequestMapping(value=\"/add/employee\", method=RequestMethod.POST, consumes=\"text/html\")\npublic void addEmployee(@RequestBody Employee employee){\n// Do something with the employee object.\n}\n\n\nThe application uses the default Jackson HttpMessageConverter to bind JSON HTTP requests to the Employee class. In order to prevent the binding of the is_admin sensitive field, use the @JsonIgnore annotation:\n\n\npublic class Employee {\n\n@JsonIgnore\nprivate boolean is_admin;\n...\n\n// Public Getters and Setters\n...\n}\n\n\nNote: Check the following REST frameworks information for more details on how to configure Jackson and JAXB annotations.\n\nApache Struts: \n\nStruts 1 and 2 will only bind HTTP request parameters to those Actions or ActionForms attributes which have an associated public setter accessor. If an attribute should not be bound to the request, its setter should be made private.\n\nExample 5: Configure a private setter so that Struts framework will not automatically bind any HTTP request parameter:\n\n\nprivate String role;\nprivate void setRole(String role)  {\nthis.role = role;\n}\n\n\nREST frameworks: \n\nMost REST frameworks will automatically bind any HTTP request bodies with content type JSON or XML to a model object. Depending on the libraries used for JSON and XML processing, there will be different ways of controlling the binding process. The following are some examples for JAXB (XML) and Jackson (JSON):\n\nExample 6: Models bound from XML documents using Oracle's JAXB library can control the binding process using different annotations such as @XmlAccessorType, @XmlAttribute, @XmlElement and @XmlTransient. The binder can be told not to bind any attributes by default, by annotating the models using the @XmlAccessorType annotation with the value XmlAccessType.NONE and then selecting which fields should be bound using @XmlAttribute and @XmlElement annotations:\n\n\n@XmlRootElement\n@XmlAccessorType(XmlAccessType.NONE)\npublic class User {\nprivate String role;\nprivate String name;\n@XmlAttribute\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nExample 7: Models bound from JSON documents using the Jackson library can control the binding process using different annotations such as @JsonIgnore, @JsonIgnoreProperties, @JsonIgnoreType and @JsonInclude. The binder can be told to ignore certain attributes by annotating them with @JsonIgnore annotation:\n\n\npublic class User {\n\n@JsonIgnore\nprivate String role;\nprivate String name;\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nA different approach to protecting against mass assignment vulnerabilities is using a layered architecture where the HTTP request parameters are bound to DTO objects. The DTO objects are only used for that purpose, exposing only those attributes defined in the web forms or API contracts, and then mapping these DTO objects to Domain Objects where the rest of the private attributes can be defined.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/55c4acf8-622e-4395-a711-8583b4f02df9"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "11445538",
          "shortDescription" : {
            "text" : "Mass Assignment: Insecure Binder Configuration"
          },
          "fullDescription" : {
            "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 81 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
          },
          "help" : {
            "text" : "To ease development and increase productivity, most modern frameworks allow an object to be automatically instantiated and populated with the HTTP request parameters whose names match an attribute of the class to be bound. Automatic instantiation and population of objects speeds up development, but can lead to serious problems if implemented without caution. Any attribute in the bound classes, or nested classes, will be automatically bound to the HTTP request parameters. Therefore, malicious users will be able to assign a value to any attribute in bound or nested classes, even if they are not exposed to the client through web forms or API contracts.\n\nExample 1: Using Spring MVC with no additional configuration, the following controller method will bind the HTTP request parameters to any attribute in the User or Details classes:\n\n\n@RequestMapping(method = RequestMethod.POST)\npublic String registerUser(@ModelAttribute(\"user\") User user, BindingResult result, SessionStatus status) {\nif (db.save(user).hasErrors()) {\nreturn \"CustomerForm\";\n} else {\nstatus.setComplete();\nreturn \"CustomerSuccess\";\n}\n}\n\n\nWhere User class is defined as:\n\n\npublic class User {\nprivate String name;\nprivate String lastname;\nprivate int age;\nprivate Details details;\n\n// Public Getters and Setters\n...\n}\n\n\nand Details class is defined as:\n\n\npublic class Details {\nprivate boolean is_admin;\nprivate int id;\nprivate Date login_date;\n\n// Public Getters and Setters\n...\n}\n\n\n\nWhen using frameworks that provide automatic model binding capabilities, it is a best practice to control which attributes will be bound to the model object so that even if attackers figure out other non-exposed attributes of the model or nested classes, they will not be able to bind arbitrary values from HTTP request parameters.\n\nDepending on the framework used there will be different ways to control the model binding process:\n\nSpring MVC: \n\nIt is possible to control which HTTP request parameters will be used in the binding process and which ones will be ignored.\n\nIn Spring MVC applications using @ModelAttribute annotated parameters, the binder can be configured to control which attributes should be bound. In order to do so, a method can be annotated with @InitBinder so that the framework will inject a reference to the Spring Model Binder. The Spring Model Binder can be configured to control the attribute binding process with the setAllowedFields and setDisallowedFields methods. Spring MVC applications extending BaseCommandController can override the initBinder(HttpServletRequest request, ServletRequestDataBinder binder) method in order to get a reference to the Spring Model Binder.\n\nExample 2: The Spring Model Binder (3.x) is configured to disallow the binding of sensitive attributes:\n\n\nfinal String[] DISALLOWED_FIELDS = new String[]{\"details.role\", \"details.age\", \"is_admin\"};\n\n@InitBinder\npublic void initBinder(WebDataBinder binder) {\nbinder.setDisallowedFields(DISALLOWED_FIELDS);\n}\n\n\nExample 3: The Spring Model Binder (2.x) is configured to disallow the binding of sensitive attributes:\n\n\n@Override\nprotected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {\nbinder.setDisallowedFields(new String[]{\"details.role\", \"details.age\", \"is_admin\"});\n}\n\n\nIn Spring MVC Applications using @RequestBody annotated parameters, the binding process is handled by HttpMessageConverter instances which will use libraries such as Jackson and JAXB to convert the HTTP request body into Java Objects. These libraries offer annotations to control which fields should be allowed or disallowed. For example, for the Jackson JSON library, the @JsonIgnore annotation can be used to prevent a field from being bound to the request.\n\nExample 4: A controller method binds an HTTP request to an instance of the Employee class using the @RequestBody annotation.\n\n\n@RequestMapping(value=\"/add/employee\", method=RequestMethod.POST, consumes=\"text/html\")\npublic void addEmployee(@RequestBody Employee employee){\n// Do something with the employee object.\n}\n\n\nThe application uses the default Jackson HttpMessageConverter to bind JSON HTTP requests to the Employee class. In order to prevent the binding of the is_admin sensitive field, use the @JsonIgnore annotation:\n\n\npublic class Employee {\n\n@JsonIgnore\nprivate boolean is_admin;\n...\n\n// Public Getters and Setters\n...\n}\n\n\nNote: Check the following REST frameworks information for more details on how to configure Jackson and JAXB annotations.\n\nApache Struts: \n\nStruts 1 and 2 will only bind HTTP request parameters to those Actions or ActionForms attributes which have an associated public setter accessor. If an attribute should not be bound to the request, its setter should be made private.\n\nExample 5: Configure a private setter so that Struts framework will not automatically bind any HTTP request parameter:\n\n\nprivate String role;\nprivate void setRole(String role)  {\nthis.role = role;\n}\n\n\nREST frameworks: \n\nMost REST frameworks will automatically bind any HTTP request bodies with content type JSON or XML to a model object. Depending on the libraries used for JSON and XML processing, there will be different ways of controlling the binding process. The following are some examples for JAXB (XML) and Jackson (JSON):\n\nExample 6: Models bound from XML documents using Oracle's JAXB library can control the binding process using different annotations such as @XmlAccessorType, @XmlAttribute, @XmlElement and @XmlTransient. The binder can be told not to bind any attributes by default, by annotating the models using the @XmlAccessorType annotation with the value XmlAccessType.NONE and then selecting which fields should be bound using @XmlAttribute and @XmlElement annotations:\n\n\n@XmlRootElement\n@XmlAccessorType(XmlAccessType.NONE)\npublic class User {\nprivate String role;\nprivate String name;\n@XmlAttribute\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nExample 7: Models bound from JSON documents using the Jackson library can control the binding process using different annotations such as @JsonIgnore, @JsonIgnoreProperties, @JsonIgnoreType and @JsonInclude. The binder can be told to ignore certain attributes by annotating them with @JsonIgnore annotation:\n\n\npublic class User {\n\n@JsonIgnore\nprivate String role;\nprivate String name;\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nA different approach to protecting against mass assignment vulnerabilities is using a layered architecture where the HTTP request parameters are bound to DTO objects. The DTO objects are only used for that purpose, exposing only those attributes defined in the web forms or API contracts, and then mapping these DTO objects to Domain Objects where the rest of the private attributes can be defined.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/bcd1c921-d54f-4efc-93b9-b9ce074dea43"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "13421042",
          "shortDescription" : {
            "text" : "Mass Assignment: Insecure Binder Configuration"
          },
          "fullDescription" : {
            "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 103 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
          },
          "help" : {
            "text" : "To ease development and increase productivity, most modern frameworks allow an object to be automatically instantiated and populated with the HTTP request parameters whose names match an attribute of the class to be bound. Automatic instantiation and population of objects speeds up development, but can lead to serious problems if implemented without caution. Any attribute in the bound classes, or nested classes, will be automatically bound to the HTTP request parameters. Therefore, malicious users will be able to assign a value to any attribute in bound or nested classes, even if they are not exposed to the client through web forms or API contracts.\n\nExample 1: Using Spring MVC with no additional configuration, the following controller method will bind the HTTP request parameters to any attribute in the User or Details classes:\n\n\n@RequestMapping(method = RequestMethod.POST)\npublic String registerUser(@ModelAttribute(\"user\") User user, BindingResult result, SessionStatus status) {\nif (db.save(user).hasErrors()) {\nreturn \"CustomerForm\";\n} else {\nstatus.setComplete();\nreturn \"CustomerSuccess\";\n}\n}\n\n\nWhere User class is defined as:\n\n\npublic class User {\nprivate String name;\nprivate String lastname;\nprivate int age;\nprivate Details details;\n\n// Public Getters and Setters\n...\n}\n\n\nand Details class is defined as:\n\n\npublic class Details {\nprivate boolean is_admin;\nprivate int id;\nprivate Date login_date;\n\n// Public Getters and Setters\n...\n}\n\n\n\nWhen using frameworks that provide automatic model binding capabilities, it is a best practice to control which attributes will be bound to the model object so that even if attackers figure out other non-exposed attributes of the model or nested classes, they will not be able to bind arbitrary values from HTTP request parameters.\n\nDepending on the framework used there will be different ways to control the model binding process:\n\nSpring MVC: \n\nIt is possible to control which HTTP request parameters will be used in the binding process and which ones will be ignored.\n\nIn Spring MVC applications using @ModelAttribute annotated parameters, the binder can be configured to control which attributes should be bound. In order to do so, a method can be annotated with @InitBinder so that the framework will inject a reference to the Spring Model Binder. The Spring Model Binder can be configured to control the attribute binding process with the setAllowedFields and setDisallowedFields methods. Spring MVC applications extending BaseCommandController can override the initBinder(HttpServletRequest request, ServletRequestDataBinder binder) method in order to get a reference to the Spring Model Binder.\n\nExample 2: The Spring Model Binder (3.x) is configured to disallow the binding of sensitive attributes:\n\n\nfinal String[] DISALLOWED_FIELDS = new String[]{\"details.role\", \"details.age\", \"is_admin\"};\n\n@InitBinder\npublic void initBinder(WebDataBinder binder) {\nbinder.setDisallowedFields(DISALLOWED_FIELDS);\n}\n\n\nExample 3: The Spring Model Binder (2.x) is configured to disallow the binding of sensitive attributes:\n\n\n@Override\nprotected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {\nbinder.setDisallowedFields(new String[]{\"details.role\", \"details.age\", \"is_admin\"});\n}\n\n\nIn Spring MVC Applications using @RequestBody annotated parameters, the binding process is handled by HttpMessageConverter instances which will use libraries such as Jackson and JAXB to convert the HTTP request body into Java Objects. These libraries offer annotations to control which fields should be allowed or disallowed. For example, for the Jackson JSON library, the @JsonIgnore annotation can be used to prevent a field from being bound to the request.\n\nExample 4: A controller method binds an HTTP request to an instance of the Employee class using the @RequestBody annotation.\n\n\n@RequestMapping(value=\"/add/employee\", method=RequestMethod.POST, consumes=\"text/html\")\npublic void addEmployee(@RequestBody Employee employee){\n// Do something with the employee object.\n}\n\n\nThe application uses the default Jackson HttpMessageConverter to bind JSON HTTP requests to the Employee class. In order to prevent the binding of the is_admin sensitive field, use the @JsonIgnore annotation:\n\n\npublic class Employee {\n\n@JsonIgnore\nprivate boolean is_admin;\n...\n\n// Public Getters and Setters\n...\n}\n\n\nNote: Check the following REST frameworks information for more details on how to configure Jackson and JAXB annotations.\n\nApache Struts: \n\nStruts 1 and 2 will only bind HTTP request parameters to those Actions or ActionForms attributes which have an associated public setter accessor. If an attribute should not be bound to the request, its setter should be made private.\n\nExample 5: Configure a private setter so that Struts framework will not automatically bind any HTTP request parameter:\n\n\nprivate String role;\nprivate void setRole(String role)  {\nthis.role = role;\n}\n\n\nREST frameworks: \n\nMost REST frameworks will automatically bind any HTTP request bodies with content type JSON or XML to a model object. Depending on the libraries used for JSON and XML processing, there will be different ways of controlling the binding process. The following are some examples for JAXB (XML) and Jackson (JSON):\n\nExample 6: Models bound from XML documents using Oracle's JAXB library can control the binding process using different annotations such as @XmlAccessorType, @XmlAttribute, @XmlElement and @XmlTransient. The binder can be told not to bind any attributes by default, by annotating the models using the @XmlAccessorType annotation with the value XmlAccessType.NONE and then selecting which fields should be bound using @XmlAttribute and @XmlElement annotations:\n\n\n@XmlRootElement\n@XmlAccessorType(XmlAccessType.NONE)\npublic class User {\nprivate String role;\nprivate String name;\n@XmlAttribute\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nExample 7: Models bound from JSON documents using the Jackson library can control the binding process using different annotations such as @JsonIgnore, @JsonIgnoreProperties, @JsonIgnoreType and @JsonInclude. The binder can be told to ignore certain attributes by annotating them with @JsonIgnore annotation:\n\n\npublic class User {\n\n@JsonIgnore\nprivate String role;\nprivate String name;\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nA different approach to protecting against mass assignment vulnerabilities is using a layered architecture where the HTTP request parameters are bound to DTO objects. The DTO objects are only used for that purpose, exposing only those attributes defined in the web forms or API contracts, and then mapping these DTO objects to Domain Objects where the rest of the private attributes can be defined.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/e8c182f3-2ff4-402c-ab90-7659255e536b"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "18303921",
          "shortDescription" : {
            "text" : "Mass Assignment: Insecure Binder Configuration"
          },
          "fullDescription" : {
            "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 398 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
          },
          "help" : {
            "text" : "To ease development and increase productivity, most modern frameworks allow an object to be automatically instantiated and populated with the HTTP request parameters whose names match an attribute of the class to be bound. Automatic instantiation and population of objects speeds up development, but can lead to serious problems if implemented without caution. Any attribute in the bound classes, or nested classes, will be automatically bound to the HTTP request parameters. Therefore, malicious users will be able to assign a value to any attribute in bound or nested classes, even if they are not exposed to the client through web forms or API contracts.\n\nExample 1: Using Spring MVC with no additional configuration, the following controller method will bind the HTTP request parameters to any attribute in the User or Details classes:\n\n\n@RequestMapping(method = RequestMethod.POST)\npublic String registerUser(@ModelAttribute(\"user\") User user, BindingResult result, SessionStatus status) {\nif (db.save(user).hasErrors()) {\nreturn \"CustomerForm\";\n} else {\nstatus.setComplete();\nreturn \"CustomerSuccess\";\n}\n}\n\n\nWhere User class is defined as:\n\n\npublic class User {\nprivate String name;\nprivate String lastname;\nprivate int age;\nprivate Details details;\n\n// Public Getters and Setters\n...\n}\n\n\nand Details class is defined as:\n\n\npublic class Details {\nprivate boolean is_admin;\nprivate int id;\nprivate Date login_date;\n\n// Public Getters and Setters\n...\n}\n\n\n\nWhen using frameworks that provide automatic model binding capabilities, it is a best practice to control which attributes will be bound to the model object so that even if attackers figure out other non-exposed attributes of the model or nested classes, they will not be able to bind arbitrary values from HTTP request parameters.\n\nDepending on the framework used there will be different ways to control the model binding process:\n\nSpring MVC: \n\nIt is possible to control which HTTP request parameters will be used in the binding process and which ones will be ignored.\n\nIn Spring MVC applications using @ModelAttribute annotated parameters, the binder can be configured to control which attributes should be bound. In order to do so, a method can be annotated with @InitBinder so that the framework will inject a reference to the Spring Model Binder. The Spring Model Binder can be configured to control the attribute binding process with the setAllowedFields and setDisallowedFields methods. Spring MVC applications extending BaseCommandController can override the initBinder(HttpServletRequest request, ServletRequestDataBinder binder) method in order to get a reference to the Spring Model Binder.\n\nExample 2: The Spring Model Binder (3.x) is configured to disallow the binding of sensitive attributes:\n\n\nfinal String[] DISALLOWED_FIELDS = new String[]{\"details.role\", \"details.age\", \"is_admin\"};\n\n@InitBinder\npublic void initBinder(WebDataBinder binder) {\nbinder.setDisallowedFields(DISALLOWED_FIELDS);\n}\n\n\nExample 3: The Spring Model Binder (2.x) is configured to disallow the binding of sensitive attributes:\n\n\n@Override\nprotected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {\nbinder.setDisallowedFields(new String[]{\"details.role\", \"details.age\", \"is_admin\"});\n}\n\n\nIn Spring MVC Applications using @RequestBody annotated parameters, the binding process is handled by HttpMessageConverter instances which will use libraries such as Jackson and JAXB to convert the HTTP request body into Java Objects. These libraries offer annotations to control which fields should be allowed or disallowed. For example, for the Jackson JSON library, the @JsonIgnore annotation can be used to prevent a field from being bound to the request.\n\nExample 4: A controller method binds an HTTP request to an instance of the Employee class using the @RequestBody annotation.\n\n\n@RequestMapping(value=\"/add/employee\", method=RequestMethod.POST, consumes=\"text/html\")\npublic void addEmployee(@RequestBody Employee employee){\n// Do something with the employee object.\n}\n\n\nThe application uses the default Jackson HttpMessageConverter to bind JSON HTTP requests to the Employee class. In order to prevent the binding of the is_admin sensitive field, use the @JsonIgnore annotation:\n\n\npublic class Employee {\n\n@JsonIgnore\nprivate boolean is_admin;\n...\n\n// Public Getters and Setters\n...\n}\n\n\nNote: Check the following REST frameworks information for more details on how to configure Jackson and JAXB annotations.\n\nApache Struts: \n\nStruts 1 and 2 will only bind HTTP request parameters to those Actions or ActionForms attributes which have an associated public setter accessor. If an attribute should not be bound to the request, its setter should be made private.\n\nExample 5: Configure a private setter so that Struts framework will not automatically bind any HTTP request parameter:\n\n\nprivate String role;\nprivate void setRole(String role)  {\nthis.role = role;\n}\n\n\nREST frameworks: \n\nMost REST frameworks will automatically bind any HTTP request bodies with content type JSON or XML to a model object. Depending on the libraries used for JSON and XML processing, there will be different ways of controlling the binding process. The following are some examples for JAXB (XML) and Jackson (JSON):\n\nExample 6: Models bound from XML documents using Oracle's JAXB library can control the binding process using different annotations such as @XmlAccessorType, @XmlAttribute, @XmlElement and @XmlTransient. The binder can be told not to bind any attributes by default, by annotating the models using the @XmlAccessorType annotation with the value XmlAccessType.NONE and then selecting which fields should be bound using @XmlAttribute and @XmlElement annotations:\n\n\n@XmlRootElement\n@XmlAccessorType(XmlAccessType.NONE)\npublic class User {\nprivate String role;\nprivate String name;\n@XmlAttribute\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nExample 7: Models bound from JSON documents using the Jackson library can control the binding process using different annotations such as @JsonIgnore, @JsonIgnoreProperties, @JsonIgnoreType and @JsonInclude. The binder can be told to ignore certain attributes by annotating them with @JsonIgnore annotation:\n\n\npublic class User {\n\n@JsonIgnore\nprivate String role;\nprivate String name;\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nA different approach to protecting against mass assignment vulnerabilities is using a layered architecture where the HTTP request parameters are bound to DTO objects. The DTO objects are only used for that purpose, exposing only those attributes defined in the web forms or API contracts, and then mapping these DTO objects to Domain Objects where the rest of the private attributes can be defined.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/b6a8581c-a066-46ca-87d5-b03402353181"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "22300898",
          "shortDescription" : {
            "text" : "Mass Assignment: Insecure Binder Configuration"
          },
          "fullDescription" : {
            "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 101 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
          },
          "help" : {
            "text" : "To ease development and increase productivity, most modern frameworks allow an object to be automatically instantiated and populated with the HTTP request parameters whose names match an attribute of the class to be bound. Automatic instantiation and population of objects speeds up development, but can lead to serious problems if implemented without caution. Any attribute in the bound classes, or nested classes, will be automatically bound to the HTTP request parameters. Therefore, malicious users will be able to assign a value to any attribute in bound or nested classes, even if they are not exposed to the client through web forms or API contracts.\n\nExample 1: Using Spring MVC with no additional configuration, the following controller method will bind the HTTP request parameters to any attribute in the User or Details classes:\n\n\n@RequestMapping(method = RequestMethod.POST)\npublic String registerUser(@ModelAttribute(\"user\") User user, BindingResult result, SessionStatus status) {\nif (db.save(user).hasErrors()) {\nreturn \"CustomerForm\";\n} else {\nstatus.setComplete();\nreturn \"CustomerSuccess\";\n}\n}\n\n\nWhere User class is defined as:\n\n\npublic class User {\nprivate String name;\nprivate String lastname;\nprivate int age;\nprivate Details details;\n\n// Public Getters and Setters\n...\n}\n\n\nand Details class is defined as:\n\n\npublic class Details {\nprivate boolean is_admin;\nprivate int id;\nprivate Date login_date;\n\n// Public Getters and Setters\n...\n}\n\n\n\nWhen using frameworks that provide automatic model binding capabilities, it is a best practice to control which attributes will be bound to the model object so that even if attackers figure out other non-exposed attributes of the model or nested classes, they will not be able to bind arbitrary values from HTTP request parameters.\n\nDepending on the framework used there will be different ways to control the model binding process:\n\nSpring MVC: \n\nIt is possible to control which HTTP request parameters will be used in the binding process and which ones will be ignored.\n\nIn Spring MVC applications using @ModelAttribute annotated parameters, the binder can be configured to control which attributes should be bound. In order to do so, a method can be annotated with @InitBinder so that the framework will inject a reference to the Spring Model Binder. The Spring Model Binder can be configured to control the attribute binding process with the setAllowedFields and setDisallowedFields methods. Spring MVC applications extending BaseCommandController can override the initBinder(HttpServletRequest request, ServletRequestDataBinder binder) method in order to get a reference to the Spring Model Binder.\n\nExample 2: The Spring Model Binder (3.x) is configured to disallow the binding of sensitive attributes:\n\n\nfinal String[] DISALLOWED_FIELDS = new String[]{\"details.role\", \"details.age\", \"is_admin\"};\n\n@InitBinder\npublic void initBinder(WebDataBinder binder) {\nbinder.setDisallowedFields(DISALLOWED_FIELDS);\n}\n\n\nExample 3: The Spring Model Binder (2.x) is configured to disallow the binding of sensitive attributes:\n\n\n@Override\nprotected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {\nbinder.setDisallowedFields(new String[]{\"details.role\", \"details.age\", \"is_admin\"});\n}\n\n\nIn Spring MVC Applications using @RequestBody annotated parameters, the binding process is handled by HttpMessageConverter instances which will use libraries such as Jackson and JAXB to convert the HTTP request body into Java Objects. These libraries offer annotations to control which fields should be allowed or disallowed. For example, for the Jackson JSON library, the @JsonIgnore annotation can be used to prevent a field from being bound to the request.\n\nExample 4: A controller method binds an HTTP request to an instance of the Employee class using the @RequestBody annotation.\n\n\n@RequestMapping(value=\"/add/employee\", method=RequestMethod.POST, consumes=\"text/html\")\npublic void addEmployee(@RequestBody Employee employee){\n// Do something with the employee object.\n}\n\n\nThe application uses the default Jackson HttpMessageConverter to bind JSON HTTP requests to the Employee class. In order to prevent the binding of the is_admin sensitive field, use the @JsonIgnore annotation:\n\n\npublic class Employee {\n\n@JsonIgnore\nprivate boolean is_admin;\n...\n\n// Public Getters and Setters\n...\n}\n\n\nNote: Check the following REST frameworks information for more details on how to configure Jackson and JAXB annotations.\n\nApache Struts: \n\nStruts 1 and 2 will only bind HTTP request parameters to those Actions or ActionForms attributes which have an associated public setter accessor. If an attribute should not be bound to the request, its setter should be made private.\n\nExample 5: Configure a private setter so that Struts framework will not automatically bind any HTTP request parameter:\n\n\nprivate String role;\nprivate void setRole(String role)  {\nthis.role = role;\n}\n\n\nREST frameworks: \n\nMost REST frameworks will automatically bind any HTTP request bodies with content type JSON or XML to a model object. Depending on the libraries used for JSON and XML processing, there will be different ways of controlling the binding process. The following are some examples for JAXB (XML) and Jackson (JSON):\n\nExample 6: Models bound from XML documents using Oracle's JAXB library can control the binding process using different annotations such as @XmlAccessorType, @XmlAttribute, @XmlElement and @XmlTransient. The binder can be told not to bind any attributes by default, by annotating the models using the @XmlAccessorType annotation with the value XmlAccessType.NONE and then selecting which fields should be bound using @XmlAttribute and @XmlElement annotations:\n\n\n@XmlRootElement\n@XmlAccessorType(XmlAccessType.NONE)\npublic class User {\nprivate String role;\nprivate String name;\n@XmlAttribute\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nExample 7: Models bound from JSON documents using the Jackson library can control the binding process using different annotations such as @JsonIgnore, @JsonIgnoreProperties, @JsonIgnoreType and @JsonInclude. The binder can be told to ignore certain attributes by annotating them with @JsonIgnore annotation:\n\n\npublic class User {\n\n@JsonIgnore\nprivate String role;\nprivate String name;\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nA different approach to protecting against mass assignment vulnerabilities is using a layered architecture where the HTTP request parameters are bound to DTO objects. The DTO objects are only used for that purpose, exposing only those attributes defined in the web forms or API contracts, and then mapping these DTO objects to Domain Objects where the rest of the private attributes can be defined.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/d6bba8f7-abda-4582-9577-3862a921da55"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "14220183",
          "shortDescription" : {
            "text" : "Mass Assignment: Insecure Binder Configuration"
          },
          "fullDescription" : {
            "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 143 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
          },
          "help" : {
            "text" : "To ease development and increase productivity, most modern frameworks allow an object to be automatically instantiated and populated with the HTTP request parameters whose names match an attribute of the class to be bound. Automatic instantiation and population of objects speeds up development, but can lead to serious problems if implemented without caution. Any attribute in the bound classes, or nested classes, will be automatically bound to the HTTP request parameters. Therefore, malicious users will be able to assign a value to any attribute in bound or nested classes, even if they are not exposed to the client through web forms or API contracts.\n\nExample 1: Using Spring MVC with no additional configuration, the following controller method will bind the HTTP request parameters to any attribute in the User or Details classes:\n\n\n@RequestMapping(method = RequestMethod.POST)\npublic String registerUser(@ModelAttribute(\"user\") User user, BindingResult result, SessionStatus status) {\nif (db.save(user).hasErrors()) {\nreturn \"CustomerForm\";\n} else {\nstatus.setComplete();\nreturn \"CustomerSuccess\";\n}\n}\n\n\nWhere User class is defined as:\n\n\npublic class User {\nprivate String name;\nprivate String lastname;\nprivate int age;\nprivate Details details;\n\n// Public Getters and Setters\n...\n}\n\n\nand Details class is defined as:\n\n\npublic class Details {\nprivate boolean is_admin;\nprivate int id;\nprivate Date login_date;\n\n// Public Getters and Setters\n...\n}\n\n\n\nWhen using frameworks that provide automatic model binding capabilities, it is a best practice to control which attributes will be bound to the model object so that even if attackers figure out other non-exposed attributes of the model or nested classes, they will not be able to bind arbitrary values from HTTP request parameters.\n\nDepending on the framework used there will be different ways to control the model binding process:\n\nSpring MVC: \n\nIt is possible to control which HTTP request parameters will be used in the binding process and which ones will be ignored.\n\nIn Spring MVC applications using @ModelAttribute annotated parameters, the binder can be configured to control which attributes should be bound. In order to do so, a method can be annotated with @InitBinder so that the framework will inject a reference to the Spring Model Binder. The Spring Model Binder can be configured to control the attribute binding process with the setAllowedFields and setDisallowedFields methods. Spring MVC applications extending BaseCommandController can override the initBinder(HttpServletRequest request, ServletRequestDataBinder binder) method in order to get a reference to the Spring Model Binder.\n\nExample 2: The Spring Model Binder (3.x) is configured to disallow the binding of sensitive attributes:\n\n\nfinal String[] DISALLOWED_FIELDS = new String[]{\"details.role\", \"details.age\", \"is_admin\"};\n\n@InitBinder\npublic void initBinder(WebDataBinder binder) {\nbinder.setDisallowedFields(DISALLOWED_FIELDS);\n}\n\n\nExample 3: The Spring Model Binder (2.x) is configured to disallow the binding of sensitive attributes:\n\n\n@Override\nprotected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {\nbinder.setDisallowedFields(new String[]{\"details.role\", \"details.age\", \"is_admin\"});\n}\n\n\nIn Spring MVC Applications using @RequestBody annotated parameters, the binding process is handled by HttpMessageConverter instances which will use libraries such as Jackson and JAXB to convert the HTTP request body into Java Objects. These libraries offer annotations to control which fields should be allowed or disallowed. For example, for the Jackson JSON library, the @JsonIgnore annotation can be used to prevent a field from being bound to the request.\n\nExample 4: A controller method binds an HTTP request to an instance of the Employee class using the @RequestBody annotation.\n\n\n@RequestMapping(value=\"/add/employee\", method=RequestMethod.POST, consumes=\"text/html\")\npublic void addEmployee(@RequestBody Employee employee){\n// Do something with the employee object.\n}\n\n\nThe application uses the default Jackson HttpMessageConverter to bind JSON HTTP requests to the Employee class. In order to prevent the binding of the is_admin sensitive field, use the @JsonIgnore annotation:\n\n\npublic class Employee {\n\n@JsonIgnore\nprivate boolean is_admin;\n...\n\n// Public Getters and Setters\n...\n}\n\n\nNote: Check the following REST frameworks information for more details on how to configure Jackson and JAXB annotations.\n\nApache Struts: \n\nStruts 1 and 2 will only bind HTTP request parameters to those Actions or ActionForms attributes which have an associated public setter accessor. If an attribute should not be bound to the request, its setter should be made private.\n\nExample 5: Configure a private setter so that Struts framework will not automatically bind any HTTP request parameter:\n\n\nprivate String role;\nprivate void setRole(String role)  {\nthis.role = role;\n}\n\n\nREST frameworks: \n\nMost REST frameworks will automatically bind any HTTP request bodies with content type JSON or XML to a model object. Depending on the libraries used for JSON and XML processing, there will be different ways of controlling the binding process. The following are some examples for JAXB (XML) and Jackson (JSON):\n\nExample 6: Models bound from XML documents using Oracle's JAXB library can control the binding process using different annotations such as @XmlAccessorType, @XmlAttribute, @XmlElement and @XmlTransient. The binder can be told not to bind any attributes by default, by annotating the models using the @XmlAccessorType annotation with the value XmlAccessType.NONE and then selecting which fields should be bound using @XmlAttribute and @XmlElement annotations:\n\n\n@XmlRootElement\n@XmlAccessorType(XmlAccessType.NONE)\npublic class User {\nprivate String role;\nprivate String name;\n@XmlAttribute\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nExample 7: Models bound from JSON documents using the Jackson library can control the binding process using different annotations such as @JsonIgnore, @JsonIgnoreProperties, @JsonIgnoreType and @JsonInclude. The binder can be told to ignore certain attributes by annotating them with @JsonIgnore annotation:\n\n\npublic class User {\n\n@JsonIgnore\nprivate String role;\nprivate String name;\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nA different approach to protecting against mass assignment vulnerabilities is using a layered architecture where the HTTP request parameters are bound to DTO objects. The DTO objects are only used for that purpose, exposing only those attributes defined in the web forms or API contracts, and then mapping these DTO objects to Domain Objects where the rest of the private attributes can be defined.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/2efcf6eb-44b1-49ca-9818-2f0c5660d37a"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "11445540",
          "shortDescription" : {
            "text" : "Mass Assignment: Insecure Binder Configuration"
          },
          "fullDescription" : {
            "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 162 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
          },
          "help" : {
            "text" : "To ease development and increase productivity, most modern frameworks allow an object to be automatically instantiated and populated with the HTTP request parameters whose names match an attribute of the class to be bound. Automatic instantiation and population of objects speeds up development, but can lead to serious problems if implemented without caution. Any attribute in the bound classes, or nested classes, will be automatically bound to the HTTP request parameters. Therefore, malicious users will be able to assign a value to any attribute in bound or nested classes, even if they are not exposed to the client through web forms or API contracts.\n\nExample 1: Using Spring MVC with no additional configuration, the following controller method will bind the HTTP request parameters to any attribute in the User or Details classes:\n\n\n@RequestMapping(method = RequestMethod.POST)\npublic String registerUser(@ModelAttribute(\"user\") User user, BindingResult result, SessionStatus status) {\nif (db.save(user).hasErrors()) {\nreturn \"CustomerForm\";\n} else {\nstatus.setComplete();\nreturn \"CustomerSuccess\";\n}\n}\n\n\nWhere User class is defined as:\n\n\npublic class User {\nprivate String name;\nprivate String lastname;\nprivate int age;\nprivate Details details;\n\n// Public Getters and Setters\n...\n}\n\n\nand Details class is defined as:\n\n\npublic class Details {\nprivate boolean is_admin;\nprivate int id;\nprivate Date login_date;\n\n// Public Getters and Setters\n...\n}\n\n\n\nWhen using frameworks that provide automatic model binding capabilities, it is a best practice to control which attributes will be bound to the model object so that even if attackers figure out other non-exposed attributes of the model or nested classes, they will not be able to bind arbitrary values from HTTP request parameters.\n\nDepending on the framework used there will be different ways to control the model binding process:\n\nSpring MVC: \n\nIt is possible to control which HTTP request parameters will be used in the binding process and which ones will be ignored.\n\nIn Spring MVC applications using @ModelAttribute annotated parameters, the binder can be configured to control which attributes should be bound. In order to do so, a method can be annotated with @InitBinder so that the framework will inject a reference to the Spring Model Binder. The Spring Model Binder can be configured to control the attribute binding process with the setAllowedFields and setDisallowedFields methods. Spring MVC applications extending BaseCommandController can override the initBinder(HttpServletRequest request, ServletRequestDataBinder binder) method in order to get a reference to the Spring Model Binder.\n\nExample 2: The Spring Model Binder (3.x) is configured to disallow the binding of sensitive attributes:\n\n\nfinal String[] DISALLOWED_FIELDS = new String[]{\"details.role\", \"details.age\", \"is_admin\"};\n\n@InitBinder\npublic void initBinder(WebDataBinder binder) {\nbinder.setDisallowedFields(DISALLOWED_FIELDS);\n}\n\n\nExample 3: The Spring Model Binder (2.x) is configured to disallow the binding of sensitive attributes:\n\n\n@Override\nprotected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {\nbinder.setDisallowedFields(new String[]{\"details.role\", \"details.age\", \"is_admin\"});\n}\n\n\nIn Spring MVC Applications using @RequestBody annotated parameters, the binding process is handled by HttpMessageConverter instances which will use libraries such as Jackson and JAXB to convert the HTTP request body into Java Objects. These libraries offer annotations to control which fields should be allowed or disallowed. For example, for the Jackson JSON library, the @JsonIgnore annotation can be used to prevent a field from being bound to the request.\n\nExample 4: A controller method binds an HTTP request to an instance of the Employee class using the @RequestBody annotation.\n\n\n@RequestMapping(value=\"/add/employee\", method=RequestMethod.POST, consumes=\"text/html\")\npublic void addEmployee(@RequestBody Employee employee){\n// Do something with the employee object.\n}\n\n\nThe application uses the default Jackson HttpMessageConverter to bind JSON HTTP requests to the Employee class. In order to prevent the binding of the is_admin sensitive field, use the @JsonIgnore annotation:\n\n\npublic class Employee {\n\n@JsonIgnore\nprivate boolean is_admin;\n...\n\n// Public Getters and Setters\n...\n}\n\n\nNote: Check the following REST frameworks information for more details on how to configure Jackson and JAXB annotations.\n\nApache Struts: \n\nStruts 1 and 2 will only bind HTTP request parameters to those Actions or ActionForms attributes which have an associated public setter accessor. If an attribute should not be bound to the request, its setter should be made private.\n\nExample 5: Configure a private setter so that Struts framework will not automatically bind any HTTP request parameter:\n\n\nprivate String role;\nprivate void setRole(String role)  {\nthis.role = role;\n}\n\n\nREST frameworks: \n\nMost REST frameworks will automatically bind any HTTP request bodies with content type JSON or XML to a model object. Depending on the libraries used for JSON and XML processing, there will be different ways of controlling the binding process. The following are some examples for JAXB (XML) and Jackson (JSON):\n\nExample 6: Models bound from XML documents using Oracle's JAXB library can control the binding process using different annotations such as @XmlAccessorType, @XmlAttribute, @XmlElement and @XmlTransient. The binder can be told not to bind any attributes by default, by annotating the models using the @XmlAccessorType annotation with the value XmlAccessType.NONE and then selecting which fields should be bound using @XmlAttribute and @XmlElement annotations:\n\n\n@XmlRootElement\n@XmlAccessorType(XmlAccessType.NONE)\npublic class User {\nprivate String role;\nprivate String name;\n@XmlAttribute\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nExample 7: Models bound from JSON documents using the Jackson library can control the binding process using different annotations such as @JsonIgnore, @JsonIgnoreProperties, @JsonIgnoreType and @JsonInclude. The binder can be told to ignore certain attributes by annotating them with @JsonIgnore annotation:\n\n\npublic class User {\n\n@JsonIgnore\nprivate String role;\nprivate String name;\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nA different approach to protecting against mass assignment vulnerabilities is using a layered architecture where the HTTP request parameters are bound to DTO objects. The DTO objects are only used for that purpose, exposing only those attributes defined in the web forms or API contracts, and then mapping these DTO objects to Domain Objects where the rest of the private attributes can be defined.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/371abc6b-9815-44b6-a08b-a7ab60c6d58f"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "14220185",
          "shortDescription" : {
            "text" : "Mass Assignment: Insecure Binder Configuration"
          },
          "fullDescription" : {
            "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 175 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
          },
          "help" : {
            "text" : "To ease development and increase productivity, most modern frameworks allow an object to be automatically instantiated and populated with the HTTP request parameters whose names match an attribute of the class to be bound. Automatic instantiation and population of objects speeds up development, but can lead to serious problems if implemented without caution. Any attribute in the bound classes, or nested classes, will be automatically bound to the HTTP request parameters. Therefore, malicious users will be able to assign a value to any attribute in bound or nested classes, even if they are not exposed to the client through web forms or API contracts.\n\nExample 1: Using Spring MVC with no additional configuration, the following controller method will bind the HTTP request parameters to any attribute in the User or Details classes:\n\n\n@RequestMapping(method = RequestMethod.POST)\npublic String registerUser(@ModelAttribute(\"user\") User user, BindingResult result, SessionStatus status) {\nif (db.save(user).hasErrors()) {\nreturn \"CustomerForm\";\n} else {\nstatus.setComplete();\nreturn \"CustomerSuccess\";\n}\n}\n\n\nWhere User class is defined as:\n\n\npublic class User {\nprivate String name;\nprivate String lastname;\nprivate int age;\nprivate Details details;\n\n// Public Getters and Setters\n...\n}\n\n\nand Details class is defined as:\n\n\npublic class Details {\nprivate boolean is_admin;\nprivate int id;\nprivate Date login_date;\n\n// Public Getters and Setters\n...\n}\n\n\n\nWhen using frameworks that provide automatic model binding capabilities, it is a best practice to control which attributes will be bound to the model object so that even if attackers figure out other non-exposed attributes of the model or nested classes, they will not be able to bind arbitrary values from HTTP request parameters.\n\nDepending on the framework used there will be different ways to control the model binding process:\n\nSpring MVC: \n\nIt is possible to control which HTTP request parameters will be used in the binding process and which ones will be ignored.\n\nIn Spring MVC applications using @ModelAttribute annotated parameters, the binder can be configured to control which attributes should be bound. In order to do so, a method can be annotated with @InitBinder so that the framework will inject a reference to the Spring Model Binder. The Spring Model Binder can be configured to control the attribute binding process with the setAllowedFields and setDisallowedFields methods. Spring MVC applications extending BaseCommandController can override the initBinder(HttpServletRequest request, ServletRequestDataBinder binder) method in order to get a reference to the Spring Model Binder.\n\nExample 2: The Spring Model Binder (3.x) is configured to disallow the binding of sensitive attributes:\n\n\nfinal String[] DISALLOWED_FIELDS = new String[]{\"details.role\", \"details.age\", \"is_admin\"};\n\n@InitBinder\npublic void initBinder(WebDataBinder binder) {\nbinder.setDisallowedFields(DISALLOWED_FIELDS);\n}\n\n\nExample 3: The Spring Model Binder (2.x) is configured to disallow the binding of sensitive attributes:\n\n\n@Override\nprotected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {\nbinder.setDisallowedFields(new String[]{\"details.role\", \"details.age\", \"is_admin\"});\n}\n\n\nIn Spring MVC Applications using @RequestBody annotated parameters, the binding process is handled by HttpMessageConverter instances which will use libraries such as Jackson and JAXB to convert the HTTP request body into Java Objects. These libraries offer annotations to control which fields should be allowed or disallowed. For example, for the Jackson JSON library, the @JsonIgnore annotation can be used to prevent a field from being bound to the request.\n\nExample 4: A controller method binds an HTTP request to an instance of the Employee class using the @RequestBody annotation.\n\n\n@RequestMapping(value=\"/add/employee\", method=RequestMethod.POST, consumes=\"text/html\")\npublic void addEmployee(@RequestBody Employee employee){\n// Do something with the employee object.\n}\n\n\nThe application uses the default Jackson HttpMessageConverter to bind JSON HTTP requests to the Employee class. In order to prevent the binding of the is_admin sensitive field, use the @JsonIgnore annotation:\n\n\npublic class Employee {\n\n@JsonIgnore\nprivate boolean is_admin;\n...\n\n// Public Getters and Setters\n...\n}\n\n\nNote: Check the following REST frameworks information for more details on how to configure Jackson and JAXB annotations.\n\nApache Struts: \n\nStruts 1 and 2 will only bind HTTP request parameters to those Actions or ActionForms attributes which have an associated public setter accessor. If an attribute should not be bound to the request, its setter should be made private.\n\nExample 5: Configure a private setter so that Struts framework will not automatically bind any HTTP request parameter:\n\n\nprivate String role;\nprivate void setRole(String role)  {\nthis.role = role;\n}\n\n\nREST frameworks: \n\nMost REST frameworks will automatically bind any HTTP request bodies with content type JSON or XML to a model object. Depending on the libraries used for JSON and XML processing, there will be different ways of controlling the binding process. The following are some examples for JAXB (XML) and Jackson (JSON):\n\nExample 6: Models bound from XML documents using Oracle's JAXB library can control the binding process using different annotations such as @XmlAccessorType, @XmlAttribute, @XmlElement and @XmlTransient. The binder can be told not to bind any attributes by default, by annotating the models using the @XmlAccessorType annotation with the value XmlAccessType.NONE and then selecting which fields should be bound using @XmlAttribute and @XmlElement annotations:\n\n\n@XmlRootElement\n@XmlAccessorType(XmlAccessType.NONE)\npublic class User {\nprivate String role;\nprivate String name;\n@XmlAttribute\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nExample 7: Models bound from JSON documents using the Jackson library can control the binding process using different annotations such as @JsonIgnore, @JsonIgnoreProperties, @JsonIgnoreType and @JsonInclude. The binder can be told to ignore certain attributes by annotating them with @JsonIgnore annotation:\n\n\npublic class User {\n\n@JsonIgnore\nprivate String role;\nprivate String name;\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nA different approach to protecting against mass assignment vulnerabilities is using a layered architecture where the HTTP request parameters are bound to DTO objects. The DTO objects are only used for that purpose, exposing only those attributes defined in the web forms or API contracts, and then mapping these DTO objects to Domain Objects where the rest of the private attributes can be defined.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/3c941188-2342-45f3-bba5-308103c34550"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "22300899",
          "shortDescription" : {
            "text" : "Mass Assignment: Insecure Binder Configuration"
          },
          "fullDescription" : {
            "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 534 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
          },
          "help" : {
            "text" : "To ease development and increase productivity, most modern frameworks allow an object to be automatically instantiated and populated with the HTTP request parameters whose names match an attribute of the class to be bound. Automatic instantiation and population of objects speeds up development, but can lead to serious problems if implemented without caution. Any attribute in the bound classes, or nested classes, will be automatically bound to the HTTP request parameters. Therefore, malicious users will be able to assign a value to any attribute in bound or nested classes, even if they are not exposed to the client through web forms or API contracts.\n\nExample 1: Using Spring MVC with no additional configuration, the following controller method will bind the HTTP request parameters to any attribute in the User or Details classes:\n\n\n@RequestMapping(method = RequestMethod.POST)\npublic String registerUser(@ModelAttribute(\"user\") User user, BindingResult result, SessionStatus status) {\nif (db.save(user).hasErrors()) {\nreturn \"CustomerForm\";\n} else {\nstatus.setComplete();\nreturn \"CustomerSuccess\";\n}\n}\n\n\nWhere User class is defined as:\n\n\npublic class User {\nprivate String name;\nprivate String lastname;\nprivate int age;\nprivate Details details;\n\n// Public Getters and Setters\n...\n}\n\n\nand Details class is defined as:\n\n\npublic class Details {\nprivate boolean is_admin;\nprivate int id;\nprivate Date login_date;\n\n// Public Getters and Setters\n...\n}\n\n\n\nWhen using frameworks that provide automatic model binding capabilities, it is a best practice to control which attributes will be bound to the model object so that even if attackers figure out other non-exposed attributes of the model or nested classes, they will not be able to bind arbitrary values from HTTP request parameters.\n\nDepending on the framework used there will be different ways to control the model binding process:\n\nSpring MVC: \n\nIt is possible to control which HTTP request parameters will be used in the binding process and which ones will be ignored.\n\nIn Spring MVC applications using @ModelAttribute annotated parameters, the binder can be configured to control which attributes should be bound. In order to do so, a method can be annotated with @InitBinder so that the framework will inject a reference to the Spring Model Binder. The Spring Model Binder can be configured to control the attribute binding process with the setAllowedFields and setDisallowedFields methods. Spring MVC applications extending BaseCommandController can override the initBinder(HttpServletRequest request, ServletRequestDataBinder binder) method in order to get a reference to the Spring Model Binder.\n\nExample 2: The Spring Model Binder (3.x) is configured to disallow the binding of sensitive attributes:\n\n\nfinal String[] DISALLOWED_FIELDS = new String[]{\"details.role\", \"details.age\", \"is_admin\"};\n\n@InitBinder\npublic void initBinder(WebDataBinder binder) {\nbinder.setDisallowedFields(DISALLOWED_FIELDS);\n}\n\n\nExample 3: The Spring Model Binder (2.x) is configured to disallow the binding of sensitive attributes:\n\n\n@Override\nprotected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {\nbinder.setDisallowedFields(new String[]{\"details.role\", \"details.age\", \"is_admin\"});\n}\n\n\nIn Spring MVC Applications using @RequestBody annotated parameters, the binding process is handled by HttpMessageConverter instances which will use libraries such as Jackson and JAXB to convert the HTTP request body into Java Objects. These libraries offer annotations to control which fields should be allowed or disallowed. For example, for the Jackson JSON library, the @JsonIgnore annotation can be used to prevent a field from being bound to the request.\n\nExample 4: A controller method binds an HTTP request to an instance of the Employee class using the @RequestBody annotation.\n\n\n@RequestMapping(value=\"/add/employee\", method=RequestMethod.POST, consumes=\"text/html\")\npublic void addEmployee(@RequestBody Employee employee){\n// Do something with the employee object.\n}\n\n\nThe application uses the default Jackson HttpMessageConverter to bind JSON HTTP requests to the Employee class. In order to prevent the binding of the is_admin sensitive field, use the @JsonIgnore annotation:\n\n\npublic class Employee {\n\n@JsonIgnore\nprivate boolean is_admin;\n...\n\n// Public Getters and Setters\n...\n}\n\n\nNote: Check the following REST frameworks information for more details on how to configure Jackson and JAXB annotations.\n\nApache Struts: \n\nStruts 1 and 2 will only bind HTTP request parameters to those Actions or ActionForms attributes which have an associated public setter accessor. If an attribute should not be bound to the request, its setter should be made private.\n\nExample 5: Configure a private setter so that Struts framework will not automatically bind any HTTP request parameter:\n\n\nprivate String role;\nprivate void setRole(String role)  {\nthis.role = role;\n}\n\n\nREST frameworks: \n\nMost REST frameworks will automatically bind any HTTP request bodies with content type JSON or XML to a model object. Depending on the libraries used for JSON and XML processing, there will be different ways of controlling the binding process. The following are some examples for JAXB (XML) and Jackson (JSON):\n\nExample 6: Models bound from XML documents using Oracle's JAXB library can control the binding process using different annotations such as @XmlAccessorType, @XmlAttribute, @XmlElement and @XmlTransient. The binder can be told not to bind any attributes by default, by annotating the models using the @XmlAccessorType annotation with the value XmlAccessType.NONE and then selecting which fields should be bound using @XmlAttribute and @XmlElement annotations:\n\n\n@XmlRootElement\n@XmlAccessorType(XmlAccessType.NONE)\npublic class User {\nprivate String role;\nprivate String name;\n@XmlAttribute\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nExample 7: Models bound from JSON documents using the Jackson library can control the binding process using different annotations such as @JsonIgnore, @JsonIgnoreProperties, @JsonIgnoreType and @JsonInclude. The binder can be told to ignore certain attributes by annotating them with @JsonIgnore annotation:\n\n\npublic class User {\n\n@JsonIgnore\nprivate String role;\nprivate String name;\npublic String getName() {\nreturn name;\n}\npublic void setName(String name) {\nthis.name = name;\n}\npublic String getRole() {\nreturn role;\n}\npublic void setRole(String role) {\nthis.role = role;\n}\n\n\nA different approach to protecting against mass assignment vulnerabilities is using a layered architecture where the HTTP request parameters are bound to DTO objects. The DTO objects are only used for that purpose, exposing only those attributes defined in the web forms or API contracts, and then mapping these DTO objects to Domain Objects where the rest of the private attributes can be defined.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/8b1544f9-4504-4765-8773-8b50fc0d1129"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "24851298",
          "shortDescription" : {
            "text" : "Null Dereference"
          },
          "fullDescription" : {
            "text" : "The method getTargetUrl() in CustomAuthenticationSuccessHandler.java can crash the program by dereferencing a null-pointer on line 122.The program can potentially dereference a null-pointer, thereby causing a null-pointer exception."
          },
          "help" : {
            "text" : "Null-pointer exceptions usually occur when one or more of the programmer's assumptions is violated. A dereference-after-store error occurs when a program explicitly sets an object to null and dereferences it later. This error is often the result of a programmer initializing a variable to null when it is declared.\n\n\nIn this case, the variable can be null when it is dereferenced on line 122, thereby causing a null-pointer exception.\n\nMost null-pointer issues result in general software reliability problems, but if attackers can intentionally trigger a null-pointer dereference, they can use the resulting exception to bypass security logic or to cause the application to reveal debugging information that will be valuable in planning subsequent attacks.\n\nExample: In the following code, the programmer explicitly sets the variable foo to null. Later, the programmer dereferences foo before checking the object for a null value.\n\n\nFoo foo = null;\n...\nfoo.setBar(val);\n...\n}\n\n\nImplement careful checks before dereferencing objects that might be null. When possible, abstract null checks into wrappers around code that manipulates resources to ensure that they are applied in all cases and to minimize the places where mistakes can occur.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/546a7e86-b598-45bf-9f8e-f2ba7fee0134"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "25337207",
          "shortDescription" : {
            "text" : "Open Redirect"
          },
          "fullDescription" : {
            "text" : "The file DefaultController.java passes unvalidated data to an HTTP redirect function on line 166. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks."
          },
          "help" : {
            "text" : "Redirects allow web applications to direct users to different pages within the same application or to external sites. Applications utilize redirects to aid in site navigation and, in some cases, to track how users exit the site. Open redirect vulnerabilities occur when a web application redirects clients to any arbitrary URL that can be controlled by an attacker.\n\nAttackers might utilize open redirects to trick users into visiting a URL to a trusted site, but then redirecting them to a malicious site. By encoding the URL, an attacker can make it difficult for end-users to notice the malicious destination of the redirect, even when it is passed as a URL parameter to the trusted site. Open redirects are often abused as part of phishing scams to harvest sensitive end-user data.\n\n\nIn this case, the URL the client will be redirected to is accepted at getHeader() in DefaultController.java on line 98.\n\n\nThe data is sent at  in DefaultController.java on line 166.\n\n\nExample 1: The following JSP code instructs the user's browser to open a URL parsed from the dest request parameter when a user clicks the link.\n\n\n&lt;%\n...\nString strDest = request.getParameter(\"dest\");\npageContext.forward(strDest);\n...\n%&gt;\n\n\nIf a victim received an email instructing them to follow a link to \"http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com\", the user would likely click on the link believing they would be transferred to the trusted site. However, when the victim clicks the link, the code in Example 1 will redirect the browser to \"http://www.wilyhacker.com\".\n\nMany users have been educated to always inspect URLs they receive in emails to make sure the link specifies a trusted site they know. However, if the attacker Hex encoded the destination url as follows:\n\"http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D\"\n\nthen even a savvy end-user may be fooled into following the link.\n\nUnvalidated user input should not be allowed to control the destination URL in a redirect. Instead, use a level of indirection: create a list of legitimate URLs that users are allowed to specify and only allow users to select from the list. With this approach, input provided by users is never used directly to specify a URL for redirects.\n\nExample 2: The following code references an array populated with valid URLs. The link the user clicks passes in the array index that corresponds to the desired URL.\n\n\n&lt;%\n...\ntry {\nint strDest = Integer.parseInt(request.getParameter(\"dest\"));\nif((strDest &gt;= 0) &amp;&amp; (strDest &lt;= strURLArray.length -1 ))\n{\nstrFinalURL = strURLArray[strDest];\npageContext.forward(strFinalURL);\n}\n}\ncatch (NumberFormatException nfe) {\n// Handle exception\n...\n}\n...\n%&gt;\n\n\nIn some situations this approach is impractical because the set of legitimate URLs is too large or too hard to keep track of. In such cases, use a similar approach to restrict the domains that users can be redirected to, which can at least prevent attackers from sending users to malicious external sites.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/402b395c-ebab-459f-8271-ce7c7fd7d3b1"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "13078270",
          "shortDescription" : {
            "text" : "Password Management: Hardcoded Password"
          },
          "fullDescription" : {
            "text" : "Hardcoded passwords can compromise system security in a way that is not easy to remedy."
          },
          "help" : {
            "text" : "It is never a good idea to hardcode a password. Not only does hardcoding a password allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. After the code is in production, the password cannot be changed without patching the software. If the account protected by the password is compromised, the owners of the system must choose between security and availability.\n\nIn this case, a hardcoded password was found in the call to  in PasswordConstraintValidator.java on line 59.\n\n\nExample 1: The following code uses a hardcoded password to connect to a database:\n\n\n...\nDriverManager.getConnection(url, \"scott\", \"tiger\");\n...\n\n\nThis code will run successfully, but anyone who has access to it will have access to the password. After the program ships, there is likely no way to change the database user \"scott\" with a password of \"tiger\" unless the program is patched. An employee with access to this information can use it to break into the system. Even worse, if attackers have access to the bytecode for the application they can use the javap -c command to access the disassembled code, which will contain the values of the passwords used. The result of this operation might look something like the following for Example 1:\n\n\njavap -c ConnMngr.class\n\n22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql\n24: ldc   #38; //String scott\n26: ldc   #17; //String tiger\n\n\nIn the mobile environment, password management is especially important given that there is such a high chance of device loss.\nExample 2: The following code uses hardcoded username and password to setup authentication for viewing protected pages with Android's WebView.\n\n...\nwebview.setWebViewClient(new WebViewClient() {\npublic void onReceivedHttpAuthRequest(WebView view,\nHttpAuthHandler handler, String host, String realm) {\nhandler.proceed(\"guest\", \"allow\");\n}\n});\n...\n\n\nSimilar to Example 1, this code will run successfully, but anyone who has access to it will have access to the password.\n\nPasswords should never be hardcoded and should generally be obfuscated and managed in an external source. Storing passwords in plain text anywhere on the system allows anyone with sufficient permissions to read and potentially misuse the password. At the very least, hash passwords before storing them.\n\nSome third-party products claim the ability to securely manage passwords. For example, WebSphere Application Server 4.x uses a simple XOR encryption algorithm for obfuscating values, but be skeptical about such facilities. WebSphere and other application servers offer outdated and relatively weak encryption mechanisms that are insufficient for security-sensitive environments. Today, the best option for a secure generic solution is to create a proprietary mechanism yourself.\n\nFor Android, as well as any other platform that uses SQLite database, SQLCipher is a good alternative. SQLCipher is an extension to the SQLite database that provides transparent 256-bit AES encryption of database files. Thus, credentials can be stored in an encrypted database.\n\nExample 3: The following code demonstrates how to integrate SQLCipher into an Android application after downloading the necessary binaries, and store credentials into the database file.\n\nimport net.sqlcipher.database.SQLiteDatabase;\n...\nSQLiteDatabase.loadLibs(this);\nFile dbFile = getDatabasePath(\"credentials.db\");\ndbFile.mkdirs();\ndbFile.delete();\nSQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, \"credentials\", null);\ndb.execSQL(\"create table credentials(u, p)\");\ndb.execSQL(\"insert into credentials(u, p) values(?, ?)\", new Object[]{username, password});\n...\n\n\nNote that references to android.database.sqlite.SQLiteDatabase are substituted with those of net.sqlcipher.database.SQLiteDatabase.\n\nTo enable encryption on the WebView store, you must recompile WebKit with the sqlcipher.so library.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/919b6548-a2ca-4bac-9250-863f9fbcb274"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "24780819",
          "shortDescription" : {
            "text" : "Password Management: Password in Configuration File"
          },
          "fullDescription" : {
            "text" : "Storing a plain text password in a configuration file may result in a system compromise."
          },
          "help" : {
            "text" : "Storing a plain text password in a configuration file allows anyone who can read the file access to the password-protected resource. Developers sometimes believe that they cannot defend the application from someone who has access to the configuration, but this attitude makes an attacker's job easier. Good password management guidelines require that a password never be stored in plain text.\n\n\nIn this case, a hardcoded password exists in application.yml on line 38.\n\n\nA password should never be stored in plain text. An administrator should be required to enter the password when the system starts. If that approach is impractical, a less secure but often adequate solution is to obfuscate the password and scatter the de-obfuscation material around the system so that an attacker has to obtain and correctly combine multiple system resources to decipher the password.\n\nSome third-party products claim the ability to manage passwords in a more secure way. For example, WebSphere Application Server 4.x uses a simple XOR encryption algorithm for obfuscating values, but be skeptical about such facilities. WebSphere and other application servers offer outdated and relatively weak encryption mechanisms that are insufficient for security-sensitive environments. For a secure solution the only viable option is a proprietary one.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/cd90bfa2-f159-4fdf-91cb-dc004fd61351"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "24780820",
          "shortDescription" : {
            "text" : "Password Management: Password in Configuration File"
          },
          "fullDescription" : {
            "text" : "Storing a plain text password in a configuration file may result in a system compromise."
          },
          "help" : {
            "text" : "Storing a plain text password in a configuration file allows anyone who can read the file access to the password-protected resource. Developers sometimes believe that they cannot defend the application from someone who has access to the configuration, but this attitude makes an attacker's job easier. Good password management guidelines require that a password never be stored in plain text.\n\n\nIn this case, a hardcoded password exists in application-dev.yml on line 36.\n\n\nA password should never be stored in plain text. An administrator should be required to enter the password when the system starts. If that approach is impractical, a less secure but often adequate solution is to obfuscate the password and scatter the de-obfuscation material around the system so that an attacker has to obtain and correctly combine multiple system resources to decipher the password.\n\nSome third-party products claim the ability to manage passwords in a more secure way. For example, WebSphere Application Server 4.x uses a simple XOR encryption algorithm for obfuscating values, but be skeptical about such facilities. WebSphere and other application servers offer outdated and relatively weak encryption mechanisms that are insufficient for security-sensitive environments. For a secure solution the only viable option is a proprietary one.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/e3e16f0c-cb28-4b08-aaec-985891ad14e6"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "24780822",
          "shortDescription" : {
            "text" : "Password Management: Password in Configuration File"
          },
          "fullDescription" : {
            "text" : "Storing a plain text password in a configuration file may result in a system compromise."
          },
          "help" : {
            "text" : "Storing a plain text password in a configuration file allows anyone who can read the file access to the password-protected resource. Developers sometimes believe that they cannot defend the application from someone who has access to the configuration, but this attitude makes an attacker's job easier. Good password management guidelines require that a password never be stored in plain text.\n\n\nIn this case, a hardcoded password exists in application-test.yml on line 36.\n\n\nA password should never be stored in plain text. An administrator should be required to enter the password when the system starts. If that approach is impractical, a less secure but often adequate solution is to obfuscate the password and scatter the de-obfuscation material around the system so that an attacker has to obtain and correctly combine multiple system resources to decipher the password.\n\nSome third-party products claim the ability to manage passwords in a more secure way. For example, WebSphere Application Server 4.x uses a simple XOR encryption algorithm for obfuscating values, but be skeptical about such facilities. WebSphere and other application servers offer outdated and relatively weak encryption mechanisms that are insufficient for security-sensitive environments. For a secure solution the only viable option is a proprietary one.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/27814a90-fa20-4d84-b747-40362ea3848e"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "22300894",
          "shortDescription" : {
            "text" : "Path Manipulation"
          },
          "fullDescription" : {
            "text" : "Attackers can control the file system path argument to get() at FileSystemStorageService.java line 53, which allows them to access or modify otherwise protected files.Allowing user input to control paths used in file system operations could enable an attacker to access or modify otherwise protected system resources."
          },
          "help" : {
            "text" : "Path manipulation errors occur when the following two conditions are met:\n\n1. An attacker can specify a path used in an operation on the file system.\n\n2. By specifying the resource, the attacker gains a capability that would not otherwise be permitted.\n\nFor example, the program might give the attacker the ability to overwrite the specified file or run with a configuration controlled by the attacker.\n\nIn this case, the attacker can specify the value that enters the program at handleFileUpload() in UserController.java on line 523, and this value is used to access a file system resource at get() in FileSystemStorageService.java on line 53.\n\n\n\nExample 1: The following code uses input from an HTTP request to create a file name. The programmer has not considered the possibility that an attacker could provide a file name such as \"../../tomcat/conf/server.xml\", which causes the application to delete one of its own configuration files.\n\n\nString rName = request.getParameter(\"reportName\");\nFile rFile = new File(\"/usr/local/apfr/reports/\" + rName);\n...\nrFile.delete();\n\n\nExample 2: The following code uses input from a configuration file to determine which file to open and echo back to the user. If the program runs with adequate privileges and malicious users can change the configuration file, they can use the program to read any file on the system that ends with the extension .txt.\n\n\nfis = new FileInputStream(cfg.getProperty(\"sub\")+\".txt\");\namt = fis.read(arr);\nout.println(arr);\n\n\nSome think that in the mobile environment, classic vulnerabilities, such as path manipulation, do not make sense -- why would the user attack themself? However, keep in mind that the essence of mobile platforms is applications that are downloaded from various sources and run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which necessitates expanding the attack surface of mobile applications to include inter-process communication.\n\nExample 3: The following code adapts Example 1 to the Android platform.\n\n\n...\nString rName = this.getIntent().getExtras().getString(\"reportName\");\nFile rFile = getBaseContext().getFileStreamPath(rName);\n...\nrFile.delete();\n...\n\n\nThe best way to prevent path manipulation is with a level of indirection: create a list of legitimate values from which the user must select. With this approach, the user-provided input is never used directly to specify the resource name.\n\nIn some situations this approach is impractical because the set of legitimate resource names is too large or too hard to maintain. Programmers often resort to implementing a deny list in these situations. A deny list is used to selectively reject or escape potentially dangerous characters before using the input. However, any such list of unsafe characters is likely to be incomplete and will almost certainly become out of date. A better approach is to create a list of characters that are permitted to appear in the resource name and accept input composed exclusively of characters in the approved set.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/836722e7-e774-4dbd-8f84-a34b9799a1f3"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "13421035",
          "shortDescription" : {
            "text" : "Path Manipulation"
          },
          "fullDescription" : {
            "text" : "Attackers can control the file system path argument to File() at UserUtils.java line 79, which allows them to access or modify otherwise protected files.Allowing user input to control paths used in file system operations could enable an attacker to access or modify otherwise protected system resources."
          },
          "help" : {
            "text" : "Path manipulation errors occur when the following two conditions are met:\n\n1. An attacker can specify a path used in an operation on the file system.\n\n2. By specifying the resource, the attacker gains a capability that would not otherwise be permitted.\n\nFor example, the program might give the attacker the ability to overwrite the specified file or run with a configuration controlled by the attacker.\n\nIn this case, the attacker can specify the value that enters the program at getProperty() in UserUtils.java on line 138, and this value is used to access a file system resource at File() in UserUtils.java on line 79.\n\n\n\nExample 1: The following code uses input from an HTTP request to create a file name. The programmer has not considered the possibility that an attacker could provide a file name such as \"../../tomcat/conf/server.xml\", which causes the application to delete one of its own configuration files.\n\n\nString rName = request.getParameter(\"reportName\");\nFile rFile = new File(\"/usr/local/apfr/reports/\" + rName);\n...\nrFile.delete();\n\n\nExample 2: The following code uses input from a configuration file to determine which file to open and echo back to the user. If the program runs with adequate privileges and malicious users can change the configuration file, they can use the program to read any file on the system that ends with the extension .txt.\n\n\nfis = new FileInputStream(cfg.getProperty(\"sub\")+\".txt\");\namt = fis.read(arr);\nout.println(arr);\n\n\nSome think that in the mobile environment, classic vulnerabilities, such as path manipulation, do not make sense -- why would the user attack themself? However, keep in mind that the essence of mobile platforms is applications that are downloaded from various sources and run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which necessitates expanding the attack surface of mobile applications to include inter-process communication.\n\nExample 3: The following code adapts Example 1 to the Android platform.\n\n\n...\nString rName = this.getIntent().getExtras().getString(\"reportName\");\nFile rFile = getBaseContext().getFileStreamPath(rName);\n...\nrFile.delete();\n...\n\n\nThe best way to prevent path manipulation is with a level of indirection: create a list of legitimate values from which the user must select. With this approach, the user-provided input is never used directly to specify the resource name.\n\nIn some situations this approach is impractical because the set of legitimate resource names is too large or too hard to maintain. Programmers often resort to implementing a deny list in these situations. A deny list is used to selectively reject or escape potentially dangerous characters before using the input. However, any such list of unsafe characters is likely to be incomplete and will almost certainly become out of date. A better approach is to create a list of characters that are permitted to appear in the resource name and accept input composed exclusively of characters in the approved set.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/25c55c9d-ece8-402c-a87d-762279fec0f9"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "13421040",
          "shortDescription" : {
            "text" : "Path Manipulation"
          },
          "fullDescription" : {
            "text" : "Attackers can control the file system path argument to File() at UserUtils.java line 50, which allows them to access or modify otherwise protected files.Allowing user input to control paths used in file system operations could enable an attacker to access or modify otherwise protected system resources."
          },
          "help" : {
            "text" : "Path manipulation errors occur when the following two conditions are met:\n\n1. An attacker can specify a path used in an operation on the file system.\n\n2. By specifying the resource, the attacker gains a capability that would not otherwise be permitted.\n\nFor example, the program might give the attacker the ability to overwrite the specified file or run with a configuration controlled by the attacker.\n\nIn this case, the attacker can specify the value that enters the program at getProperty() in UserUtils.java on line 138, and this value is used to access a file system resource at File() in UserUtils.java on line 50.\n\n\n\nExample 1: The following code uses input from an HTTP request to create a file name. The programmer has not considered the possibility that an attacker could provide a file name such as \"../../tomcat/conf/server.xml\", which causes the application to delete one of its own configuration files.\n\n\nString rName = request.getParameter(\"reportName\");\nFile rFile = new File(\"/usr/local/apfr/reports/\" + rName);\n...\nrFile.delete();\n\n\nExample 2: The following code uses input from a configuration file to determine which file to open and echo back to the user. If the program runs with adequate privileges and malicious users can change the configuration file, they can use the program to read any file on the system that ends with the extension .txt.\n\n\nfis = new FileInputStream(cfg.getProperty(\"sub\")+\".txt\");\namt = fis.read(arr);\nout.println(arr);\n\n\nSome think that in the mobile environment, classic vulnerabilities, such as path manipulation, do not make sense -- why would the user attack themself? However, keep in mind that the essence of mobile platforms is applications that are downloaded from various sources and run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which necessitates expanding the attack surface of mobile applications to include inter-process communication.\n\nExample 3: The following code adapts Example 1 to the Android platform.\n\n\n...\nString rName = this.getIntent().getExtras().getString(\"reportName\");\nFile rFile = getBaseContext().getFileStreamPath(rName);\n...\nrFile.delete();\n...\n\n\nThe best way to prevent path manipulation is with a level of indirection: create a list of legitimate values from which the user must select. With this approach, the user-provided input is never used directly to specify the resource name.\n\nIn some situations this approach is impractical because the set of legitimate resource names is too large or too hard to maintain. Programmers often resort to implementing a deny list in these situations. A deny list is used to selectively reject or escape potentially dangerous characters before using the input. However, any such list of unsafe characters is likely to be incomplete and will almost certainly become out of date. A better approach is to create a list of characters that are permitted to appear in the resource name and accept input composed exclusively of characters in the approved set.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/c528fb56-2a52-4cd3-bef9-a39e450935fe"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "22300897",
          "shortDescription" : {
            "text" : "Path Manipulation"
          },
          "fullDescription" : {
            "text" : "Attackers can control the file system path argument to resolve() at FileSystemStorageService.java line 85, which allows them to access or modify otherwise protected files.Allowing user input to control paths used in file system operations could enable an attacker to access or modify otherwise protected system resources."
          },
          "help" : {
            "text" : "Path manipulation errors occur when the following two conditions are met:\n\n1. An attacker can specify a path used in an operation on the file system.\n\n2. By specifying the resource, the attacker gains a capability that would not otherwise be permitted.\n\nFor example, the program might give the attacker the ability to overwrite the specified file or run with a configuration controlled by the attacker.\n\nIn this case, the attacker can specify the value that enters the program at serveFile() in UserController.java on line 515, and this value is used to access a file system resource at resolve() in FileSystemStorageService.java on line 85.\n\n\n\nExample 1: The following code uses input from an HTTP request to create a file name. The programmer has not considered the possibility that an attacker could provide a file name such as \"../../tomcat/conf/server.xml\", which causes the application to delete one of its own configuration files.\n\n\nString rName = request.getParameter(\"reportName\");\nFile rFile = new File(\"/usr/local/apfr/reports/\" + rName);\n...\nrFile.delete();\n\n\nExample 2: The following code uses input from a configuration file to determine which file to open and echo back to the user. If the program runs with adequate privileges and malicious users can change the configuration file, they can use the program to read any file on the system that ends with the extension .txt.\n\n\nfis = new FileInputStream(cfg.getProperty(\"sub\")+\".txt\");\namt = fis.read(arr);\nout.println(arr);\n\n\nSome think that in the mobile environment, classic vulnerabilities, such as path manipulation, do not make sense -- why would the user attack themself? However, keep in mind that the essence of mobile platforms is applications that are downloaded from various sources and run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which necessitates expanding the attack surface of mobile applications to include inter-process communication.\n\nExample 3: The following code adapts Example 1 to the Android platform.\n\n\n...\nString rName = this.getIntent().getExtras().getString(\"reportName\");\nFile rFile = getBaseContext().getFileStreamPath(rName);\n...\nrFile.delete();\n...\n\n\nThe best way to prevent path manipulation is with a level of indirection: create a list of legitimate values from which the user must select. With this approach, the user-provided input is never used directly to specify the resource name.\n\nIn some situations this approach is impractical because the set of legitimate resource names is too large or too hard to maintain. Programmers often resort to implementing a deny list in these situations. A deny list is used to selectively reject or escape potentially dangerous characters before using the input. However, any such list of unsafe characters is likely to be incomplete and will almost certainly become out of date. A better approach is to create a list of characters that are permitted to appear in the resource name and accept input composed exclusively of characters in the approved set.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/47095d2a-7ead-4c00-8b65-68fad5a8678f"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "13421043",
          "shortDescription" : {
            "text" : "Path Manipulation"
          },
          "fullDescription" : {
            "text" : "Attackers can control the file system path argument to FileReader() at UserUtils.java line 81, which allows them to access or modify otherwise protected files.Allowing user input to control paths used in file system operations could enable an attacker to access or modify otherwise protected system resources."
          },
          "help" : {
            "text" : "Path manipulation errors occur when the following two conditions are met:\n\n1. An attacker can specify a path used in an operation on the file system.\n\n2. By specifying the resource, the attacker gains a capability that would not otherwise be permitted.\n\nFor example, the program might give the attacker the ability to overwrite the specified file or run with a configuration controlled by the attacker.\n\nIn this case, the attacker can specify the value that enters the program at getProperty() in UserUtils.java on line 138, and this value is used to access a file system resource at FileReader() in UserUtils.java on line 81.\n\n\n\nExample 1: The following code uses input from an HTTP request to create a file name. The programmer has not considered the possibility that an attacker could provide a file name such as \"../../tomcat/conf/server.xml\", which causes the application to delete one of its own configuration files.\n\n\nString rName = request.getParameter(\"reportName\");\nFile rFile = new File(\"/usr/local/apfr/reports/\" + rName);\n...\nrFile.delete();\n\n\nExample 2: The following code uses input from a configuration file to determine which file to open and echo back to the user. If the program runs with adequate privileges and malicious users can change the configuration file, they can use the program to read any file on the system that ends with the extension .txt.\n\n\nfis = new FileInputStream(cfg.getProperty(\"sub\")+\".txt\");\namt = fis.read(arr);\nout.println(arr);\n\n\nSome think that in the mobile environment, classic vulnerabilities, such as path manipulation, do not make sense -- why would the user attack themself? However, keep in mind that the essence of mobile platforms is applications that are downloaded from various sources and run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which necessitates expanding the attack surface of mobile applications to include inter-process communication.\n\nExample 3: The following code adapts Example 1 to the Android platform.\n\n\n...\nString rName = this.getIntent().getExtras().getString(\"reportName\");\nFile rFile = getBaseContext().getFileStreamPath(rName);\n...\nrFile.delete();\n...\n\n\nThe best way to prevent path manipulation is with a level of indirection: create a list of legitimate values from which the user must select. With this approach, the user-provided input is never used directly to specify the resource name.\n\nIn some situations this approach is impractical because the set of legitimate resource names is too large or too hard to maintain. Programmers often resort to implementing a deny list in these situations. A deny list is used to selectively reject or escape potentially dangerous characters before using the input. However, any such list of unsafe characters is likely to be incomplete and will almost certainly become out of date. A better approach is to create a list of characters that are permitted to appear in the resource name and accept input composed exclusively of characters in the approved set.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/a4174640-6f20-448f-8a3b-a606b4b388ee"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "24780823",
          "shortDescription" : {
            "text" : "Path Manipulation"
          },
          "fullDescription" : {
            "text" : "Attackers can control the file system path argument to get() at ProductController.java line 125, which allows them to access or modify otherwise protected files.Allowing user input to control paths used in file system operations could enable an attacker to access or modify otherwise protected system resources."
          },
          "help" : {
            "text" : "Path manipulation errors occur when the following two conditions are met:\n\n1. An attacker can specify a path used in an operation on the file system.\n\n2. By specifying the resource, the attacker gains a capability that would not otherwise be permitted.\n\nFor example, the program might give the attacker the ability to overwrite the specified file or run with a configuration controlled by the attacker.\n\nIn this case, the attacker can specify the value that enters the program at downloadFile() in ProductController.java on line 113, and this value is used to access a file system resource at get() in ProductController.java on line 125.\n\n\n\nExample 1: The following code uses input from an HTTP request to create a file name. The programmer has not considered the possibility that an attacker could provide a file name such as \"../../tomcat/conf/server.xml\", which causes the application to delete one of its own configuration files.\n\n\nString rName = request.getParameter(\"reportName\");\nFile rFile = new File(\"/usr/local/apfr/reports/\" + rName);\n...\nrFile.delete();\n\n\nExample 2: The following code uses input from a configuration file to determine which file to open and echo back to the user. If the program runs with adequate privileges and malicious users can change the configuration file, they can use the program to read any file on the system that ends with the extension .txt.\n\n\nfis = new FileInputStream(cfg.getProperty(\"sub\")+\".txt\");\namt = fis.read(arr);\nout.println(arr);\n\n\nSome think that in the mobile environment, classic vulnerabilities, such as path manipulation, do not make sense -- why would the user attack themself? However, keep in mind that the essence of mobile platforms is applications that are downloaded from various sources and run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which necessitates expanding the attack surface of mobile applications to include inter-process communication.\n\nExample 3: The following code adapts Example 1 to the Android platform.\n\n\n...\nString rName = this.getIntent().getExtras().getString(\"reportName\");\nFile rFile = getBaseContext().getFileStreamPath(rName);\n...\nrFile.delete();\n...\n\n\nThe best way to prevent path manipulation is with a level of indirection: create a list of legitimate values from which the user must select. With this approach, the user-provided input is never used directly to specify the resource name.\n\nIn some situations this approach is impractical because the set of legitimate resource names is too large or too hard to maintain. Programmers often resort to implementing a deny list in these situations. A deny list is used to selectively reject or escape potentially dangerous characters before using the input. However, any such list of unsafe characters is likely to be incomplete and will almost certainly become out of date. A better approach is to create a list of characters that are permitted to appear in the resource name and accept input composed exclusively of characters in the approved set.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/3d504fec-c6e0-4dea-a243-5cb155ec6d1a"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "13421038",
          "shortDescription" : {
            "text" : "Race Condition: Singleton Member Field"
          },
          "fullDescription" : {
            "text" : "The class ProductService is a singleton, so the member field pageSize is shared between users. The result is that one user could see another user's data.Servlet member fields might allow one user to see another user's data."
          },
          "help" : {
            "text" : "Many Servlet developers do not understand that a Servlet is a singleton. There is only one instance of the Servlet, and that single instance is used and re-used to handle multiple requests that are processed simultaneously by different threads.\n\nA common result of this misunderstanding is that developers use Servlet member fields in such a way that one user may inadvertently see another user's data. In other words, storing user data in Servlet member fields introduces a data access race condition.\n\nExample 1: The following Servlet stores the value of a request parameter in a member field and then later echoes the parameter value to the response output stream.\n\n\npublic class GuestBook extends HttpServlet {\n\nString name;\n\nprotected void doPost (HttpServletRequest req, HttpServletResponse res) {\nname = req.getParameter(\"name\");\n...\nout.println(name + \", thanks for visiting!\");\n}\n}\n\n\nWhile this code will work perfectly in a single-user environment, if two users access the Servlet at approximately the same time, it is possible for the two request handler threads to interleave in the following way:\n\nThread 1:\tassign \"Dick\" to name\nThread 2:\tassign \"Jane\" to name\nThread 1:\tprint \"Jane, thanks for visiting!\"\nThread 2:\tprint \"Jane, thanks for visiting!\"\n\nThereby showing the first user the second user's name.\n\nDo not use Servlet member fields for anything but constants. (i.e. make all member fields static final).\n\nDevelopers are often tempted to use Servlet member fields for user data when they need to transport data from one region of code to another. If this is your aim, consider declaring a separate class and using the Servlet only to \"wrap\" this new class.\n\nExample 2: The bug in Example 1 can be corrected in the following way:\n\n\npublic class GuestBook extends HttpServlet {\n\nprotected void doPost (HttpServletRequest req, HttpServletResponse res) {\nGBRequestHandler handler = new GBRequestHandler();\nhandler.handle(req, res);\n}\n}\n\npublic class GBRequestHandler {\n\nString name;\n\npublic void handle(HttpServletRequest req, HttpServletResponse res) {\nname = req.getParameter(\"name\");\n...\nout.println(name + \", thanks for visiting!\");\n}\n\n}\n\n\nAlternatively, a Servlet can utilize synchronized blocks to access servlet instance variables but using synchronized blocks may cause significant performance problems.\n\nPlease notice that wrapping the field access within a synchronized block will only prevent the issue if all read and write operations on that member are performed within the same synchronized block or method.\n\nExample 3: Wrapping the Example 1 write operation (assignment) in a synchronized block will not fix the problem since the threads will have to get a lock to modify name field, but they will release the lock afterwards, allowing a second thread to change the value again. If, after changing the name value, the first thread resumes execution, the value printed will be the one assigned by the second thread:\n\n\npublic class GuestBook extends HttpServlet {\n\nString name;\n\nprotected void doPost (HttpServletRequest req, HttpServletResponse res) {\nsynchronized(name) {\nname = req.getParameter(\"name\");\n}\n...\nout.println(name + \", thanks for visiting!\");\n}\n}\n\n\nIn order to fix the race condition, all the write and read operations on the shared member field should be run atomically within the same synchronized block:\n\n\npublic class GuestBook extends HttpServlet {\n\nString name;\n\nprotected void doPost (HttpServletRequest req, HttpServletResponse res) {\nsynchronized(name) {\nname = req.getParameter(\"name\");\n...\nout.println(name + \", thanks for visiting!\");\n}\n}\n}\n\n\n\nFor more information, see https://emea.fortify.com//redirect/Issues/4419be0d-1784-4976-a890-4e4491252701"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "11425738",
          "shortDescription" : {
            "text" : "Spring Boot Misconfiguration: DevTools Enabled"
          },
          "fullDescription" : {
            "text" : "The Spring Boot application is configured in developer mode."
          },
          "help" : {
            "text" : "The Spring Boot application has DevTools enabled. DevTools include an additional set of tools which can make the application development experience a little more pleasant, but DevTools are not recommended to use on applications in a production environment. As stated in the official Spring Boot documentation: \"Enabling spring-boot-devtools on a remote application is a security risk. You should never enable support on a production deployment.\"\n\nRemove spring-boot-devtools dependency on production deployments.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/78762aaa-c7ff-4f01-9d5c-0cd763a7d5e5"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "24851296",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 121 of ProductRepository.java, the method findAvailableByKeywords() invokes a SQL query built with input that comes from an untrusted source. This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.Constructing a dynamic SQL statement with input that comes from an untrusted source could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands. "
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case, the data enters at index() in ProductController.java on line 84.\n\n\n2. The data is used to dynamically construct a SQL query.\n\n\nIn this case, the data is passed to query() in ProductRepository.java on line 121.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user.\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query = \"SELECT * FROM items WHERE owner = '\"\n+ userName + \"' AND itemname = '\"\n+ itemName + \"'\";\nResultSet rs = stmt.execute(query);\n...\n\n\nThe query intends to execute the following code:\n\n\nSELECT * FROM items\nWHERE owner = &lt;userName&gt;\nAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\nSELECT * FROM items\nWHERE owner = 'wiley'\nAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\nSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query must only return items owned by the authenticated user. The query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\nSELECT * FROM items\nWHERE owner = 'wiley'\nAND itemname = 'name';\n\nDELETE FROM items;\n\n--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.\n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created:\n\n\nSELECT * FROM items\nWHERE owner = 'wiley'\nAND itemname = 'name';\n\nDELETE FROM items;\n\nSELECT * FROM items WHERE 'a'='a';\n\n\nSome think that in the mobile world, classic web application vulnerabilities, such as SQL injection, do not make sense -- why would the user attack themself? However, keep in mind that the essence of mobile platforms is applications that are downloaded from various sources and run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which necessitates expanding the attack surface of mobile applications to include inter-process communication.\n\nExample 3: The following code adapts Example 1 to the Android platform.\n\n\n...\nPasswordAuthentication pa = authenticator.getPasswordAuthentication();\nString userName = pa.getUserName();\nString itemName = this.getIntent().getExtras().getString(\"itemName\");\nString query = \"SELECT * FROM items WHERE owner = '\"\n+ userName + \"' AND itemname = '\"\n+ itemName + \"'\";\nSQLiteDatabase db = this.openOrCreateDatabase(\"DB\", MODE_PRIVATE, null);\nCursor c = db.rawQuery(query, null);\n...\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from an allow list of safe values or identify and escape a list of potentially malicious values (deny list). Checking an allow list can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, implementing a deny list is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers may:\n\n- Target fields that are not quoted\n- Find ways to bypass the need for certain escaped metacharacters\n- Use stored procedures to hide the injected metacharacters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks.\n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks.\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nExample 1 can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query = \"SELECT * FROM items WHERE itemname=? AND owner=?\";\nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nAnd here is an Android equivalent:\n\n\n...\nPasswordAuthentication pa = authenticator.getPasswordAuthentication();\nString userName = pa.getUserName();\nString itemName = this.getIntent().getExtras().getString(\"itemName\");\nString query = \"SELECT * FROM items WHERE itemname=? AND owner=?\";\nSQLiteDatabase db = this.openOrCreateDatabase(\"DB\", MODE_PRIVATE, null);\nCursor c = db.rawQuery(query, new Object[]{itemName, userName});\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/216d13f9-e249-413c-b6a9-695a60798963"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "24851299",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 110 of ProductRepository.java, the method findByKeywords() invokes a SQL query built with input that comes from an untrusted source. This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.Constructing a dynamic SQL statement with input that comes from an untrusted source could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands. "
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case, the data enters at getProductsByKeywords() in ApiProductController.java on line 75.\n\n\n2. The data is used to dynamically construct a SQL query.\n\n\nIn this case, the data is passed to query() in ProductRepository.java on line 110.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user.\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query = \"SELECT * FROM items WHERE owner = '\"\n+ userName + \"' AND itemname = '\"\n+ itemName + \"'\";\nResultSet rs = stmt.execute(query);\n...\n\n\nThe query intends to execute the following code:\n\n\nSELECT * FROM items\nWHERE owner = &lt;userName&gt;\nAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\nSELECT * FROM items\nWHERE owner = 'wiley'\nAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\nSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query must only return items owned by the authenticated user. The query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\nSELECT * FROM items\nWHERE owner = 'wiley'\nAND itemname = 'name';\n\nDELETE FROM items;\n\n--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.\n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created:\n\n\nSELECT * FROM items\nWHERE owner = 'wiley'\nAND itemname = 'name';\n\nDELETE FROM items;\n\nSELECT * FROM items WHERE 'a'='a';\n\n\nSome think that in the mobile world, classic web application vulnerabilities, such as SQL injection, do not make sense -- why would the user attack themself? However, keep in mind that the essence of mobile platforms is applications that are downloaded from various sources and run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which necessitates expanding the attack surface of mobile applications to include inter-process communication.\n\nExample 3: The following code adapts Example 1 to the Android platform.\n\n\n...\nPasswordAuthentication pa = authenticator.getPasswordAuthentication();\nString userName = pa.getUserName();\nString itemName = this.getIntent().getExtras().getString(\"itemName\");\nString query = \"SELECT * FROM items WHERE owner = '\"\n+ userName + \"' AND itemname = '\"\n+ itemName + \"'\";\nSQLiteDatabase db = this.openOrCreateDatabase(\"DB\", MODE_PRIVATE, null);\nCursor c = db.rawQuery(query, null);\n...\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from an allow list of safe values or identify and escape a list of potentially malicious values (deny list). Checking an allow list can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, implementing a deny list is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers may:\n\n- Target fields that are not quoted\n- Find ways to bypass the need for certain escaped metacharacters\n- Use stored procedures to hide the injected metacharacters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks.\n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks.\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nExample 1 can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query = \"SELECT * FROM items WHERE itemname=? AND owner=?\";\nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nAnd here is an Android equivalent:\n\n\n...\nPasswordAuthentication pa = authenticator.getPasswordAuthentication();\nString userName = pa.getUserName();\nString itemName = this.getIntent().getExtras().getString(\"itemName\");\nString query = \"SELECT * FROM items WHERE itemname=? AND owner=?\";\nSQLiteDatabase db = this.openOrCreateDatabase(\"DB\", MODE_PRIVATE, null);\nCursor c = db.rawQuery(query, new Object[]{itemName, userName});\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/d1650384-27da-4197-b24e-eb03640c4b3f"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "24851300",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "On line 95 of ProductRepository.java, the method findByCode() invokes a SQL query built with input that comes from an untrusted source. This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.Constructing a dynamic SQL statement with input that comes from an untrusted source could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands. "
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case, the data enters at productSave() in AdminProductController.java on line 102.\n\n\n2. The data is used to dynamically construct a SQL query.\n\n\nIn this case, the data is passed to query() in ProductRepository.java on line 95.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user.\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query = \"SELECT * FROM items WHERE owner = '\"\n+ userName + \"' AND itemname = '\"\n+ itemName + \"'\";\nResultSet rs = stmt.execute(query);\n...\n\n\nThe query intends to execute the following code:\n\n\nSELECT * FROM items\nWHERE owner = &lt;userName&gt;\nAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\nSELECT * FROM items\nWHERE owner = 'wiley'\nAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\nSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query must only return items owned by the authenticated user. The query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\nSELECT * FROM items\nWHERE owner = 'wiley'\nAND itemname = 'name';\n\nDELETE FROM items;\n\n--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.\n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created:\n\n\nSELECT * FROM items\nWHERE owner = 'wiley'\nAND itemname = 'name';\n\nDELETE FROM items;\n\nSELECT * FROM items WHERE 'a'='a';\n\n\nSome think that in the mobile world, classic web application vulnerabilities, such as SQL injection, do not make sense -- why would the user attack themself? However, keep in mind that the essence of mobile platforms is applications that are downloaded from various sources and run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which necessitates expanding the attack surface of mobile applications to include inter-process communication.\n\nExample 3: The following code adapts Example 1 to the Android platform.\n\n\n...\nPasswordAuthentication pa = authenticator.getPasswordAuthentication();\nString userName = pa.getUserName();\nString itemName = this.getIntent().getExtras().getString(\"itemName\");\nString query = \"SELECT * FROM items WHERE owner = '\"\n+ userName + \"' AND itemname = '\"\n+ itemName + \"'\";\nSQLiteDatabase db = this.openOrCreateDatabase(\"DB\", MODE_PRIVATE, null);\nCursor c = db.rawQuery(query, null);\n...\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from an allow list of safe values or identify and escape a list of potentially malicious values (deny list). Checking an allow list can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, implementing a deny list is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers may:\n\n- Target fields that are not quoted\n- Find ways to bypass the need for certain escaped metacharacters\n- Use stored procedures to hide the injected metacharacters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks.\n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks.\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nExample 1 can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:\n\n\n...\nString userName = ctx.getAuthenticatedUserName();\nString itemName = request.getParameter(\"itemName\");\nString query = \"SELECT * FROM items WHERE itemname=? AND owner=?\";\nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, itemName);\nstmt.setString(2, userName);\nResultSet results = stmt.execute();\n...\n\n\nAnd here is an Android equivalent:\n\n\n...\nPasswordAuthentication pa = authenticator.getPasswordAuthentication();\nString userName = pa.getUserName();\nString itemName = this.getIntent().getExtras().getString(\"itemName\");\nString query = \"SELECT * FROM items WHERE itemname=? AND owner=?\";\nSQLiteDatabase db = this.openOrCreateDatabase(\"DB\", MODE_PRIVATE, null);\nCursor c = db.rawQuery(query, new Object[]{itemName, userName});\n...\n\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/d89226fb-302b-4aa6-b735-7a3ceb8918f7"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "11445512",
          "shortDescription" : {
            "text" : "System Information Leak: External"
          },
          "fullDescription" : {
            "text" : "The function commence() in BasicAuthenticationEntryPointCustom.java reveals system data or debug information by calling println() on line 69. The information revealed by println() could help an adversary form a plan of attack.Revealing system data or debugging information helps an adversary learn about the system and form a plan of attack."
          },
          "help" : {
            "text" : "An external information leak occurs when system data or debug information leaves the program to a remote machine via a socket or network connection. External leaks can help an attacker by revealing specific data about operating systems, full pathnames, the existence of usernames, or locations of configuration files, and are more serious than internal information leaks, which are more difficult for an attacker to access.\n\n\nIn this case, println() is called in BasicAuthenticationEntryPointCustom.java on line 69.\n\n\nExample 1: The following code leaks Exception information in the HTTP response:\n\n\nprotected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {\n...\nPrintWriter out = res.getWriter();\ntry {\n...\n} catch (Exception e) {\nout.println(e.getMessage());\n}\n}\n\n\nThis information can be exposed to a remote user. In some cases, the error message provides the attacker with the precise type of attack to which the system is vulnerable. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In Example 1, the leaked information could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\nInformation leaks are also a concern in a mobile computing environment. With mobile platforms, applications are downloaded from various sources and are run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which is why application authors need to be careful about what information they include in messages addressed to other applications running on the device.\n\nExample 2: The following code broadcasts the stack trace of a caught exception to all the registered Android receivers.\n\n...\ntry {\n...\n} catch (Exception e) {\nString exception = Log.getStackTraceString(e);\nIntent i = new Intent();\ni.setAction(\"SEND_EXCEPTION\");\ni.putExtra(\"exception\", exception);\nview.getContext().sendBroadcast(i);\n}\n...\n\n\nThis is another scenario specific to the mobile environment. Most mobile devices now implement a Near-Field Communication (NFC) protocol for quickly sharing information between devices using radio communication. It works by bringing devices in close proximity or having the devices touch each other. Even though the communication range of NFC is limited to just a few centimeters, eavesdropping, data modification and various other types of attacks are possible, because NFC alone does not ensure secure communication.\n\nExample 3: The Android platform provides support for NFC. The following code creates a message that gets pushed to the other device within range.\n\n...\npublic static final String TAG = \"NfcActivity\";\nprivate static final String DATA_SPLITTER = \"__:DATA:__\";\nprivate static final String MIME_TYPE = \"application/my.applications.mimetype\";\n...\nTelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);\nString VERSION = tm.getDeviceSoftwareVersion();\n...\nNfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);\nif (nfcAdapter == null)\nreturn;\n\nString text = TAG + DATA_SPLITTER + VERSION;\nNdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,\nMIME_TYPE.getBytes(), new byte[0], text.getBytes());\nNdefRecord[] records = { record };\nNdefMessage msg = new NdefMessage(records);\nnfcAdapter.setNdefPushMessage(msg, this);\n...\n\n\nAn NFC Data Exchange Format (NDEF) message contains typed data, a URI, or a custom application payload. If the message contains information about the application, such as its name, MIME type, or device software version, this information could be leaked to an eavesdropper.\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Debug traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system. Because of this, never send information to a resource directly outside the program.\n\nExample 4: The following code broadcasts the stack trace of a caught exception within your application only, so that it cannot be leaked to other apps on the system. Additionally, this technique is more efficient than globally broadcasting through the system.\n\n\n...\ntry {\n...\n} catch (Exception e) {\nString exception = Log.getStackTraceString(e);\nIntent i = new Intent();\ni.setAction(\"SEND_EXCEPTION\");\ni.putExtra(\"exception\", exception);\nLocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);\n}\n...\n\n\nIf you are concerned about leaking system data via NFC on an Android device, you could do one of the following three things. Do not include system data in the messages pushed to other devices in range, encrypt the payload of the message, or establish a secure communication channel at a higher layer.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/c93103fd-485e-4ec6-94e4-c87acb377687"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "12336037",
          "shortDescription" : {
            "text" : "System Information Leak: External"
          },
          "fullDescription" : {
            "text" : "The function commence() in AuthenticationEntryPointJwt.java reveals system data or debug information by calling println() on line 69. The information revealed by println() could help an adversary form a plan of attack.Revealing system data or debugging information helps an adversary learn about the system and form a plan of attack."
          },
          "help" : {
            "text" : "An external information leak occurs when system data or debug information leaves the program to a remote machine via a socket or network connection. External leaks can help an attacker by revealing specific data about operating systems, full pathnames, the existence of usernames, or locations of configuration files, and are more serious than internal information leaks, which are more difficult for an attacker to access.\n\n\nIn this case, println() is called in AuthenticationEntryPointJwt.java on line 69.\n\n\nExample 1: The following code leaks Exception information in the HTTP response:\n\n\nprotected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {\n...\nPrintWriter out = res.getWriter();\ntry {\n...\n} catch (Exception e) {\nout.println(e.getMessage());\n}\n}\n\n\nThis information can be exposed to a remote user. In some cases, the error message provides the attacker with the precise type of attack to which the system is vulnerable. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In Example 1, the leaked information could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\nInformation leaks are also a concern in a mobile computing environment. With mobile platforms, applications are downloaded from various sources and are run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which is why application authors need to be careful about what information they include in messages addressed to other applications running on the device.\n\nExample 2: The following code broadcasts the stack trace of a caught exception to all the registered Android receivers.\n\n...\ntry {\n...\n} catch (Exception e) {\nString exception = Log.getStackTraceString(e);\nIntent i = new Intent();\ni.setAction(\"SEND_EXCEPTION\");\ni.putExtra(\"exception\", exception);\nview.getContext().sendBroadcast(i);\n}\n...\n\n\nThis is another scenario specific to the mobile environment. Most mobile devices now implement a Near-Field Communication (NFC) protocol for quickly sharing information between devices using radio communication. It works by bringing devices in close proximity or having the devices touch each other. Even though the communication range of NFC is limited to just a few centimeters, eavesdropping, data modification and various other types of attacks are possible, because NFC alone does not ensure secure communication.\n\nExample 3: The Android platform provides support for NFC. The following code creates a message that gets pushed to the other device within range.\n\n...\npublic static final String TAG = \"NfcActivity\";\nprivate static final String DATA_SPLITTER = \"__:DATA:__\";\nprivate static final String MIME_TYPE = \"application/my.applications.mimetype\";\n...\nTelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);\nString VERSION = tm.getDeviceSoftwareVersion();\n...\nNfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);\nif (nfcAdapter == null)\nreturn;\n\nString text = TAG + DATA_SPLITTER + VERSION;\nNdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,\nMIME_TYPE.getBytes(), new byte[0], text.getBytes());\nNdefRecord[] records = { record };\nNdefMessage msg = new NdefMessage(records);\nnfcAdapter.setNdefPushMessage(msg, this);\n...\n\n\nAn NFC Data Exchange Format (NDEF) message contains typed data, a URI, or a custom application payload. If the message contains information about the application, such as its name, MIME type, or device software version, this information could be leaked to an eavesdropper.\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Debug traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system. Because of this, never send information to a resource directly outside the program.\n\nExample 4: The following code broadcasts the stack trace of a caught exception within your application only, so that it cannot be leaked to other apps on the system. Additionally, this technique is more efficient than globally broadcasting through the system.\n\n\n...\ntry {\n...\n} catch (Exception e) {\nString exception = Log.getStackTraceString(e);\nIntent i = new Intent();\ni.setAction(\"SEND_EXCEPTION\");\ni.putExtra(\"exception\", exception);\nLocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);\n}\n...\n\n\nIf you are concerned about leaking system data via NFC on an Android device, you could do one of the following three things. Do not include system data in the messages pushed to other devices in range, encrypt the payload of the message, or establish a secure communication channel at a higher layer.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/e11eb89e-b0c2-4431-8db8-9964d84f23db"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "11445541",
          "shortDescription" : {
            "text" : "System Information Leak: External"
          },
          "fullDescription" : {
            "text" : "The function handle() in ApiAccessDeniedHandler.java reveals system data or debug information by calling println() on line 66. The information revealed by println() could help an adversary form a plan of attack.Revealing system data or debugging information helps an adversary learn about the system and form a plan of attack."
          },
          "help" : {
            "text" : "An external information leak occurs when system data or debug information leaves the program to a remote machine via a socket or network connection. External leaks can help an attacker by revealing specific data about operating systems, full pathnames, the existence of usernames, or locations of configuration files, and are more serious than internal information leaks, which are more difficult for an attacker to access.\n\n\nIn this case, println() is called in ApiAccessDeniedHandler.java on line 66.\n\n\nExample 1: The following code leaks Exception information in the HTTP response:\n\n\nprotected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {\n...\nPrintWriter out = res.getWriter();\ntry {\n...\n} catch (Exception e) {\nout.println(e.getMessage());\n}\n}\n\n\nThis information can be exposed to a remote user. In some cases, the error message provides the attacker with the precise type of attack to which the system is vulnerable. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In Example 1, the leaked information could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\nInformation leaks are also a concern in a mobile computing environment. With mobile platforms, applications are downloaded from various sources and are run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which is why application authors need to be careful about what information they include in messages addressed to other applications running on the device.\n\nExample 2: The following code broadcasts the stack trace of a caught exception to all the registered Android receivers.\n\n...\ntry {\n...\n} catch (Exception e) {\nString exception = Log.getStackTraceString(e);\nIntent i = new Intent();\ni.setAction(\"SEND_EXCEPTION\");\ni.putExtra(\"exception\", exception);\nview.getContext().sendBroadcast(i);\n}\n...\n\n\nThis is another scenario specific to the mobile environment. Most mobile devices now implement a Near-Field Communication (NFC) protocol for quickly sharing information between devices using radio communication. It works by bringing devices in close proximity or having the devices touch each other. Even though the communication range of NFC is limited to just a few centimeters, eavesdropping, data modification and various other types of attacks are possible, because NFC alone does not ensure secure communication.\n\nExample 3: The Android platform provides support for NFC. The following code creates a message that gets pushed to the other device within range.\n\n...\npublic static final String TAG = \"NfcActivity\";\nprivate static final String DATA_SPLITTER = \"__:DATA:__\";\nprivate static final String MIME_TYPE = \"application/my.applications.mimetype\";\n...\nTelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);\nString VERSION = tm.getDeviceSoftwareVersion();\n...\nNfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);\nif (nfcAdapter == null)\nreturn;\n\nString text = TAG + DATA_SPLITTER + VERSION;\nNdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,\nMIME_TYPE.getBytes(), new byte[0], text.getBytes());\nNdefRecord[] records = { record };\nNdefMessage msg = new NdefMessage(records);\nnfcAdapter.setNdefPushMessage(msg, this);\n...\n\n\nAn NFC Data Exchange Format (NDEF) message contains typed data, a URI, or a custom application payload. If the message contains information about the application, such as its name, MIME type, or device software version, this information could be leaked to an eavesdropper.\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Debug traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system. Because of this, never send information to a resource directly outside the program.\n\nExample 4: The following code broadcasts the stack trace of a caught exception within your application only, so that it cannot be leaked to other apps on the system. Additionally, this technique is more efficient than globally broadcasting through the system.\n\n\n...\ntry {\n...\n} catch (Exception e) {\nString exception = Log.getStackTraceString(e);\nIntent i = new Intent();\ni.setAction(\"SEND_EXCEPTION\");\ni.putExtra(\"exception\", exception);\nLocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);\n}\n...\n\n\nIf you are concerned about leaking system data via NFC on an Android device, you could do one of the following three things. Do not include system data in the messages pushed to other devices in range, encrypt the payload of the message, or establish a secure communication channel at a higher layer.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/2cc11bd2-7d76-47d5-852b-98295685bd19"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "11429996",
          "shortDescription" : {
            "text" : "Unreleased Resource: Files"
          },
          "fullDescription" : {
            "text" : "The function logZipContents() in UserUtils.java sometimes fails to release a file handle allocated by ZipFile() on line 129.The program can potentially fail to release a file handle."
          },
          "help" : {
            "text" : "The program can potentially fail to release a file handle.\n\nIn this case, there are program paths on which the file handle resource obtained in UserUtils.java on line 129 is not released.\n\nResource leaks have at least two common causes:\n\n- Error conditions and other exceptional circumstances.\n\n- Confusion over which part of the program is responsible for releasing the resource.\n\nMost unreleased resource issues result in general software reliability problems. However, if an attacker can intentionally trigger a resource leak, the attacker may be able to launch a denial of service attack by depleting the resource pool.\n\nExample 1: The following method never closes the file handle it opens. The finalize() method for ZipFile eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n\n\npublic void printZipContents(String fName)\nthrows ZipException, IOException, SecurityException, IllegalStateException, NoSuchElementException\n{\nZipFile zf = new ZipFile(fName);\nEnumeration&lt;ZipEntry&gt; e = zf.entries();\n\nwhile (e.hasMoreElements()) {\nprintFileInfo(e.nextElement());\n}\n}\n\n\nExample 2: Under normal conditions, the following fix properly closes the file handle after printing out all the zip file entries. But if an exception occurs while iterating through the entries, the zip file handle will not be closed. If this happens often enough, the JVM can still run out of available file handles.\n\n\npublic void printZipContents(String fName)\nthrows ZipException, IOException, SecurityException, IllegalStateException, NoSuchElementException\n{\nZipFile zf = new ZipFile(fName);\nEnumeration&lt;ZipEntry&gt; e = zf.entries();\n\nwhile (e.hasMoreElements()) {\nprintFileInfo(e.nextElement());\n}\n}\n\n\n1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to \"bursty\" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.\n\nFinally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network, for example), then the thread that is executing the finalize() method will hang.\n\n2. Release resources in a finally block. The code for Example 2 should be rewritten as follows:\n\n\npublic void printZipContents(String fName)\nthrows ZipException, IOException, SecurityException, IllegalStateException, NoSuchElementException\n{\nZipFile zf;\ntry {\nzf = new ZipFile(fName);\nEnumeration&lt;ZipEntry&gt; e = zf.entries();\n...\n}\nfinally {\nif (zf != null) {\nsafeClose(zf);\n}\n}\n}\n\npublic static void safeClose(ZipFile zf) {\nif (zf != null) {\ntry {\nzf.close();\n} catch (IOException e) {\nlog(e);\n}\n}\n}\n\n\nThis solution uses a helper function to log the exceptions that might occur when trying to close the file. Presumably this helper function will be reused whenever a file needs to be closed.\n\nAlso, the printZipContents method does not initialize the zf object to null. Instead, it checks to ensure that zf is not null before calling safeClose(). Without the null check, the Java compiler reports that zf might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  zf is initialized to null in a more complex method, cases in which zf is used without being initialized will not be detected by the compiler.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/3671e327-14a1-4713-aea3-799ac589ec90"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "13421041",
          "shortDescription" : {
            "text" : "Unreleased Resource: Streams"
          },
          "fullDescription" : {
            "text" : "The function registerUser() in UserUtils.java sometimes fails to release a system resource allocated by FileReader() on line 81.The program can potentially fail to release a system resource."
          },
          "help" : {
            "text" : "The program can potentially fail to release a system resource.\n\nIn this case, there are program paths on which the resource allocated in UserUtils.java on line 81 is not released.\n\nResource leaks have at least two common causes:\n\n- Error conditions and other exceptional circumstances.\n\n- Confusion over which part of the program is responsible for releasing the resource.\n\nMost unreleased resource issues result in general software reliability problems. However, if an attacker can intentionally trigger a resource leak, the attacker may be able to launch a denial of service attack by depleting the resource pool.\n\nExample: The following method never closes the file handle it opens. The finalize() method for FileInputStream eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n\nprivate void processFile(String fName) throws FileNotFoundException, IOException {\nFileInputStream fis = new FileInputStream(fName);\nint sz;\nbyte[] byteArray = new byte[BLOCK_SIZE];\nwhile ((sz = fis.read(byteArray)) != -1) {\nprocessBytes(byteArray, sz);\n}\n}\n\n\n1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to \"bursty\" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.\n\nFinally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang.\n\n2. Release resources in a finally block. The code for the Example should be rewritten as follows:\n\n\npublic void processFile(String fName) throws FileNotFoundException, IOException {\nFileInputStream fis;\ntry {\nfis = new FileInputStream(fName);\nint sz;\nbyte[] byteArray = new byte[BLOCK_SIZE];\nwhile ((sz = fis.read(byteArray)) != -1) {\nprocessBytes(byteArray, sz);\n}\n}\nfinally {\nif (fis != null) {\nsafeClose(fis);\n}\n}\n}\n\npublic static void safeClose(FileInputStream fis) {\nif (fis != null) {\ntry {\nfis.close();\n} catch (IOException e) {\nlog(e);\n}\n}\n}\n\n\nThis solution uses a helper function to log the exceptions that might occur when trying to close the stream. Presumably this helper function will be reused whenever a stream needs to be closed.\n\nAlso, the processFile method does not initialize the fis object to null. Instead, it checks to ensure that fis is not null before calling safeClose(). Without the null check, the Java compiler reports that fis might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If fis is initialized to null in a more complex method, cases in which fis is used without being initialized will not be detected by the compiler.\n\nFor more information, see https://emea.fortify.com//redirect/Issues/085c14d9-051c-43d8-b65e-152922fd18ab"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        } ]
      }
    },
    "results" : [ {
      "ruleId" : "22300900",
      "message" : {
        "text" : "The method serveFile() in UserController.java sends unvalidated data to a web browser on line 519, which can result in the browser executing malicious code.Sending unvalidated data to a web browser can result in the browser executing malicious code."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "AF354DA2E1AAA1C33827072E147B7A4B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/web/controllers/UserController.java"
          },
          "region" : {
            "startLine" : 519,
            "endLine" : 519,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "22300895",
      "message" : {
        "text" : "The method serveFile() in UserController.java includes unvalidated data in an HTTP response header on line 519. This enables attacks such as cache-poisoning, cross-site scripting, cross-user defacement, page hijacking, cookie manipulation or open redirect.Including unvalidated data in an HTTP response header can enable cache-poisoning, cross-site scripting, cross-user defacement, page hijacking, cookie manipulation or open redirect."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "10F9F530EFE22338F4D8B7751F34BE58"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/web/controllers/UserController.java"
          },
          "region" : {
            "startLine" : 519,
            "endLine" : 519,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "24780821",
      "message" : {
        "text" : "The method downloadFile() in ProductController.java includes unvalidated data in an HTTP response header on line 147. This enables attacks such as cache-poisoning, cross-site scripting, cross-user defacement, page hijacking, cookie manipulation or open redirect.Including unvalidated data in an HTTP response header can enable cache-poisoning, cross-site scripting, cross-user defacement, page hijacking, cookie manipulation or open redirect."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "928965F11DEF122C46CB7EF0992AC542"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/web/controllers/ProductController.java"
          },
          "region" : {
            "startLine" : 147,
            "endLine" : 147,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "12336035",
      "message" : {
        "text" : "Content Security Policy (CSP) is not configured."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "2F6ECF6FFC4E2C16509883187B3FCAF7"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/config/WebSecurityConfiguration.java"
          },
          "region" : {
            "startLine" : 97,
            "endLine" : 97,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "12336036",
      "message" : {
        "text" : "Content Security Policy (CSP) is not configured."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "68D081327E97D2FE084DA4047763767E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/config/WebSecurityConfiguration.java"
          },
          "region" : {
            "startLine" : 137,
            "endLine" : 137,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "12336034",
      "message" : {
        "text" : "The application does not restrict browsers from letting third-party sites render its content."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "1DBC20EF05F367A88A794AE9D90218DE"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/config/WebSecurityConfiguration.java"
          },
          "region" : {
            "startLine" : 141,
            "endLine" : 141,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "25337208",
      "message" : {
        "text" : "The connection established via send() in EmailUtils.java does not verify the server certificate when making an SSL connection. This leaves the application vulnerable to a man-in-the-middle attack.Server identity verification is disabled when making SSL connections."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "BB369E591650FE23DE611B787A369D5D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/utils/EmailUtils.java"
          },
          "region" : {
            "startLine" : 95,
            "endLine" : 95,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "11445528",
      "message" : {
        "text" : "The method onAuthenticationSuccess() in UrlAuthenticationSuccessHandler.java stores a non-serializable object as an HttpSession attribute, which can damage application reliability.Storing a non-serializable object as an HttpSession attribute can damage application reliability."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "ECC1C966A4D9B10A694089FA446A460F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/config/handlers/UrlAuthenticationSuccessHandler.java"
          },
          "region" : {
            "startLine" : 69,
            "endLine" : 69,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "24851297",
      "message" : {
        "text" : "The method generateAndSetSession() in JwtUtils.java stores a non-serializable object as an HttpSession attribute, which can damage application reliability.Storing a non-serializable object as an HttpSession attribute can damage application reliability."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "CBEA8FCAD42583261EC1A276CA8D7F34"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/utils/JwtUtils.java"
          },
          "region" : {
            "startLine" : 110,
            "endLine" : 110,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "14220168",
      "message" : {
        "text" : "On line 115 of UserUtils.java, the method registerUser() writes unvalidated input into JSON. This call could allow an attacker to inject arbitrary elements or attributes into the JSON entity.The method writes unvalidated input into JSON. This call could allow an attacker to inject arbitrary elements or attributes into the JSON entity."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "1254DB675D174D6D514D62B293256495"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/utils/UserUtils.java"
          },
          "region" : {
            "startLine" : 115,
            "endLine" : 115,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "11445520",
      "message" : {
        "text" : "The method startDbBackup() in AdminUtils.java writes unvalidated user input to the log on line 67. An attacker could take advantage of this behavior to forge log entries or inject malicious content into the log.Writing unvalidated user input to log files can allow an attacker to forge log entries or inject malicious content into the logs."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "281978E388B4D9413D050BC48EA5E93F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/utils/AdminUtils.java"
          },
          "region" : {
            "startLine" : 67,
            "endLine" : 67,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "25337209",
      "message" : {
        "text" : "The method verifyUser() in UserController.java writes unvalidated user input to the log on line 485. An attacker could take advantage of this behavior to forge log entries or inject malicious content into the log.Writing unvalidated user input to log files can allow an attacker to forge log entries or inject malicious content into the logs."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "FCA1AB0BBD39F693E0E2C2D659EC0F2E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/web/controllers/UserController.java"
          },
          "region" : {
            "startLine" : 485,
            "endLine" : 485,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "14220158",
      "message" : {
        "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 193 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "06FED6D89832F3B361940629DD97E1DA"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/api/controllers/ApiSiteController.java"
          },
          "region" : {
            "startLine" : 193,
            "endLine" : 193,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "14220162",
      "message" : {
        "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 212 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "1255E1F16970A9C1AD40369A0DDFB444"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/api/controllers/ApiSiteController.java"
          },
          "region" : {
            "startLine" : 212,
            "endLine" : 212,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "11445516",
      "message" : {
        "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 349 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "1CDEA9BFD8B1403A226A5E6ADCC25282"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/web/controllers/UserController.java"
          },
          "region" : {
            "startLine" : 349,
            "endLine" : 349,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "11445517",
      "message" : {
        "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 107 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "213884AF53C06CF7376E45372DF9EFB6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/web/controllers/admin/AdminUserController.java"
          },
          "region" : {
            "startLine" : 107,
            "endLine" : 107,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "13078268",
      "message" : {
        "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 137 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "2272240A2BB091793BDE5F4330D34284"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/api/controllers/ApiUserController.java"
          },
          "region" : {
            "startLine" : 137,
            "endLine" : 137,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "11445521",
      "message" : {
        "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 131 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "46FC0D04F9CDC65B6E4D1341A4C424DE"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/api/controllers/ApiRoleController.java"
          },
          "region" : {
            "startLine" : 131,
            "endLine" : 131,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "11445524",
      "message" : {
        "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 320 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "6EAA8502E05824C19FF4F0A486C9C79E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/web/controllers/UserController.java"
          },
          "region" : {
            "startLine" : 320,
            "endLine" : 320,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "11445525",
      "message" : {
        "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 114 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "7062F805327F3B7989D24745B63A0248"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/api/controllers/ApiRoleController.java"
          },
          "region" : {
            "startLine" : 114,
            "endLine" : 114,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "22300896",
      "message" : {
        "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 500 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "7506580BA4950FD0B787682833A77874"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/web/controllers/UserController.java"
          },
          "region" : {
            "startLine" : 500,
            "endLine" : 500,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "11445530",
      "message" : {
        "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 208 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "9B6F26ECAD825A46992AEE28687A0022"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/web/controllers/admin/AdminUserController.java"
          },
          "region" : {
            "startLine" : 208,
            "endLine" : 208,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "11445532",
      "message" : {
        "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 102 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "ADD48A64E845C07A71321447208B5B34"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/web/controllers/admin/AdminProductController.java"
          },
          "region" : {
            "startLine" : 102,
            "endLine" : 102,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "14220179",
      "message" : {
        "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 101 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "ADEC98F10B00EBA9C7873567092FAC2B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/web/controllers/admin/AdminOrderController.java"
          },
          "region" : {
            "startLine" : 101,
            "endLine" : 101,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "11445534",
      "message" : {
        "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 120 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "B5785F362628A638B0EE3275600E0098"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/api/controllers/ApiUserController.java"
          },
          "region" : {
            "startLine" : 120,
            "endLine" : 120,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "11445538",
      "message" : {
        "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 81 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "B5D61A6DB526887FF10901D72F2B75CE"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/web/controllers/admin/AdminDefaultController.java"
          },
          "region" : {
            "startLine" : 81,
            "endLine" : 81,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "13421042",
      "message" : {
        "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 103 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "BDF34A1A266D30C8F60C33A06D78C818"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/web/controllers/CartController.java"
          },
          "region" : {
            "startLine" : 103,
            "endLine" : 103,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "18303921",
      "message" : {
        "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 398 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "C6BC3F99B7B0294E3D67514488703BAC"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/web/controllers/UserController.java"
          },
          "region" : {
            "startLine" : 398,
            "endLine" : 398,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "22300898",
      "message" : {
        "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 101 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "CB2AFDC9222D6F5EF06EF33E0655EE78"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/web/controllers/admin/AdminReviewController.java"
          },
          "region" : {
            "startLine" : 101,
            "endLine" : 101,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "14220183",
      "message" : {
        "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 143 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "E24AFFD5B5B45E3D2812058A93F0EA69"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/web/controllers/admin/AdminUserController.java"
          },
          "region" : {
            "startLine" : 143,
            "endLine" : 143,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "11445540",
      "message" : {
        "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 162 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "E3138FA4B30F55E2857A60A837E38267"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/web/controllers/admin/AdminProductController.java"
          },
          "region" : {
            "startLine" : 162,
            "endLine" : 162,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "14220185",
      "message" : {
        "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 175 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "E5492F799415CE087AF6FCC4CE7F2279"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/api/controllers/ApiSiteController.java"
          },
          "region" : {
            "startLine" : 175,
            "endLine" : 175,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "22300899",
      "message" : {
        "text" : "The framework binder used for binding the HTTP request parameters to the model class in  on line 534 has not been explicitly configured to allow, or disallow, certain attributes.The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow certain attributes."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "EC053C499DB21E8AF26751828BD91C15"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/web/controllers/UserController.java"
          },
          "region" : {
            "startLine" : 534,
            "endLine" : 534,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "24851298",
      "message" : {
        "text" : "The method getTargetUrl() in CustomAuthenticationSuccessHandler.java can crash the program by dereferencing a null-pointer on line 122.The program can potentially dereference a null-pointer, thereby causing a null-pointer exception."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "A53D49B82586B3AA98DCDEB3033598A4"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/config/handlers/CustomAuthenticationSuccessHandler.java"
          },
          "region" : {
            "startLine" : 122,
            "endLine" : 122,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "25337207",
      "message" : {
        "text" : "The file DefaultController.java passes unvalidated data to an HTTP redirect function on line 166. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "8E74E75876596FFD961C3B5FA6AE2732"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/web/controllers/DefaultController.java"
          },
          "region" : {
            "startLine" : 166,
            "endLine" : 166,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "13078270",
      "message" : {
        "text" : "Hardcoded passwords can compromise system security in a way that is not easy to remedy."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "5E18D23F85398E73ECABFC5E656B7D5A"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/web/validation/PasswordConstraintValidator.java"
          },
          "region" : {
            "startLine" : 59,
            "endLine" : 59,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "24780819",
      "message" : {
        "text" : "Storing a plain text password in a configuration file may result in a system compromise."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "4389F0306BC01890564B60438324901D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/resources/application.yml"
          },
          "region" : {
            "startLine" : 38,
            "endLine" : 38,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "24780820",
      "message" : {
        "text" : "Storing a plain text password in a configuration file may result in a system compromise."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "7B5E26DE92BA5BABDEF54F3F13FD15C9"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/resources/application-dev.yml"
          },
          "region" : {
            "startLine" : 36,
            "endLine" : 36,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "24780822",
      "message" : {
        "text" : "Storing a plain text password in a configuration file may result in a system compromise."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "BCE395ADCDD91CA96D7CC920DBA74614"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/resources/application-test.yml"
          },
          "region" : {
            "startLine" : 36,
            "endLine" : 36,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "22300894",
      "message" : {
        "text" : "Attackers can control the file system path argument to get() at FileSystemStorageService.java line 53, which allows them to access or modify otherwise protected files.Allowing user input to control paths used in file system operations could enable an attacker to access or modify otherwise protected system resources."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "11D8010EC65EC012EE0EF471A08775A2"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/service/FileSystemStorageService.java"
          },
          "region" : {
            "startLine" : 53,
            "endLine" : 53,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "13421035",
      "message" : {
        "text" : "Attackers can control the file system path argument to File() at UserUtils.java line 79, which allows them to access or modify otherwise protected files.Allowing user input to control paths used in file system operations could enable an attacker to access or modify otherwise protected system resources."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "00411ED275CA1DCF328136A99613E95E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/utils/UserUtils.java"
          },
          "region" : {
            "startLine" : 79,
            "endLine" : 79,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "13421040",
      "message" : {
        "text" : "Attackers can control the file system path argument to File() at UserUtils.java line 50, which allows them to access or modify otherwise protected files.Allowing user input to control paths used in file system operations could enable an attacker to access or modify otherwise protected system resources."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "6D623C08536E645A78083F45802BD829"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/utils/UserUtils.java"
          },
          "region" : {
            "startLine" : 50,
            "endLine" : 50,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "22300897",
      "message" : {
        "text" : "Attackers can control the file system path argument to resolve() at FileSystemStorageService.java line 85, which allows them to access or modify otherwise protected files.Allowing user input to control paths used in file system operations could enable an attacker to access or modify otherwise protected system resources."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "A7F89829A6B25EEB1003C5704B409D3A"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/service/FileSystemStorageService.java"
          },
          "region" : {
            "startLine" : 85,
            "endLine" : 85,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "13421043",
      "message" : {
        "text" : "Attackers can control the file system path argument to FileReader() at UserUtils.java line 81, which allows them to access or modify otherwise protected files.Allowing user input to control paths used in file system operations could enable an attacker to access or modify otherwise protected system resources."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "F1919E7AAD4B30B9D5DD4675AE34C86E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/utils/UserUtils.java"
          },
          "region" : {
            "startLine" : 81,
            "endLine" : 81,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "24780823",
      "message" : {
        "text" : "Attackers can control the file system path argument to get() at ProductController.java line 125, which allows them to access or modify otherwise protected files.Allowing user input to control paths used in file system operations could enable an attacker to access or modify otherwise protected system resources."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "CED1DDB86E691B109491FC69D539145E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/web/controllers/ProductController.java"
          },
          "region" : {
            "startLine" : 125,
            "endLine" : 125,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "13421038",
      "message" : {
        "text" : "The class ProductService is a singleton, so the member field pageSize is shared between users. The result is that one user could see another user's data.Servlet member fields might allow one user to see another user's data."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "57EED148BFB0D519D4F5730EB03C729C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/service/ProductService.java"
          },
          "region" : {
            "startLine" : 81,
            "endLine" : 81,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "11425738",
      "message" : {
        "text" : "The Spring Boot application is configured in developer mode."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "3BEEB4D638B3FD80F4D21F7FC6967D98"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "pom.xml"
          },
          "region" : {
            "startLine" : 274,
            "endLine" : 274,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "24851296",
      "message" : {
        "text" : "On line 121 of ProductRepository.java, the method findAvailableByKeywords() invokes a SQL query built with input that comes from an untrusted source. This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.Constructing a dynamic SQL statement with input that comes from an untrusted source could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands. "
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "C1184BFE79952A1F290AE8065142822A"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/repository/ProductRepository.java"
          },
          "region" : {
            "startLine" : 121,
            "endLine" : 121,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "24851299",
      "message" : {
        "text" : "On line 110 of ProductRepository.java, the method findByKeywords() invokes a SQL query built with input that comes from an untrusted source. This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.Constructing a dynamic SQL statement with input that comes from an untrusted source could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands. "
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "D9A2CDD293E20E03D21F1EF32E167F5A"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/repository/ProductRepository.java"
          },
          "region" : {
            "startLine" : 110,
            "endLine" : 110,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "24851300",
      "message" : {
        "text" : "On line 95 of ProductRepository.java, the method findByCode() invokes a SQL query built with input that comes from an untrusted source. This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.Constructing a dynamic SQL statement with input that comes from an untrusted source could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands. "
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "FD6EE4674903CBA0770E37A9EB63C106"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/repository/ProductRepository.java"
          },
          "region" : {
            "startLine" : 95,
            "endLine" : 95,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "11445512",
      "message" : {
        "text" : "The function commence() in BasicAuthenticationEntryPointCustom.java reveals system data or debug information by calling println() on line 69. The information revealed by println() could help an adversary form a plan of attack.Revealing system data or debugging information helps an adversary learn about the system and form a plan of attack."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "035CD161F52C89F6A63F56C9CFBCBA4F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/config/handlers/BasicAuthenticationEntryPointCustom.java"
          },
          "region" : {
            "startLine" : 69,
            "endLine" : 69,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "12336037",
      "message" : {
        "text" : "The function commence() in AuthenticationEntryPointJwt.java reveals system data or debug information by calling println() on line 69. The information revealed by println() could help an adversary form a plan of attack.Revealing system data or debugging information helps an adversary learn about the system and form a plan of attack."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "A1B2E0688E58E6EF786545ECE9316B0D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/config/handlers/AuthenticationEntryPointJwt.java"
          },
          "region" : {
            "startLine" : 69,
            "endLine" : 69,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "11445541",
      "message" : {
        "text" : "The function handle() in ApiAccessDeniedHandler.java reveals system data or debug information by calling println() on line 66. The information revealed by println() could help an adversary form a plan of attack.Revealing system data or debugging information helps an adversary learn about the system and form a plan of attack."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "F58F6F68F91119A983C3558FF30D4DF1"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/config/handlers/ApiAccessDeniedHandler.java"
          },
          "region" : {
            "startLine" : 66,
            "endLine" : 66,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "11429996",
      "message" : {
        "text" : "The function logZipContents() in UserUtils.java sometimes fails to release a file handle allocated by ZipFile() on line 129.The program can potentially fail to release a file handle."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "86DA2FCE10361A698F6C11C0C93B59A9"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/utils/UserUtils.java"
          },
          "region" : {
            "startLine" : 129,
            "endLine" : 129,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    }, {
      "ruleId" : "13421041",
      "message" : {
        "text" : "The function registerUser() in UserUtils.java sometimes fails to release a system resource allocated by FileReader() on line 81.The program can potentially fail to release a system resource."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "82F3624ECFD65FD73DA8D29C3AF7349E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "src/main/java/com/microfocus/example/utils/UserUtils.java"
          },
          "region" : {
            "startLine" : 81,
            "endLine" : 81,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ]
    } ]
  } ]
}